# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/decodetree.rst:3
msgid "Decodetree Specification"
msgstr ""

#: ../../../devel/decodetree.rst:5
msgid ""
"A *decodetree* is built from instruction *patterns*.  A pattern may "
"represent a single architectural instruction or a group of same, depending "
"on what is convenient for further processing."
msgstr ""

#: ../../../devel/decodetree.rst:9
msgid ""
"Each pattern has both *fixedbits* and *fixedmask*, the combination of which "
"describes the condition under which the pattern is matched::"
msgstr ""

#: ../../../devel/decodetree.rst:12
msgid "(insn & fixedmask) == fixedbits"
msgstr ""

#: ../../../devel/decodetree.rst:14
msgid ""
"Each pattern may have *fields*, which are extracted from the insn and passed "
"along to the translator.  Examples of such are registers, immediates, and "
"sub-opcodes."
msgstr ""

#: ../../../devel/decodetree.rst:18
msgid ""
"In support of patterns, one may declare *fields*, *argument sets*, and "
"*formats*, each of which may be re-used to simplify further definitions."
msgstr ""

#: ../../../devel/decodetree.rst:22
msgid "Fields"
msgstr ""

#: ../../../devel/decodetree.rst:24 ../../../devel/decodetree.rst:86
#: ../../../devel/decodetree.rst:120 ../../../devel/decodetree.rst:167
#: ../../../devel/decodetree.rst:200
msgid "Syntax::"
msgstr ""

#: ../../../devel/decodetree.rst:26
msgid ""
"field_def     := '%' identifier ( field )* ( !function=identifier )?\n"
"field         := unnamed_field | named_field\n"
"unnamed_field := number ':' ( 's' ) number\n"
"named_field   := identifier ':' ( 's' ) number"
msgstr ""

#: ../../../devel/decodetree.rst:31
msgid ""
"For *unnamed_field*, the first number is the least-significant bit position "
"of the field and the second number is the length of the field.  If the 's' "
"is present, the field is considered signed."
msgstr ""

#: ../../../devel/decodetree.rst:35
msgid ""
"A *named_field* refers to some other field in the instruction pattern or "
"format. Regardless of the length of the other field where it is defined, it "
"will be inserted into this field with the specified signedness and bit width."
msgstr ""

#: ../../../devel/decodetree.rst:40
msgid ""
"Field definitions that involve loops (i.e. where a field is defined directly "
"or indirectly in terms of itself) are errors."
msgstr ""

#: ../../../devel/decodetree.rst:43
msgid ""
"A format can include fields that refer to named fields that are defined in "
"the instruction pattern(s) that use the format. Conversely, an instruction "
"pattern can include fields that refer to named fields that are defined in "
"the format it uses. However you cannot currently do both at once (i.e. "
"pattern P uses format F; F has a field A that refers to a named field B that "
"is defined in P, and P has a field C that refers to a named field D that is "
"defined in F)."
msgstr ""

#: ../../../devel/decodetree.rst:51
msgid ""
"If multiple ``fields`` are present, they are concatenated. In this way one "
"can define disjoint fields."
msgstr ""

#: ../../../devel/decodetree.rst:54
msgid ""
"If ``!function`` is specified, the concatenated result is passed through the "
"named function, taking and returning an integral value."
msgstr ""

#: ../../../devel/decodetree.rst:57
msgid ""
"One may use ``!function`` with zero ``fields``.  This case is called a "
"*parameter*, and the named function is only passed the ``DisasContext`` and "
"returns an integral value extracted from there."
msgstr ""

#: ../../../devel/decodetree.rst:61
msgid "A field with no ``fields`` and no ``!function`` is in error."
msgstr ""

#: ../../../devel/decodetree.rst:63
msgid "Field examples:"
msgstr ""

#: ../../../devel/decodetree.rst:66
msgid "Input"
msgstr ""

#: ../../../devel/decodetree.rst:66
msgid "Generated code"
msgstr ""

#: ../../../devel/decodetree.rst:68
msgid "%disp   0:s16"
msgstr ""

#: ../../../devel/decodetree.rst:68
msgid "sextract(i, 0, 16)"
msgstr ""

#: ../../../devel/decodetree.rst:70
msgid "%imm9   16:6 10:3"
msgstr ""

#: ../../../devel/decodetree.rst:70
msgid "extract(i, 16, 6) << 3 | extract(i, 10, 3)"
msgstr ""

#: ../../../devel/decodetree.rst:72
msgid "%disp12 0:s1 1:1 2:10"
msgstr ""

#: ../../../devel/decodetree.rst:72
msgid "sextract(i, 0, 1) << 11 |"
msgstr ""

#: ../../../devel/decodetree.rst:73
msgid "extract(i, 1, 1) << 10 | extract(i, 2, 10)"
msgstr ""

#: ../../../devel/decodetree.rst:76
msgid "%shimm8 5:s8 13:1"
msgstr ""

#: ../../../devel/decodetree.rst:77
msgid "!function=expand_shimm8"
msgstr ""

#: ../../../devel/decodetree.rst:76
msgid "expand_shimm8(sextract(i, 5, 8) << 1 |"
msgstr ""

#: ../../../devel/decodetree.rst:77
msgid "extract(i, 13, 1))"
msgstr ""

#: ../../../devel/decodetree.rst:79
msgid "%sz_imm 10:2 sz:3"
msgstr ""

#: ../../../devel/decodetree.rst:80
msgid "!function=expand_sz_imm"
msgstr ""

#: ../../../devel/decodetree.rst:79
msgid "expand_sz_imm(extract(i, 10, 2) << 3 |"
msgstr ""

#: ../../../devel/decodetree.rst:80
msgid "extract(a->sz, 0, 3))"
msgstr ""

#: ../../../devel/decodetree.rst:84
msgid "Argument Sets"
msgstr ""

#: ../../../devel/decodetree.rst:88
msgid ""
"args_def    := '&' identifier ( args_elt )+ ( !extern )?\n"
"args_elt    := identifier (':' identifier)?"
msgstr ""

#: ../../../devel/decodetree.rst:91
msgid ""
"Each *args_elt* defines an argument within the argument set. If the form of "
"the *args_elt* contains a colon, the first identifier is the argument name "
"and the second identifier is the argument type.  If the colon is missing, "
"the argument type will be ``int``."
msgstr ""

#: ../../../devel/decodetree.rst:97
msgid ""
"Each argument set will be rendered as a C structure \"arg_$name\" with each "
"of the fields being one of the member arguments."
msgstr ""

#: ../../../devel/decodetree.rst:100
msgid ""
"If ``!extern`` is specified, the backing structure is assumed to have been "
"already declared, typically via a second decoder."
msgstr ""

#: ../../../devel/decodetree.rst:103
msgid ""
"Argument sets are useful when one wants to define helper functions for the "
"translator functions that can perform operations on a common set of "
"arguments.  This can ensure, for instance, that the ``AND`` pattern and the "
"``OR`` pattern put their operands into the same named structure, so that a "
"common ``gen_logic_insn`` may be able to handle the operations common "
"between the two."
msgstr ""

#: ../../../devel/decodetree.rst:110
msgid "Argument set examples::"
msgstr ""

#: ../../../devel/decodetree.rst:112
msgid ""
"&reg3       ra rb rc\n"
"&loadstore  reg base offset\n"
"&longldst   reg base offset:int64_t"
msgstr ""

#: ../../../devel/decodetree.rst:118
msgid "Formats"
msgstr ""

#: ../../../devel/decodetree.rst:122
msgid ""
"fmt_def      := '@' identifier ( fmt_elt )+\n"
"fmt_elt      := fixedbit_elt | field_elt | field_ref | args_ref\n"
"fixedbit_elt := [01.-]+\n"
"field_elt    := identifier ':' 's'? number\n"
"field_ref    := '%' identifier | identifier '=' '%' identifier\n"
"args_ref     := '&' identifier"
msgstr ""

#: ../../../devel/decodetree.rst:129
msgid ""
"Defining a format is a handy way to avoid replicating groups of fields "
"across many instruction patterns."
msgstr ""

#: ../../../devel/decodetree.rst:132
msgid ""
"A *fixedbit_elt* describes a contiguous sequence of bits that must be 1, 0, "
"or don't care.  The difference between '.' and '-' is that '.' means that "
"the bit will be covered with a field or a final 0 or 1 from the pattern, and "
"'-' means that the bit is really ignored by the cpu and will not be "
"specified."
msgstr ""

#: ../../../devel/decodetree.rst:138
msgid ""
"A *field_elt* describes a simple field only given a width; the position of "
"the field is implied by its position with respect to other *fixedbit_elt* "
"and *field_elt*."
msgstr ""

#: ../../../devel/decodetree.rst:142
msgid ""
"If any *fixedbit_elt* or *field_elt* appear, then all bits must be defined. "
"Padding with a *fixedbit_elt* of all '.' is an easy way to accomplish that."
msgstr ""

#: ../../../devel/decodetree.rst:145
msgid ""
"A *field_ref* incorporates a field by reference.  This is the only way to "
"add a complex field to a format.  A field may be renamed in the process via "
"assignment to another identifier.  This is intended to allow the same "
"argument set be used with disjoint named fields."
msgstr ""

#: ../../../devel/decodetree.rst:150
msgid ""
"A single *args_ref* may specify an argument set to use for the format. The "
"set of fields in the format must be a subset of the arguments in the "
"argument set.  If an argument set is not specified, one will be inferred "
"from the set of fields."
msgstr ""

#: ../../../devel/decodetree.rst:155
msgid ""
"It is recommended, but not required, that all *field_ref* and *args_ref* "
"appear at the end of the line, not interleaving with *fixedbit_elf* or "
"*field_elt*."
msgstr ""

#: ../../../devel/decodetree.rst:159
msgid "Format examples::"
msgstr ""

#: ../../../devel/decodetree.rst:161
msgid ""
"@opr    ...... ra:5 rb:5 ... 0 ....... rc:5\n"
"@opi    ...... ra:5 lit:8    1 ....... rc:5"
msgstr ""

#: ../../../devel/decodetree.rst:165
msgid "Patterns"
msgstr ""

#: ../../../devel/decodetree.rst:169
msgid ""
"pat_def      := identifier ( pat_elt )+\n"
"pat_elt      := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | "
"const_elt\n"
"fmt_ref      := '@' identifier\n"
"const_elt    := identifier '=' number"
msgstr ""

#: ../../../devel/decodetree.rst:174
msgid ""
"The *fixedbit_elt* and *field_elt* specifiers are unchanged from formats. A "
"pattern that does not specify a named format will have one inferred from a "
"referenced argument set (if present) and the set of fields."
msgstr ""

#: ../../../devel/decodetree.rst:178
msgid ""
"A *const_elt* allows a argument to be set to a constant value.  This may "
"come in handy when fields overlap between patterns and one has to include "
"the values in the *fixedbit_elt* instead."
msgstr ""

#: ../../../devel/decodetree.rst:182
msgid "The decoder will call a translator function for each pattern matched."
msgstr ""

#: ../../../devel/decodetree.rst:184
msgid "Pattern examples::"
msgstr ""

#: ../../../devel/decodetree.rst:186
msgid ""
"addl_r   010000 ..... ..... .... 0000000 ..... @opr\n"
"addl_i   010000 ..... ..... .... 0000000 ..... @opi"
msgstr ""

#: ../../../devel/decodetree.rst:189
msgid "which will, in part, invoke::"
msgstr ""

#: ../../../devel/decodetree.rst:191
msgid "trans_addl_r(ctx, &arg_opr, insn)"
msgstr ""

#: ../../../devel/decodetree.rst:193
msgid "and::"
msgstr ""

#: ../../../devel/decodetree.rst:195
msgid "trans_addl_i(ctx, &arg_opi, insn)"
msgstr ""

#: ../../../devel/decodetree.rst:198
msgid "Pattern Groups"
msgstr ""

#: ../../../devel/decodetree.rst:202
msgid ""
"group            := overlap_group | no_overlap_group\n"
"overlap_group    := '{' ( pat_def | group )+ '}'\n"
"no_overlap_group := '[' ( pat_def | group )+ ']'"
msgstr ""

#: ../../../devel/decodetree.rst:206
msgid ""
"A *group* begins with a lone open-brace or open-bracket, with all subsequent "
"lines indented two spaces, and ending with a lone close-brace or close-"
"bracket.  Groups may be nested, increasing the required indentation of the "
"lines within the nested group to two spaces per nesting level."
msgstr ""

#: ../../../devel/decodetree.rst:212
msgid ""
"Patterns within overlap groups are allowed to overlap.  Conflicts are "
"resolved by selecting the patterns in order.  If all of the fixedbits for a "
"pattern match, its translate function will be called.  If the translate "
"function returns false, then subsequent patterns within the group will be "
"matched."
msgstr ""

#: ../../../devel/decodetree.rst:218
msgid ""
"Patterns within no-overlap groups are not allowed to overlap, just the same "
"as ungrouped patterns.  Thus no-overlap groups are intended to be nested "
"inside overlap groups."
msgstr ""

#: ../../../devel/decodetree.rst:222
msgid ""
"The following example from PA-RISC shows specialization of the *or* "
"instruction::"
msgstr ""

#: ../../../devel/decodetree.rst:225
msgid ""
"{\n"
"  {\n"
"    nop   000010 ----- ----- 0000 001001 0 00000\n"
"    copy  000010 00000 r1:5  0000 001001 0 rt:5\n"
"  }\n"
"  or      000010 rt2:5 r1:5  cf:4 001001 0 rt:5\n"
"}"
msgstr ""

#: ../../../devel/decodetree.rst:233
msgid ""
"When the *cf* field is zero, the instruction has no side effects, and may be "
"specialized.  When the *rt* field is zero, the output is discarded and so "
"the instruction has no effect.  When the *rt2* field is zero, the operation "
"is ``reg[r1] | 0`` and so encodes the canonical register copy operation."
msgstr ""

#: ../../../devel/decodetree.rst:239
msgid "The output from the generator might look like::"
msgstr ""

#: ../../../devel/decodetree.rst:241
msgid ""
"switch (insn & 0xfc000fe0) {\n"
"case 0x08000240:\n"
"  /* 000010.. ........ ....0010 010..... */\n"
"  if ((insn & 0x0000f000) == 0x00000000) {\n"
"      /* 000010.. ........ 00000010 010..... */\n"
"      if ((insn & 0x0000001f) == 0x00000000) {\n"
"          /* 000010.. ........ 00000010 01000000 */\n"
"          extract_decode_Fmt_0(&u.f_decode0, insn);\n"
"          if (trans_nop(ctx, &u.f_decode0)) return true;\n"
"      }\n"
"      if ((insn & 0x03e00000) == 0x00000000) {\n"
"          /* 00001000 000..... 00000010 010..... */\n"
"          extract_decode_Fmt_1(&u.f_decode1, insn);\n"
"          if (trans_copy(ctx, &u.f_decode1)) return true;\n"
"      }\n"
"  }\n"
"  extract_decode_Fmt_2(&u.f_decode2, insn);\n"
"  if (trans_or(ctx, &u.f_decode2)) return true;\n"
"  return false;\n"
"}"
msgstr ""
