# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/tcg-plugins.rst:9
msgid "QEMU TCG Plugins"
msgstr ""

#: ../../../devel/tcg-plugins.rst:11
msgid ""
"QEMU TCG plugins provide a way for users to run experiments taking advantage "
"of the total system control emulation can have over a guest. It provides a "
"mechanism for plugins to subscribe to events during translation and "
"execution and optionally callback into the plugin during these events. TCG "
"plugins are unable to change the system state only monitor it passively. "
"However they can do this down to an individual instruction granularity "
"including potentially subscribing to all load and store operations."
msgstr ""

#: ../../../devel/tcg-plugins.rst:21
msgid "Usage"
msgstr ""

#: ../../../devel/tcg-plugins.rst:23
msgid ""
"Any QEMU binary with TCG support has plugins enabled by default. Earlier "
"releases needed to be explicitly enabled with::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:26
msgid "configure --enable-plugins"
msgstr ""

#: ../../../devel/tcg-plugins.rst:28
msgid ""
"Once built a program can be run with multiple plugins loaded each with their "
"own arguments::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:31
msgid ""
"$QEMU $OTHER_QEMU_ARGS \\\n"
"    -plugin contrib/plugin/libhowvec.so,inline=on,count=hint \\\n"
"    -plugin contrib/plugin/libhotblocks.so"
msgstr ""

#: ../../../devel/tcg-plugins.rst:35
msgid ""
"Arguments are plugin specific and can be used to modify their behaviour. In "
"this case the howvec plugin is being asked to use inline ops to count and "
"break down the hint instructions by type."
msgstr ""

#: ../../../devel/tcg-plugins.rst:39
msgid ""
"Linux user-mode emulation also evaluates the environment variable "
"``QEMU_PLUGIN``::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:42
msgid ""
"QEMU_PLUGIN=\"file=contrib/plugins/libhowvec.so,inline=on,count=hint\" $QEMU"
msgstr ""

#: ../../../devel/tcg-plugins.rst:45
msgid "Writing plugins"
msgstr ""

#: ../../../devel/tcg-plugins.rst:48
msgid "API versioning"
msgstr ""

#: ../../../devel/tcg-plugins.rst:50
msgid ""
"This is a new feature for QEMU and it does allow people to develop out-of-"
"tree plugins that can be dynamically linked into a running QEMU process. "
"However the project reserves the right to change or break the API should it "
"need to do so. The best way to avoid this is to submit your plugin upstream "
"so they can be updated if/when the API changes."
msgstr ""

#: ../../../devel/tcg-plugins.rst:56
msgid ""
"All plugins need to declare a symbol which exports the plugin API version "
"they were built against. This can be done simply by::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:59
msgid "QEMU_PLUGIN_EXPORT int qemu_plugin_version = QEMU_PLUGIN_VERSION;"
msgstr ""

#: ../../../devel/tcg-plugins.rst:61
msgid ""
"The core code will refuse to load a plugin that doesn't export a "
"``qemu_plugin_version`` symbol or if plugin version is outside of QEMU's "
"supported range of API versions."
msgstr ""

#: ../../../devel/tcg-plugins.rst:65
msgid ""
"Additionally the ``qemu_info_t`` structure which is passed to the "
"``qemu_plugin_install`` method of a plugin will detail the minimum and "
"current API versions supported by QEMU. The API version will be incremented "
"if new APIs are added. The minimum API version will be incremented if "
"existing APIs are changed or removed."
msgstr ""

#: ../../../devel/tcg-plugins.rst:72
msgid "Lifetime of the query handle"
msgstr ""

#: ../../../devel/tcg-plugins.rst:74
msgid ""
"Each callback provides an opaque anonymous information handle which can "
"usually be further queried to find out information about a translation, "
"instruction or operation. The handles themselves are only valid during the "
"lifetime of the callback so it is important that any information that is "
"needed is extracted during the callback and saved by the plugin."
msgstr ""

#: ../../../devel/tcg-plugins.rst:82
msgid "Plugin life cycle"
msgstr ""

#: ../../../devel/tcg-plugins.rst:84
msgid ""
"First the plugin is loaded and the public qemu_plugin_install function is "
"called. The plugin will then register callbacks for various plugin events. "
"Generally plugins will register a handler for the *atexit* if they want to "
"dump a summary of collected information once the program/system has finished "
"running."
msgstr ""

#: ../../../devel/tcg-plugins.rst:90
msgid ""
"When a registered event occurs the plugin callback is invoked. The callbacks "
"may provide additional information. In the case of a translation event the "
"plugin has an option to enumerate the instructions in a block of "
"instructions and optionally register callbacks to some or all instructions "
"when they are executed."
msgstr ""

#: ../../../devel/tcg-plugins.rst:96
msgid ""
"There is also a facility to add an inline event where code to increment a "
"counter can be directly inlined with the translation. Currently only a "
"simple increment is supported. This is not atomic so can miss counts. If you "
"want absolute precision you should use a callback which can then ensure "
"atomicity itself."
msgstr ""

#: ../../../devel/tcg-plugins.rst:102
msgid ""
"Finally when QEMU exits all the registered *atexit* callbacks are invoked."
msgstr ""

#: ../../../devel/tcg-plugins.rst:106
msgid "Exposure of QEMU internals"
msgstr ""

#: ../../../devel/tcg-plugins.rst:108
msgid ""
"The plugin architecture actively avoids leaking implementation details about "
"how QEMU's translation works to the plugins. While there are conceptions "
"such as translation time and translation blocks the details are opaque to "
"plugins. The plugin is able to query select details of instructions and "
"system configuration only through the exported *qemu_plugin* functions."
msgstr ""

#: ../../../devel/tcg-plugins.rst:115
msgid "However the following assumptions can be made:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:118
msgid "Translation Blocks"
msgstr ""

#: ../../../devel/tcg-plugins.rst:120
msgid ""
"All code will go through a translation phase although not all translations "
"will be necessarily be executed. You need to instrument actual executions to "
"track what is happening."
msgstr ""

#: ../../../devel/tcg-plugins.rst:124
msgid ""
"It is quite normal to see the same address translated multiple times. If you "
"want to track the code in system emulation you should examine the underlying "
"physical address (``qemu_plugin_insn_haddr``) to take into account the "
"effects of virtual memory although if the system does paging this will "
"change too."
msgstr ""

#: ../../../devel/tcg-plugins.rst:130
msgid ""
"Not all instructions in a block will always execute so if its important to "
"track individual instruction execution you need to instrument them directly. "
"However asynchronous interrupts will not change control flow mid-block."
msgstr ""

#: ../../../devel/tcg-plugins.rst:136
msgid "Instructions"
msgstr ""

#: ../../../devel/tcg-plugins.rst:138
msgid ""
"Instruction instrumentation runs before the instruction executes. You can be "
"can be sure the instruction will be dispatched, but you can't be sure it "
"will complete. Generally this will be because of a synchronous exception (e."
"g. SIGILL) triggered by the instruction attempting to execute. If you want "
"to be sure you will need to instrument the next instruction as well. See the "
"``execlog.c`` plugin for examples of how to track this and finalise details "
"after execution."
msgstr ""

#: ../../../devel/tcg-plugins.rst:147
msgid "Memory Accesses"
msgstr ""

#: ../../../devel/tcg-plugins.rst:149
msgid ""
"Memory callbacks are called after a successful load or store. Unsuccessful "
"operations (i.e. faults) will not be visible to memory instrumentation "
"although the execution side effects can be observed (e.g. entering a "
"exception handler)."
msgstr ""

#: ../../../devel/tcg-plugins.rst:155
msgid "System Idle and Resume States"
msgstr ""

#: ../../../devel/tcg-plugins.rst:157
msgid ""
"The ``qemu_plugin_register_vcpu_idle_cb`` and "
"``qemu_plugin_register_vcpu_resume_cb`` functions can be used to track when "
"CPUs go into and return from sleep states when waiting for external I/O. Be "
"aware though that these may occur less frequently than in real HW due to the "
"inefficiencies of emulation giving less chance for the CPU to idle."
msgstr ""

#: ../../../devel/tcg-plugins.rst:165
msgid "Internals"
msgstr ""

#: ../../../devel/tcg-plugins.rst:168
msgid "Locking"
msgstr ""

#: ../../../devel/tcg-plugins.rst:170
msgid ""
"We have to ensure we cannot deadlock, particularly under MTTCG. For this we "
"acquire a lock when called from plugin code. We also keep the list of "
"callbacks under RCU so that we do not have to hold the lock when calling the "
"callbacks. This is also for performance, since some callbacks (e.g. memory "
"access callbacks) might be called very frequently."
msgstr ""

#: ../../../devel/tcg-plugins.rst:177
msgid ""
"A consequence of this is that we keep our own list of CPUs, so that we do "
"not have to worry about locking order wrt cpu_list_lock."
msgstr ""

#: ../../../devel/tcg-plugins.rst:179
msgid ""
"Use a recursive lock, since we can get registration calls from callbacks."
msgstr ""

#: ../../../devel/tcg-plugins.rst:182
msgid ""
"As a result registering/unregistering callbacks is \"slow\", since it takes "
"a lock. But this is very infrequent; we want performance when calling (or "
"not calling) callbacks, not when registering them. Using RCU is great for "
"this."
msgstr ""

#: ../../../devel/tcg-plugins.rst:187
msgid ""
"We support the uninstallation of a plugin at any time (e.g. from plugin "
"callbacks). This allows plugins to remove themselves if they no longer want "
"to instrument the code. This operation is asynchronous which means callbacks "
"may still occur after the uninstall operation is requested. The plugin isn't "
"completely uninstalled until the safe work has executed while all vCPUs are "
"quiescent."
msgstr ""

#: ../../../devel/tcg-plugins.rst:195
msgid "Example Plugins"
msgstr ""

#: ../../../devel/tcg-plugins.rst:197
msgid ""
"There are a number of plugins included with QEMU and you are encouraged to "
"contribute your own plugins plugins upstream. There is a ``contrib/plugins`` "
"directory where they can go. There are also some basic plugins that are used "
"to test and exercise the API during the ``make check-tcg`` target in "
"``tests\\plugins``."
msgstr ""

#: ../../../devel/tcg-plugins.rst:203
msgid "tests/plugins/empty.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:205
msgid ""
"Purely a test plugin for measuring the overhead of the plugins system "
"itself. Does no instrumentation."
msgstr ""

#: ../../../devel/tcg-plugins.rst:208
msgid "tests/plugins/bb.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:210
msgid ""
"A very basic plugin which will measure execution in course terms as each "
"basic block is executed. By default the results are shown once execution "
"finishes::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:214
msgid ""
"$ qemu-aarch64 -plugin tests/plugin/libbb.so \\\n"
"    -d plugin ./tests/tcg/aarch64-linux-user/sha1\n"
"SHA1=15dd99a1991e0b3826fede3deffc1feba42278e6\n"
"bb's: 2277338, insns: 158483046"
msgstr ""

#: ../../../devel/tcg-plugins.rst:219 ../../../devel/tcg-plugins.rst:249
#: ../../../devel/tcg-plugins.rst:290
msgid "Behaviour can be tweaked with the following arguments:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:221 ../../../devel/tcg-plugins.rst:251
#: ../../../devel/tcg-plugins.rst:292
msgid "inline=true|false"
msgstr ""

#: ../../../devel/tcg-plugins.rst:223 ../../../devel/tcg-plugins.rst:253
#: ../../../devel/tcg-plugins.rst:294
msgid ""
"Use faster inline addition of a single counter. Not per-cpu and not thread "
"safe."
msgstr ""

#: ../../../devel/tcg-plugins.rst:226
msgid "idle=true|false"
msgstr ""

#: ../../../devel/tcg-plugins.rst:228
msgid "Dump the current execution stats whenever the guest vCPU idles"
msgstr ""

#: ../../../devel/tcg-plugins.rst:230
msgid "tests/plugins/insn.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:232
msgid ""
"This is a basic instruction level instrumentation which can count the number "
"of instructions executed on each core/thread::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:235
msgid ""
"$ qemu-aarch64 -plugin tests/plugin/libinsn.so \\\n"
"    -d plugin ./tests/tcg/aarch64-linux-user/threadcount\n"
"Created 10 threads\n"
"Done\n"
"cpu 0 insns: 46765\n"
"cpu 1 insns: 3694\n"
"cpu 2 insns: 3694\n"
"cpu 3 insns: 2994\n"
"cpu 4 insns: 1497\n"
"cpu 5 insns: 1497\n"
"cpu 6 insns: 1497\n"
"cpu 7 insns: 1497\n"
"total insns: 63135"
msgstr ""

#: ../../../devel/tcg-plugins.rst:256
msgid "sizes=true|false"
msgstr ""

#: ../../../devel/tcg-plugins.rst:258
msgid "Give a summary of the instruction sizes for the execution"
msgstr ""

#: ../../../devel/tcg-plugins.rst:260
msgid "match=<string>"
msgstr ""

#: ../../../devel/tcg-plugins.rst:262
msgid ""
"Only instrument instructions matching the string prefix. Will show some "
"basic stats including how many instructions have executed since the last "
"execution. For example::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:266
msgid ""
"$ qemu-aarch64 -plugin tests/plugin/libinsn.so,match=bl \\\n"
"    -d plugin ./tests/tcg/aarch64-linux-user/sha512-vector\n"
"...\n"
"0x40069c, 'bl #0x4002b0', 10 hits, 1093 match hits, Δ+1257 since last match, "
"98 avg insns/match\n"
"0x4006ac, 'bl #0x403690', 10 hits, 1094 match hits, Δ+47 since last match, "
"98 avg insns/match\n"
"0x4037fc, 'bl #0x4002b0', 18 hits, 1095 match hits, Δ+22 since last match, "
"98 avg insns/match\n"
"0x400720, 'bl #0x403690', 10 hits, 1096 match hits, Δ+58 since last match, "
"98 avg insns/match\n"
"0x4037fc, 'bl #0x4002b0', 19 hits, 1097 match hits, Δ+22 since last match, "
"98 avg insns/match\n"
"0x400730, 'bl #0x403690', 10 hits, 1098 match hits, Δ+33 since last match, "
"98 avg insns/match\n"
"0x4037ac, 'bl #0x4002b0', 12 hits, 1099 match hits, Δ+20 since last match, "
"98 avg insns/match\n"
"..."
msgstr ""

#: ../../../devel/tcg-plugins.rst:278
msgid ""
"For more detailed execution tracing see the ``execlog`` plugin for other "
"options."
msgstr ""

#: ../../../devel/tcg-plugins.rst:281
msgid "tests/plugins/mem.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:283
msgid "Basic instruction level memory instrumentation::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:285
msgid ""
"$ qemu-aarch64 -plugin tests/plugin/libmem.so,inline=true \\\n"
"    -d plugin ./tests/tcg/aarch64-linux-user/sha1\n"
"SHA1=15dd99a1991e0b3826fede3deffc1feba42278e6\n"
"inline mem accesses: 79525013"
msgstr ""

#: ../../../devel/tcg-plugins.rst:297
msgid "callback=true|false"
msgstr ""

#: ../../../devel/tcg-plugins.rst:299
msgid "Use callbacks on each memory instrumentation."
msgstr ""

#: ../../../devel/tcg-plugins.rst:301
msgid "hwaddr=true|false"
msgstr ""

#: ../../../devel/tcg-plugins.rst:303
msgid "Count IO accesses (only for system emulation)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:305
msgid "tests/plugins/syscall.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:307
msgid ""
"A basic syscall tracing plugin. This only works for user-mode. By default it "
"will give a summary of syscall stats at the end of the run::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:311
msgid ""
"$ qemu-aarch64 -plugin tests/plugin/libsyscall \\\n"
"    -d plugin ./tests/tcg/aarch64-linux-user/threadcount\n"
"Created 10 threads\n"
"Done\n"
"syscall no.  calls  errors\n"
"226          12     0\n"
"99           11     11\n"
"115          11     0\n"
"222          11     0\n"
"93           10     0\n"
"220          10     0\n"
"233          10     0\n"
"215          8      0\n"
"214          4      0\n"
"134          2      0\n"
"64           2      0\n"
"96           1      0\n"
"94           1      0\n"
"80           1      0\n"
"261          1      0\n"
"78           1      0\n"
"160          1      0\n"
"135          1      0"
msgstr ""

#: ../../../devel/tcg-plugins.rst:335
msgid "contrib/plugins/hotblocks.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:337
msgid ""
"The hotblocks plugin allows you to examine the where hot paths of execution "
"are in your program. Once the program has finished you will get a sorted "
"list of blocks reporting the starting PC, translation count, number of "
"instructions and execution count. This will work best with linux-user "
"execution as system emulation tends to generate re-translations as blocks "
"from different programs get swapped in and out of system memory."
msgstr ""

#: ../../../devel/tcg-plugins.rst:345
msgid ""
"If your program is single-threaded you can use the ``inline`` option for "
"slightly faster (but not thread safe) counters."
msgstr ""

#: ../../../devel/tcg-plugins.rst:348
msgid "Example::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:350
msgid ""
"$ qemu-aarch64 \\\n"
"  -plugin contrib/plugins/libhotblocks.so -d plugin \\\n"
"  ./tests/tcg/aarch64-linux-user/sha1\n"
"SHA1=15dd99a1991e0b3826fede3deffc1feba42278e6\n"
"collected 903 entries in the hash table\n"
"pc, tcount, icount, ecount\n"
"0x0000000041ed10, 1, 5, 66087\n"
"0x000000004002b0, 1, 4, 66087\n"
"..."
msgstr ""

#: ../../../devel/tcg-plugins.rst:360
msgid "contrib/plugins/hotpages.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:362
msgid "Similar to hotblocks but this time tracks memory accesses::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:364
msgid ""
"$ qemu-aarch64 \\\n"
"  -plugin contrib/plugins/libhotpages.so -d plugin \\\n"
"  ./tests/tcg/aarch64-linux-user/sha1\n"
"SHA1=15dd99a1991e0b3826fede3deffc1feba42278e6\n"
"Addr, RCPUs, Reads, WCPUs, Writes\n"
"0x000055007fe000, 0x0001, 31747952, 0x0001, 8835161\n"
"0x000055007ff000, 0x0001, 29001054, 0x0001, 8780625\n"
"0x00005500800000, 0x0001, 687465, 0x0001, 335857\n"
"0x0000000048b000, 0x0001, 130594, 0x0001, 355\n"
"0x0000000048a000, 0x0001, 1826, 0x0001, 11"
msgstr ""

#: ../../../devel/tcg-plugins.rst:375
msgid "The hotpages plugin can be configured using the following arguments:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:377
msgid "sortby=reads|writes|address"
msgstr ""

#: ../../../devel/tcg-plugins.rst:379
msgid ""
"Log the data sorted by either the number of reads, the number of writes, or "
"memory address. (Default: entries are sorted by the sum of reads and writes)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:382
msgid "io=on"
msgstr ""

#: ../../../devel/tcg-plugins.rst:384
msgid ""
"Track IO addresses. Only relevant to full system emulation. (Default: off)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:386
msgid "pagesize=N"
msgstr ""

#: ../../../devel/tcg-plugins.rst:388
msgid "The page size used. (Default: N = 4096)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:390
msgid "contrib/plugins/howvec.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:392
msgid ""
"This is an instruction classifier so can be used to count different types of "
"instructions. It has a number of options to refine which get counted. You "
"can give a value to the ``count`` argument for a class of instructions to "
"break it down fully, so for example to see all the system registers "
"accesses::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:398
msgid ""
"$ qemu-system-aarch64 $(QEMU_ARGS) \\\n"
"  -append \"root=/dev/sda2 systemd.unit=benchmark.service\" \\\n"
"  -smp 4 -plugin ./contrib/plugins/libhowvec.so,count=sreg -d plugin"
msgstr ""

#: ../../../devel/tcg-plugins.rst:402
msgid "which will lead to a sorted list after the class breakdown::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:404
msgid ""
"Instruction Classes:\n"
"Class:   UDEF                   not counted\n"
"Class:   SVE                    (68 hits)\n"
"Class:   PCrel addr             (47789483 hits)\n"
"Class:   Add/Sub (imm)          (192817388 hits)\n"
"Class:   Logical (imm)          (93852565 hits)\n"
"Class:   Move Wide (imm)        (76398116 hits)\n"
"Class:   Bitfield               (44706084 hits)\n"
"Class:   Extract                (5499257 hits)\n"
"Class:   Cond Branch (imm)      (147202932 hits)\n"
"Class:   Exception Gen          (193581 hits)\n"
"Class:     NOP                  not counted\n"
"Class:   Hints                  (6652291 hits)\n"
"Class:   Barriers               (8001661 hits)\n"
"Class:   PSTATE                 (1801695 hits)\n"
"Class:   System Insn            (6385349 hits)\n"
"Class:   System Reg             counted individually\n"
"Class:   Branch (reg)           (69497127 hits)\n"
"Class:   Branch (imm)           (84393665 hits)\n"
"Class:   Cmp & Branch           (110929659 hits)\n"
"Class:   Tst & Branch           (44681442 hits)\n"
"Class:   AdvSimd ldstmult       (736 hits)\n"
"Class:   ldst excl              (9098783 hits)\n"
"Class:   Load Reg (lit)         (87189424 hits)\n"
"Class:   ldst noalloc pair      (3264433 hits)\n"
"Class:   ldst pair              (412526434 hits)\n"
"Class:   ldst reg (imm)         (314734576 hits)\n"
"Class: Loads & Stores           (2117774 hits)\n"
"Class: Data Proc Reg            (223519077 hits)\n"
"Class: Scalar FP                (31657954 hits)\n"
"Individual Instructions:\n"
"Instr: mrs x0, sp_el0           (2682661 hits)  (op=0xd5384100/  System "
"Reg)\n"
"Instr: mrs x1, tpidr_el2        (1789339 hits)  (op=0xd53cd041/  System "
"Reg)\n"
"Instr: mrs x2, tpidr_el2        (1513494 hits)  (op=0xd53cd042/  System "
"Reg)\n"
"Instr: mrs x0, tpidr_el2        (1490823 hits)  (op=0xd53cd040/  System "
"Reg)\n"
"Instr: mrs x1, sp_el0           (933793 hits)   (op=0xd5384101/  System "
"Reg)\n"
"Instr: mrs x2, sp_el0           (699516 hits)   (op=0xd5384102/  System "
"Reg)\n"
"Instr: mrs x4, tpidr_el2        (528437 hits)   (op=0xd53cd044/  System "
"Reg)\n"
"Instr: mrs x30, ttbr1_el1       (480776 hits)   (op=0xd538203e/  System "
"Reg)\n"
"Instr: msr ttbr1_el1, x30       (480713 hits)   (op=0xd518203e/  System "
"Reg)\n"
"Instr: msr vbar_el1, x30        (480671 hits)   (op=0xd518c01e/  System "
"Reg)\n"
"..."
msgstr ""

#: ../../../devel/tcg-plugins.rst:447
msgid ""
"To find the argument shorthand for the class you need to examine the source "
"code of the plugin at the moment, specifically the ``*opt`` argument in the "
"InsnClassExecCount tables."
msgstr ""

#: ../../../devel/tcg-plugins.rst:451
msgid "contrib/plugins/lockstep.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:453
msgid ""
"This is a debugging tool for developers who want to find out when and where "
"execution diverges after a subtle change to TCG code generation. It is not "
"an exact science and results are likely to be mixed once asynchronous events "
"are introduced. While the use of -icount can introduce determinism to the "
"execution flow it doesn't always follow the translation sequence will be "
"exactly the same. Typically this is caused by a timer firing to service the "
"GUI causing a block to end early. However in some cases it has proved to be "
"useful in pointing people at roughly where execution diverges. The only "
"argument you need for the plugin is a path for the socket the two instances "
"will communicate over::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:466
msgid ""
"$ qemu-system-sparc -monitor none -parallel none \\\n"
"  -net none -M SS-20 -m 256 -kernel day11/zImage.elf \\\n"
"  -plugin ./contrib/plugins/liblockstep.so,sockpath=lockstep-sparc.sock \\\n"
"  -d plugin,nochain"
msgstr ""

#: ../../../devel/tcg-plugins.rst:471
msgid "which will eventually report::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:473
msgid ""
"qemu-system-sparc: warning: nic lance.0 has no peer\n"
"@ 0x000000ffd06678 vs 0x000000ffd001e0 (2/1 since last)\n"
"@ 0x000000ffd07d9c vs 0x000000ffd06678 (3/1 since last)\n"
"Δ insn_count @ 0x000000ffd07d9c (809900609) vs 0x000000ffd06678 (809900612)\n"
"  previously @ 0x000000ffd06678/10 (809900609 insns)\n"
"  previously @ 0x000000ffd001e0/4 (809900599 insns)\n"
"  previously @ 0x000000ffd080ac/2 (809900595 insns)\n"
"  previously @ 0x000000ffd08098/5 (809900593 insns)\n"
"  previously @ 0x000000ffd080c0/1 (809900588 insns)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:483
msgid "contrib/plugins/hwprofile.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:485
msgid ""
"The hwprofile tool can only be used with system emulation and allows the "
"user to see what hardware is accessed how often. It has a number of options:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:488
msgid "track=read or track=write"
msgstr ""

#: ../../../devel/tcg-plugins.rst:490
msgid ""
"By default the plugin tracks both reads and writes. You can use one of these "
"options to limit the tracking to just one class of accesses."
msgstr ""

#: ../../../devel/tcg-plugins.rst:493
msgid "source"
msgstr ""

#: ../../../devel/tcg-plugins.rst:495
msgid ""
"Will include a detailed break down of what the guest PC that made the access "
"was. Not compatible with the pattern option. Example output::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:498
msgid ""
"cirrus-low-memory @ 0xfffffd00000a0000\n"
" pc:fffffc0000005cdc, 1, 256\n"
" pc:fffffc0000005ce8, 1, 256\n"
" pc:fffffc0000005cec, 1, 256"
msgstr ""

#: ../../../devel/tcg-plugins.rst:503
msgid "pattern"
msgstr ""

#: ../../../devel/tcg-plugins.rst:505
msgid ""
"Instead break down the accesses based on the offset into the HW region. This "
"can be useful for seeing the most used registers of a device. Example "
"output::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:509
msgid ""
"pci0-conf @ 0xfffffd01fe000000\n"
"  off:00000004, 1, 1\n"
"  off:00000010, 1, 3\n"
"  off:00000014, 1, 3\n"
"  off:00000018, 1, 2\n"
"  off:0000001c, 1, 2\n"
"  off:00000020, 1, 2\n"
"  ..."
msgstr ""

#: ../../../devel/tcg-plugins.rst:518
msgid "contrib/plugins/execlog.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:520
msgid ""
"The execlog tool traces executed instructions with memory access. It can be "
"used for debugging and security analysis purposes. Please be aware that this "
"will generate a lot of output."
msgstr ""

#: ../../../devel/tcg-plugins.rst:524
msgid "The plugin needs default argument::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:526
msgid ""
"$ qemu-system-arm $(QEMU_ARGS) \\\n"
"  -plugin ./contrib/plugins/libexeclog.so -d plugin"
msgstr ""

#: ../../../devel/tcg-plugins.rst:529
msgid "which will output an execution trace following this structure::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:531
msgid ""
"# vCPU, vAddr, opcode, disassembly[, load/store, memory addr, device]...\n"
"0, 0xa12, 0xf8012400, \"movs r4, #0\"\n"
"0, 0xa14, 0xf87f42b4, \"cmp r4, r6\"\n"
"0, 0xa16, 0xd206, \"bhs #0xa26\"\n"
"0, 0xa18, 0xfff94803, \"ldr r0, [pc, #0xc]\", load, 0x00010a28, RAM\n"
"0, 0xa1a, 0xf989f000, \"bl #0xd30\"\n"
"0, 0xd30, 0xfff9b510, \"push {r4, lr}\", store, 0x20003ee0, RAM, store, "
"0x20003ee4, RAM\n"
"0, 0xd32, 0xf9893014, \"adds r0, #0x14\"\n"
"0, 0xd34, 0xf9c8f000, \"bl #0x10c8\"\n"
"0, 0x10c8, 0xfff96c43, \"ldr r3, [r0, #0x44]\", load, 0x200000e4, RAM"
msgstr ""

#: ../../../devel/tcg-plugins.rst:542
msgid ""
"the output can be filtered to only track certain instructions or addresses "
"using the ``ifilter`` or ``afilter`` options. You can stack the arguments if "
"required::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:546
msgid ""
"$ qemu-system-arm $(QEMU_ARGS) \\\n"
"  -plugin ./contrib/plugins/libexeclog.so,ifilter=st1w,afilter=0x40001808 -d "
"plugin"
msgstr ""

#: ../../../devel/tcg-plugins.rst:549
msgid ""
"This plugin can also dump registers when they change value. Specify the name "
"of the registers with multiple ``reg`` options. You can also use glob style "
"matching if you wish::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:552
msgid ""
"$ qemu-system-arm $(QEMU_ARGS) \\\n"
"  -plugin ./contrib/plugins/libexeclog.so,reg=\\*_el2,reg=sp -d plugin"
msgstr ""

#: ../../../devel/tcg-plugins.rst:555
msgid ""
"Be aware that each additional register to check will slow down execution "
"quite considerably. You can optimise the number of register checks done by "
"using the rdisas option. This will only instrument instructions that mention "
"the registers in question in disassembly. This is not foolproof as some "
"instructions implicitly change instructions. You can use the ifilter to "
"catch these cases:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:562
msgid "$ qemu-system-arm $(QEMU_ARGS) \\"
msgstr ""

#: ../../../devel/tcg-plugins.rst:563
msgid ""
"-plugin ./contrib/plugins/libexeclog.so,ifilter=msr,ifilter=blr,reg=x30,"
"reg=\\*_el1,rdisas=on"
msgstr ""

#: ../../../devel/tcg-plugins.rst:565
msgid "contrib/plugins/cache.c"
msgstr ""

#: ../../../devel/tcg-plugins.rst:567
msgid ""
"Cache modelling plugin that measures the performance of a given L1 cache "
"configuration, and optionally a unified L2 per-core cache when a given "
"working set is run::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:571
msgid ""
"$ qemu-x86_64 -plugin ./contrib/plugins/libcache.so \\\n"
"    -d plugin -D cache.log ./tests/tcg/x86_64-linux-user/float_convs"
msgstr ""

#: ../../../devel/tcg-plugins.rst:574
msgid "will report the following::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:576
msgid ""
"core #, data accesses, data misses, dmiss rate, insn accesses, insn misses, "
"imiss rate\n"
"0       996695         508             0.0510%  2642799        "
"18617           0.7044%\n"
"\n"
"address, data misses, instruction\n"
"0x424f1e (_int_malloc), 109, movq %rax, 8(%rcx)\n"
"0x41f395 (_IO_default_xsputn), 49, movb %dl, (%rdi, %rax)\n"
"0x42584d (ptmalloc_init.part.0), 33, movaps %xmm0, (%rax)\n"
"0x454d48 (__tunables_init), 20, cmpb $0, (%r8)\n"
"...\n"
"\n"
"address, fetch misses, instruction\n"
"0x4160a0 (__vfprintf_internal), 744, movl $1, %ebx\n"
"0x41f0a0 (_IO_setb), 744, endbr64\n"
"0x415882 (__vfprintf_internal), 744, movq %r12, %rdi\n"
"0x4268a0 (__malloc), 696, andq $0xfffffffffffffff0, %rax\n"
"..."
msgstr ""

#: ../../../devel/tcg-plugins.rst:593
msgid "The plugin has a number of arguments, all of them are optional:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:595
msgid "limit=N"
msgstr ""

#: ../../../devel/tcg-plugins.rst:597
msgid ""
"Print top N icache and dcache thrashing instructions along with their "
"address, number of misses, and its disassembly. (default: 32)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:600
msgid "icachesize=N"
msgstr ""

#: ../../../devel/tcg-plugins.rst:601
msgid "iblksize=B"
msgstr ""

#: ../../../devel/tcg-plugins.rst:602
msgid "iassoc=A"
msgstr ""

#: ../../../devel/tcg-plugins.rst:604
msgid ""
"Instruction cache configuration arguments. They specify the cache size, "
"block size, and associativity of the instruction cache, respectively. "
"(default: N = 16384, B = 64, A = 8)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:608
msgid "dcachesize=N"
msgstr ""

#: ../../../devel/tcg-plugins.rst:609
msgid "dblksize=B"
msgstr ""

#: ../../../devel/tcg-plugins.rst:610
msgid "dassoc=A"
msgstr ""

#: ../../../devel/tcg-plugins.rst:612
msgid ""
"Data cache configuration arguments. They specify the cache size, block size, "
"and associativity of the data cache, respectively. (default: N = 16384, B = "
"64, A = 8)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:616
msgid "evict=POLICY"
msgstr ""

#: ../../../devel/tcg-plugins.rst:618
msgid ""
"Sets the eviction policy to POLICY. Available policies are: :code:`lru`, :"
"code:`fifo`, and :code:`rand`. The plugin will use the specified policy for "
"both instruction and data caches. (default: POLICY = :code:`lru`)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:622
msgid "cores=N"
msgstr ""

#: ../../../devel/tcg-plugins.rst:624
msgid ""
"Sets the number of cores for which we maintain separate icache and dcache. "
"(default: for linux-user, N = 1, for full system emulation: N = cores "
"available to guest)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:628
msgid "l2=on"
msgstr ""

#: ../../../devel/tcg-plugins.rst:630
msgid ""
"Simulates a unified L2 cache (stores blocks for both instructions and data) "
"using the default L2 configuration (cache size = 2MB, associativity = 16-"
"way, block size = 64B)."
msgstr ""

#: ../../../devel/tcg-plugins.rst:634
msgid "l2cachesize=N"
msgstr ""

#: ../../../devel/tcg-plugins.rst:635
msgid "l2blksize=B"
msgstr ""

#: ../../../devel/tcg-plugins.rst:636
msgid "l2assoc=A"
msgstr ""

#: ../../../devel/tcg-plugins.rst:638
msgid ""
"L2 cache configuration arguments. They specify the cache size, block size, "
"and associativity of the L2 cache, respectively. Setting any of the L2 "
"configuration arguments implies ``l2=on``. (default: N = 2097152 (2MB), B = "
"64, A = 16)"
msgstr ""

#: ../../../devel/tcg-plugins.rst:644
msgid "Plugin API"
msgstr ""

#: ../../../devel/tcg-plugins.rst:646
msgid ""
"The following API is generated from the inline documentation in ``include/"
"qemu/qemu-plugin.h``. Please ensure any updates to the API include the full "
"kernel-doc annotations."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:41
msgid "Unique plugin ID"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:67
msgid "system information for plugins"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:69
msgid "**Definition**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:73
msgid ""
"struct qemu_info_t {\n"
"  const char *target_name;\n"
"  struct {\n"
"    int min;\n"
"    int cur;\n"
"  } version;\n"
"  bool system_emulation;\n"
"  union {\n"
"    struct {\n"
"      int smp_vcpus;\n"
"      int max_vcpus;\n"
"    } system;\n"
"  };\n"
"};"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:88
msgid "**Members**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:74
msgid "``target_name``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:75
msgid "string describing architecture"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:0
msgid "``version``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1
msgid "minimum and current plugin API level"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:0
msgid "``system_emulation``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1
msgid "is this a full system emulation?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:3
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:4
msgid "anonymous"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:0
msgid "``system``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1
msgid "information relevant to system emulation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:4
#: ../../../../include/qemu/qemu-plugin.h:102
#: ../../../../include/qemu/qemu-plugin.h:120
#: ../../../../include/qemu/qemu-plugin.h:154
#: ../../../../include/qemu/qemu-plugin.h:168
#: ../../../../include/qemu/qemu-plugin.h:182
#: ../../../../include/qemu/qemu-plugin.h:195
#: ../../../../include/qemu/qemu-plugin.h:208
#: ../../../../include/qemu/qemu-plugin.h:219
#: ../../../../include/qemu/qemu-plugin.h:235
#: ../../../../include/qemu/qemu-plugin.h:278
#: ../../../../include/qemu/qemu-plugin.h:296
#: ../../../../include/qemu/qemu-plugin.h:323
#: ../../../../include/qemu/qemu-plugin.h:339
#: ../../../../include/qemu/qemu-plugin.h:354
#: ../../../../include/qemu/qemu-plugin.h:386
#: ../../../../include/qemu/qemu-plugin.h:439
#: ../../../../include/qemu/qemu-plugin.h:484
#: ../../../../include/qemu/qemu-plugin.h:506
#: ../../../../include/qemu/qemu-plugin.h:516
#: ../../../../include/qemu/qemu-plugin.h:551
#: ../../../../include/qemu/qemu-plugin.h:578
#: ../../../../include/qemu/qemu-plugin.h:613
#: ../../../../include/qemu/qemu-plugin.h:623
#: ../../../../include/qemu/qemu-plugin.h:634
#: ../../../../include/qemu/qemu-plugin.h:652
#: ../../../../include/qemu/qemu-plugin.h:681
#: ../../../../include/qemu/qemu-plugin.h:695
#: ../../../../include/qemu/qemu-plugin.h:706
#: ../../../../include/qemu/qemu-plugin.h:715
#: ../../../../include/qemu/qemu-plugin.h:724
#: ../../../../include/qemu/qemu-plugin.h:749
#: ../../../../include/qemu/qemu-plugin.h:759
#: ../../../../include/qemu/qemu-plugin.h:774
#: ../../../../include/qemu/qemu-plugin.h:792
msgid "**Description**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:69
msgid ""
"This structure provides for some limited information about the system to "
"allow the plugin to make decisions on how to proceed. For example it might "
"only be suitable for running on some guest architectures or when under full "
"system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:96
msgid "Install a plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:98
#: ../../../../include/qemu/qemu-plugin.h:124
#: ../../../../include/qemu/qemu-plugin.h:132
#: ../../../../include/qemu/qemu-plugin.h:140
#: ../../../../include/qemu/qemu-plugin.h:148
#: ../../../../include/qemu/qemu-plugin.h:152
#: ../../../../include/qemu/qemu-plugin.h:166
#: ../../../../include/qemu/qemu-plugin.h:180
#: ../../../../include/qemu/qemu-plugin.h:193
#: ../../../../include/qemu/qemu-plugin.h:206
#: ../../../../include/qemu/qemu-plugin.h:217
#: ../../../../include/qemu/qemu-plugin.h:273
#: ../../../../include/qemu/qemu-plugin.h:276
#: ../../../../include/qemu/qemu-plugin.h:292
#: ../../../../include/qemu/qemu-plugin.h:319
#: ../../../../include/qemu/qemu-plugin.h:335
#: ../../../../include/qemu/qemu-plugin.h:350
#: ../../../../include/qemu/qemu-plugin.h:366
#: ../../../../include/qemu/qemu-plugin.h:375
#: ../../../../include/qemu/qemu-plugin.h:384
#: ../../../../include/qemu/qemu-plugin.h:399
#: ../../../../include/qemu/qemu-plugin.h:412
#: ../../../../include/qemu/qemu-plugin.h:421
#: ../../../../include/qemu/qemu-plugin.h:430
#: ../../../../include/qemu/qemu-plugin.h:449
#: ../../../../include/qemu/qemu-plugin.h:457
#: ../../../../include/qemu/qemu-plugin.h:465
#: ../../../../include/qemu/qemu-plugin.h:473
#: ../../../../include/qemu/qemu-plugin.h:482
#: ../../../../include/qemu/qemu-plugin.h:505
#: ../../../../include/qemu/qemu-plugin.h:515
#: ../../../../include/qemu/qemu-plugin.h:539
#: ../../../../include/qemu/qemu-plugin.h:546
#: ../../../../include/qemu/qemu-plugin.h:573
#: ../../../../include/qemu/qemu-plugin.h:612
#: ../../../../include/qemu/qemu-plugin.h:622
#: ../../../../include/qemu/qemu-plugin.h:632
#: ../../../../include/qemu/qemu-plugin.h:649
#: ../../../../include/qemu/qemu-plugin.h:669
#: ../../../../include/qemu/qemu-plugin.h:676
#: ../../../../include/qemu/qemu-plugin.h:690
#: ../../../../include/qemu/qemu-plugin.h:701
#: ../../../../include/qemu/qemu-plugin.h:710
#: ../../../../include/qemu/qemu-plugin.h:719
#: ../../../../include/qemu/qemu-plugin.h:744
#: ../../../../include/qemu/qemu-plugin.h:756
#: ../../../../include/qemu/qemu-plugin.h:772
#: ../../../../include/qemu/qemu-plugin.h:783
#: ../../../../include/qemu/qemu-plugin.h:790
#: ../../../../include/qemu/qemu-plugin.h:808
#: ../../../../include/qemu/qemu-plugin.h:818
#: ../../../../include/qemu/qemu-plugin.h:826
#: ../../../../include/qemu/qemu-plugin.h:836
msgid "**Parameters**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:100
#: ../../../../include/qemu/qemu-plugin.h:126
#: ../../../../include/qemu/qemu-plugin.h:134
#: ../../../../include/qemu/qemu-plugin.h:142
#: ../../../../include/qemu/qemu-plugin.h:154
#: ../../../../include/qemu/qemu-plugin.h:168
#: ../../../../include/qemu/qemu-plugin.h:182
#: ../../../../include/qemu/qemu-plugin.h:195
#: ../../../../include/qemu/qemu-plugin.h:208
#: ../../../../include/qemu/qemu-plugin.h:219
#: ../../../../include/qemu/qemu-plugin.h:275
#: ../../../../include/qemu/qemu-plugin.h:278
#: ../../../../include/qemu/qemu-plugin.h:634
#: ../../../../include/qemu/qemu-plugin.h:651
msgid "``qemu_plugin_id_t id``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:97
#: ../../../../include/qemu/qemu-plugin.h:151
#: ../../../../include/qemu/qemu-plugin.h:165
msgid "this plugin's opaque ID"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:99
msgid "``const qemu_info_t *info``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:98
msgid "a block describing some details about the guest"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:100
msgid "``int argc``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:99
msgid "number of arguments"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:101
msgid "``char **argv``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:100
msgid "array of arguments (**argc** elements)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:102
msgid ""
"All plugins must export this symbol which is called when the plugin is first "
"loaded. Calling qemu_plugin_uninstall() from this function is a bug."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:106
#: ../../../../include/qemu/qemu-plugin.h:158
#: ../../../../include/qemu/qemu-plugin.h:257
#: ../../../../include/qemu/qemu-plugin.h:312
#: ../../../../include/qemu/qemu-plugin.h:400
msgid "**Note**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:106
msgid ""
"**info** is only live during the call. Copy any information we want to keep. "
"**argv** remains valid throughout the lifetime of the loaded plugin."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:110
#: ../../../../include/qemu/qemu-plugin.h:367
#: ../../../../include/qemu/qemu-plugin.h:376
#: ../../../../include/qemu/qemu-plugin.h:390
#: ../../../../include/qemu/qemu-plugin.h:403
#: ../../../../include/qemu/qemu-plugin.h:413
#: ../../../../include/qemu/qemu-plugin.h:422
#: ../../../../include/qemu/qemu-plugin.h:431
#: ../../../../include/qemu/qemu-plugin.h:450
#: ../../../../include/qemu/qemu-plugin.h:458
#: ../../../../include/qemu/qemu-plugin.h:466
#: ../../../../include/qemu/qemu-plugin.h:474
msgid "**Return**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:110
msgid "0 on successful loading, !0 for an error."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:117
msgid "**Typedef**: simple callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:120
#: ../../../../include/qemu/qemu-plugin.h:128
#: ../../../../include/qemu/qemu-plugin.h:136
#: ../../../../include/qemu/qemu-plugin.h:144
#: ../../../../include/qemu/qemu-plugin.h:269
#: ../../../../include/qemu/qemu-plugin.h:535
msgid "**Syntax**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:122
msgid "``void qemu_plugin_simple_cb_t (qemu_plugin_id_t id)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:118
#: ../../../../include/qemu/qemu-plugin.h:126
#: ../../../../include/qemu/qemu-plugin.h:134
msgid "the unique qemu_plugin_id_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:120
msgid "This callback passes no information aside from the unique **id**."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:125
msgid "**Typedef**: callback with user data"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:130
msgid "``void qemu_plugin_udata_cb_t (qemu_plugin_id_t id, void *userdata)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:128
#: ../../../../include/qemu/qemu-plugin.h:144
#: ../../../../include/qemu/qemu-plugin.h:295
#: ../../../../include/qemu/qemu-plugin.h:338
#: ../../../../include/qemu/qemu-plugin.h:537
#: ../../../../include/qemu/qemu-plugin.h:550
#: ../../../../include/qemu/qemu-plugin.h:651
msgid "``void *userdata``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:127
#: ../../../../include/qemu/qemu-plugin.h:143
msgid "a pointer to some user data supplied when the callback was registered."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:133
#: ../../../../include/qemu/qemu-plugin.h:141
msgid "**Typedef**: vcpu callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:138
msgid ""
"``void qemu_plugin_vcpu_simple_cb_t (qemu_plugin_id_t id, unsigned int "
"vcpu_index)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:136
#: ../../../../include/qemu/qemu-plugin.h:150
#: ../../../../include/qemu/qemu-plugin.h:541
#: ../../../../include/qemu/qemu-plugin.h:791
#: ../../../../include/qemu/qemu-plugin.h:809
#: ../../../../include/qemu/qemu-plugin.h:819
#: ../../../../include/qemu/qemu-plugin.h:827
msgid "``unsigned int vcpu_index``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:135
#: ../../../../include/qemu/qemu-plugin.h:142
msgid "the current vcpu context"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:146
msgid ""
"``void qemu_plugin_vcpu_udata_cb_t (unsigned int vcpu_index, void "
"*userdata)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:150
msgid "Uninstall a plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:153
#: ../../../../include/qemu/qemu-plugin.h:167
msgid "``qemu_plugin_simple_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:152
msgid "callback to be called once the plugin has been removed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:154
msgid ""
"Do NOT assume that the plugin has been uninstalled once this function "
"returns. Plugins are uninstalled asynchronously, and therefore the given "
"plugin receives callbacks until **cb** is called."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:158
msgid "Calling this function from qemu_plugin_install() is a bug."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:164
msgid "Reset a plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:166
msgid "callback to be called once the plugin has been reset"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:168
msgid "Unregisters all callbacks for the plugin given by **id**."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:170
msgid ""
"Do NOT assume that the plugin has been reset once this function returns. "
"Plugins are reset asynchronously, and therefore the given plugin receives "
"callbacks until **cb** is called."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:178
msgid "register a vCPU initialization callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:179
#: ../../../../include/qemu/qemu-plugin.h:192
#: ../../../../include/qemu/qemu-plugin.h:205
#: ../../../../include/qemu/qemu-plugin.h:216
#: ../../../../include/qemu/qemu-plugin.h:275
#: ../../../../include/qemu/qemu-plugin.h:631
#: ../../../../include/qemu/qemu-plugin.h:648
msgid "plugin ID"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:181
#: ../../../../include/qemu/qemu-plugin.h:194
#: ../../../../include/qemu/qemu-plugin.h:207
#: ../../../../include/qemu/qemu-plugin.h:218
#: ../../../../include/qemu/qemu-plugin.h:633
msgid "``qemu_plugin_vcpu_simple_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:180
#: ../../../../include/qemu/qemu-plugin.h:193
#: ../../../../include/qemu/qemu-plugin.h:206
#: ../../../../include/qemu/qemu-plugin.h:217
#: ../../../../include/qemu/qemu-plugin.h:276
#: ../../../../include/qemu/qemu-plugin.h:292
#: ../../../../include/qemu/qemu-plugin.h:335
#: ../../../../include/qemu/qemu-plugin.h:632
msgid "callback function"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:182
msgid "The **cb** function is called every time a vCPU is initialized."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:184
msgid "See also: qemu_plugin_register_vcpu_exit_cb()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:191
msgid "register a vCPU exit callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:195
msgid "The **cb** function is called every time a vCPU exits."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:197
#: ../../../../include/qemu/qemu-plugin.h:636
msgid "See also: qemu_plugin_register_vcpu_init_cb()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:204
msgid "register a vCPU idle callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:208
msgid "The **cb** function is called every time a vCPU idles."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:215
msgid "register a vCPU resume callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:219
msgid "The **cb** function is called every time a vCPU resumes execution."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:233
msgid "uint64_t member of an entry in a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:235
msgid ""
"This field allows to access a specific uint64_t member in one given entry, "
"located at a specified offset. Inline operations expect this as entry."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:244
msgid "type of callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:246
#: ../../../../include/qemu/qemu-plugin.h:307
msgid "**Constants**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:248
msgid "``QEMU_PLUGIN_CB_NO_REGS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:249
msgid "callback does not access the CPU's regs"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:251
msgid "``QEMU_PLUGIN_CB_R_REGS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:252
msgid "callback reads the CPU's regs"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:254
msgid "``QEMU_PLUGIN_CB_RW_REGS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:255
msgid "callback reads and writes the CPU's regs"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:250
msgid ""
"currently QEMU_PLUGIN_CB_RW_REGS is unused, plugins cannot change system "
"register state."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:266
msgid "**Typedef**: translation callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:271
msgid ""
"``void qemu_plugin_vcpu_tb_trans_cb_t (qemu_plugin_id_t id, struct "
"qemu_plugin_tb *tb)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:267
msgid "unique plugin id"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:269
#: ../../../../include/qemu/qemu-plugin.h:294
#: ../../../../include/qemu/qemu-plugin.h:321
msgid "``struct qemu_plugin_tb *tb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:268
msgid "opaque handle used for querying and instrumenting a block."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:274
msgid "register a translate cb"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:277
msgid "``qemu_plugin_vcpu_tb_trans_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:278
msgid ""
"The **cb** function is called every time a translation occurs. The **cb** "
"function is passed an opaque qemu_plugin_type which it can query for "
"additional information including the list of translated instructions. At "
"this point the plugin can register further callbacks to be triggered when "
"the block or individual instruction executes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:290
msgid "register execution callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:291
#: ../../../../include/qemu/qemu-plugin.h:318
msgid "the opaque qemu_plugin_tb handle for the translation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:293
#: ../../../../include/qemu/qemu-plugin.h:336
msgid "``qemu_plugin_vcpu_udata_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:294
#: ../../../../include/qemu/qemu-plugin.h:337
#: ../../../../include/qemu/qemu-plugin.h:548
msgid "``enum qemu_plugin_cb_flags flags``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:293
#: ../../../../include/qemu/qemu-plugin.h:336
msgid "does the plugin read or write the CPU's registers?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:294
#: ../../../../include/qemu/qemu-plugin.h:337
msgid "any plugin data to pass to the **cb**?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:296
msgid "The **cb** function is called every time a translated unit executes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:305
msgid "describes an inline op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:309
msgid "``QEMU_PLUGIN_INLINE_ADD_U64``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:310
msgid "add an immediate value uint64_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:309
msgid "currently only a single inline op is supported."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:317
msgid "execution inline op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:320
#: ../../../../include/qemu/qemu-plugin.h:351
#: ../../../../include/qemu/qemu-plugin.h:575
msgid "``enum qemu_plugin_op op``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:319
#: ../../../../include/qemu/qemu-plugin.h:350
msgid "the type of qemu_plugin_op (e.g. ADD_U64)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:321
#: ../../../../include/qemu/qemu-plugin.h:352
#: ../../../../include/qemu/qemu-plugin.h:576
#: ../../../../include/qemu/qemu-plugin.h:810
#: ../../../../include/qemu/qemu-plugin.h:820
#: ../../../../include/qemu/qemu-plugin.h:828
#: ../../../../include/qemu/qemu-plugin.h:838
msgid "``qemu_plugin_u64 entry``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:320
#: ../../../../include/qemu/qemu-plugin.h:351
#: ../../../../include/qemu/qemu-plugin.h:575
msgid "entry to run op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:322
#: ../../../../include/qemu/qemu-plugin.h:353
#: ../../../../include/qemu/qemu-plugin.h:577
msgid "``uint64_t imm``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:321
#: ../../../../include/qemu/qemu-plugin.h:352
msgid "the op data (e.g. 1)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:323
msgid "Insert an inline op on a given scoreboard entry."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:333
msgid "register insn execution cb"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:337
#: ../../../../include/qemu/qemu-plugin.h:352
#: ../../../../include/qemu/qemu-plugin.h:548
#: ../../../../include/qemu/qemu-plugin.h:575
msgid "``struct qemu_plugin_insn *insn``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:334
#: ../../../../include/qemu/qemu-plugin.h:349
msgid "the opaque qemu_plugin_insn handle for an instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:339
msgid "The **cb** function is called every time an instruction is executed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:348
msgid "insn exec inline op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:354
msgid "Insert an inline op to every time an instruction executes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:364
msgid "query helper for number of insns in TB"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:368
#: ../../../../include/qemu/qemu-plugin.h:377
#: ../../../../include/qemu/qemu-plugin.h:386
msgid "``const struct qemu_plugin_tb *tb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:365
#: ../../../../include/qemu/qemu-plugin.h:374
#: ../../../../include/qemu/qemu-plugin.h:383
msgid "opaque handle to TB passed to callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:367
msgid "number of instructions in this block"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:373
msgid "query helper for vaddr of TB start"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:376
msgid "virtual address of block start"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:382
msgid "retrieve handle for instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:385
msgid "``size_t idx``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:384
msgid "instruction number, 0 indexed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:386
msgid ""
"The returned handle can be used in follow up helper queries as well as when "
"instrumenting an instruction. It is only valid for the lifetime of the "
"callback."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:390
msgid "opaque handle to instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:397
msgid "return ptr to instruction data"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:401
#: ../../../../include/qemu/qemu-plugin.h:414
#: ../../../../include/qemu/qemu-plugin.h:423
#: ../../../../include/qemu/qemu-plugin.h:432
#: ../../../../include/qemu/qemu-plugin.h:614
#: ../../../../include/qemu/qemu-plugin.h:624
msgid "``const struct qemu_plugin_insn *insn``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:398
#: ../../../../include/qemu/qemu-plugin.h:411
#: ../../../../include/qemu/qemu-plugin.h:420
#: ../../../../include/qemu/qemu-plugin.h:429
msgid "opaque instruction handle from qemu_plugin_tb_get_insn()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:400
msgid ""
"data is only valid for duration of callback. See qemu_plugin_insn_size() to "
"calculate size of stream."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:403
msgid ""
"pointer to a stream of bytes containing the value of this instructions "
"opcode."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:410
msgid "return size of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:413
msgid "size of instruction in bytes"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:419
msgid "return vaddr of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:422
msgid "virtual address of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:428
msgid "return hardware addr of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:431
msgid "hardware (physical) target address of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:437
#: ../../../../include/qemu/qemu-plugin.h:448
#: ../../../../include/qemu/qemu-plugin.h:456
#: ../../../../include/qemu/qemu-plugin.h:464
#: ../../../../include/qemu/qemu-plugin.h:472
msgid "opaque memory transaction handle"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:439
msgid ""
"This can be further queried using the qemu_plugin_mem_* query functions."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:447
msgid "get size of access"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:451
#: ../../../../include/qemu/qemu-plugin.h:459
#: ../../../../include/qemu/qemu-plugin.h:467
#: ../../../../include/qemu/qemu-plugin.h:475
#: ../../../../include/qemu/qemu-plugin.h:484
#: ../../../../include/qemu/qemu-plugin.h:535
msgid "``qemu_plugin_meminfo_t info``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:450
msgid "size of access in ^2 (0=byte, 1=16bit, 2=32bit etc...)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:455
msgid "was the access sign extended"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:458
#: ../../../../include/qemu/qemu-plugin.h:466
#: ../../../../include/qemu/qemu-plugin.h:474
msgid "true if it was, otherwise false"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:463
msgid "was the access big endian"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:471
msgid "was the access a store"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:480
msgid "return handle for memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:481
msgid "opaque memory info structure"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:483
#: ../../../../include/qemu/qemu-plugin.h:536
msgid "``uint64_t vaddr``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:482
msgid "the virtual address of the memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:484
msgid ""
"For system emulation returns a qemu_plugin_hwaddr handle to query details "
"about the actual physical address backing the virtual address. For linux-"
"user guests it just returns NULL."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:488
msgid ""
"This handle is *only* valid for the duration of the callback. Any "
"information about the handle should be recovered before the callback returns."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:503
msgid "query whether memory operation is IO"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:507
#: ../../../../include/qemu/qemu-plugin.h:517
msgid "``const struct qemu_plugin_hwaddr *haddr``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:504
#: ../../../../include/qemu/qemu-plugin.h:514
msgid "address handle from qemu_plugin_get_hwaddr()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:506
msgid ""
"Returns true if the handle's memory operation is to memory-mapped IO, or "
"false if it is to RAM"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:513
msgid "query physical address for memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:516
msgid "Returns the physical address associated with the memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:518
msgid ""
"Note that the returned physical address may not be unique if you are dealing "
"with multiple address spaces."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:532
msgid "**Typedef**: memory callback function type"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:537
msgid ""
"``void qemu_plugin_vcpu_mem_cb_t (unsigned int vcpu_index, "
"qemu_plugin_meminfo_t info, uint64_t vaddr, void *userdata)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:533
msgid "the executing vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:534
msgid "an opaque handle for further queries about the memory"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:535
msgid "the virtual address of the transaction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:536
msgid "any user data attached to the callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:544
msgid "register memory access callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:545
#: ../../../../include/qemu/qemu-plugin.h:572
msgid "handle for instruction to instrument"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:547
msgid "``qemu_plugin_vcpu_mem_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:546
msgid "callback of type qemu_plugin_vcpu_mem_cb_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:547
msgid "(currently unused) callback flags"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:549
#: ../../../../include/qemu/qemu-plugin.h:574
msgid "``enum qemu_plugin_mem_rw rw``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:548
msgid "monitor reads, writes or both"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:549
msgid "opaque pointer for userdata"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:551
msgid ""
"This registers a full callback for every memory access generated by an "
"instruction. If the instruction doesn't access memory no callback will be "
"made."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:555
msgid ""
"The callback reports the vCPU the access took place on, the virtual address "
"of the access and a handle for further queries. The user can attach some "
"userdata to the callback for additional purposes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:559
msgid ""
"Other execution threads will continue to execute during the callback so the "
"plugin is responsible for ensuring it doesn't get confused by making "
"appropriate use of locking if required."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:571
msgid "inline op for mem access"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:573
msgid "apply to reads, writes or both"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:574
msgid "the op, of type qemu_plugin_op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:576
msgid "immediate data for **op**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:578
msgid ""
"This registers a inline op every memory access generated by the instruction."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:610
msgid "return disassembly string for instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:611
#: ../../../../include/qemu/qemu-plugin.h:621
msgid "instruction reference"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:613
msgid "Returns an allocated string containing the disassembly"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:620
msgid "best effort symbol lookup"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:623
msgid ""
"Return a static string referring to the symbol. This is dependent on the "
"binary QEMU is running having provided a symbol table."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:630
msgid "iterate over the existing vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:634
msgid "The **cb** function is called once for each existing vCPU."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:647
msgid "register exit callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:650
msgid "``qemu_plugin_udata_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:649
msgid "callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:650
msgid "user data for callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:652
msgid ""
"The **cb** function is called once execution has finished. Plugins should be "
"able to free all their resources at this point much like after a reset/"
"uninstall callback is called."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:656
msgid ""
"In user-mode it is possible a few un-instrumented instructions from child "
"threads may run before the host kernel reaps the threads."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:667
msgid "output string via QEMU's logging system"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:671
msgid "``const char *string``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:668
msgid "a string"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:674
msgid ""
"parses a boolean argument in the form of \"<argname>=[on|yes|true|off|no|"
"false]\""
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:678
msgid "``const char *name``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:677
msgid "argument name, the part before the equals sign"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:679
msgid "``const char *val``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:678
msgid "argument value, what's after the equals sign"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:680
msgid "``bool *ret``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:679
msgid "output return value"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:681
msgid ""
"returns true if the combination **name**=**val** parses correctly to a "
"boolean argument, and false otherwise"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:688
msgid "path to binary file being executed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:692
#: ../../../../include/qemu/qemu-plugin.h:703
#: ../../../../include/qemu/qemu-plugin.h:712
#: ../../../../include/qemu/qemu-plugin.h:721
#: ../../../../include/qemu/qemu-plugin.h:746
msgid "``void``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:693
#: ../../../../include/qemu/qemu-plugin.h:704
#: ../../../../include/qemu/qemu-plugin.h:713
#: ../../../../include/qemu/qemu-plugin.h:722
#: ../../../../include/qemu/qemu-plugin.h:747
msgid "no arguments"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:690
msgid ""
"Return a string representing the path to the binary. For user-mode this is "
"the main executable. For system emulation we currently return NULL. The user "
"should g_free() the string once no longer needed."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:699
msgid "returns start of text segment"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:701
msgid ""
"Returns the nominal start address of the main text segment in user-mode. "
"Currently returns 0 for system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:708
msgid "returns end of text segment"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:710
msgid ""
"Returns the nominal end address of the main text segment in user-mode. "
"Currently returns 0 for system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:717
msgid "returns start address for module"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:719
msgid ""
"Returns the nominal entry address of the main text segment in user-mode. "
"Currently returns 0 for system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:729
msgid "register descriptions"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:742
msgid "return register list for current vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:744
msgid ""
"Returns a potentially empty GArray of qemu_plugin_reg_descriptor. Caller "
"frees the array (but not the const strings)."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:747
msgid ""
"Should be used from a qemu_plugin_register_vcpu_init_cb() callback after the "
"vCPU is initialised, i.e. in the vCPU context."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:754
msgid "read register for current vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:758
msgid "``struct qemu_plugin_register *handle``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:756
msgid "a **qemu_plugin_reg_handle** handle"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:758
msgid "``GByteArray *buf``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:757
msgid "A GByteArray for the data owned by the plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:759
msgid ""
"This function is only available in a context that register read access is "
"explicitly requested via the QEMU_PLUGIN_CB_R_REGS flag."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:762
msgid ""
"Returns the size of the read register. The content of **buf** is in target "
"byte order. On failure returns -1."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:770
msgid "alloc a new scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:774
msgid "``size_t element_size``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:772
msgid "size (in bytes) for one entry"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:774
msgid ""
"Returns a pointer to a new scoreboard. It must be freed using "
"qemu_plugin_scoreboard_free."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:781
msgid "free a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:785
#: ../../../../include/qemu/qemu-plugin.h:792
msgid "``struct qemu_plugin_scoreboard *score``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:782
msgid "scoreboard to free"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:788
msgid "get pointer to an entry of a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:789
msgid "scoreboard to query"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:790
#: ../../../../include/qemu/qemu-plugin.h:808
#: ../../../../include/qemu/qemu-plugin.h:818
#: ../../../../include/qemu/qemu-plugin.h:826
msgid "entry index"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:792
msgid ""
"Returns address of entry of a scoreboard matching a given vcpu_index. This "
"address can be modified later if scoreboard is resized."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:806
msgid "add a value to a qemu_plugin_u64 for a given vcpu"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:807
#: ../../../../include/qemu/qemu-plugin.h:817
#: ../../../../include/qemu/qemu-plugin.h:825
msgid "entry to query"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:810
msgid "``uint64_t added``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:809
msgid "value to add"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:816
msgid "get value of a qemu_plugin_u64 for a given vcpu"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:824
msgid "set value of a qemu_plugin_u64 for a given vcpu"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:828
msgid "``uint64_t val``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:827
msgid "new value"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:834
msgid "return sum of all vcpu entries in a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:835
msgid "entry to sum"
msgstr ""
