# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/qom.rst:5
msgid "The QEMU Object Model (QOM)"
msgstr ""

#: ../../../devel/qom.rst:9
msgid ""
"The QEMU Object Model provides a framework for registering user creatable "
"types and instantiating objects from those types.  QOM provides the "
"following features:"
msgstr ""

#: ../../../devel/qom.rst:13
msgid "System for dynamically registering types"
msgstr ""

#: ../../../devel/qom.rst:14
msgid "Support for single-inheritance of types"
msgstr ""

#: ../../../devel/qom.rst:15
msgid "Multiple inheritance of stateless interfaces"
msgstr ""

#: ../../../devel/qom.rst:16
msgid "Mapping internal members to publicly exposed properties"
msgstr ""

#: ../../../devel/qom.rst:18
msgid ""
"The root object class is TYPE_OBJECT which provides for the basic object "
"methods."
msgstr ""

#: ../../../devel/qom.rst:22
msgid "The QOM tree"
msgstr ""

#: ../../../devel/qom.rst:24
msgid ""
"The QOM tree is a composition tree which represents all of the objects that "
"make up a QEMU \"machine\". You can view this tree by running ``info qom-"
"tree`` in the :ref:`QEMU monitor`. It will contain both objects created by "
"the machine itself as well those created due to user configuration."
msgstr ""

#: ../../../devel/qom.rst:31
msgid "Creating a QOM class"
msgstr ""

#: ../../../devel/qom.rst:33
msgid "A simple minimal device implementation may look something like below:"
msgstr ""

#: ../../../devel/qom.rst:35
msgid "Creating a minimal type"
msgstr ""

#: ../../../devel/qom.rst:35
msgid ""
"#include \"qdev.h\"\n"
"\n"
"#define TYPE_MY_DEVICE \"my-device\"\n"
"\n"
"// No new virtual functions: we can reuse the typedef for the\n"
"// superclass.\n"
"typedef DeviceClass MyDeviceClass;\n"
"typedef struct MyDevice\n"
"{\n"
"    DeviceState parent_obj;\n"
"\n"
"    int reg0, reg1, reg2;\n"
"} MyDevice;\n"
"\n"
"static const TypeInfo my_device_info = {\n"
"    .name = TYPE_MY_DEVICE,\n"
"    .parent = TYPE_DEVICE,\n"
"    .instance_size = sizeof(MyDevice),\n"
"};\n"
"\n"
"static void my_device_register_types(void)\n"
"{\n"
"    type_register_static(&my_device_info);\n"
"}\n"
"\n"
"type_init(my_device_register_types)"
msgstr ""

#: ../../../devel/qom.rst:65
msgid ""
"In the above example, we create a simple type that is described by "
"#TypeInfo. #TypeInfo describes information about the type including what it "
"inherits from, the instance and class size, and constructor/destructor hooks."
msgstr ""

#: ../../../devel/qom.rst:69
msgid ""
"The TYPE_DEVICE class is the parent class for all modern devices implemented "
"in QEMU and adds some specific methods to handle QEMU device model. This "
"includes managing the lifetime of devices from creation through to when they "
"become visible to the guest and eventually unrealized."
msgstr ""

#: ../../../devel/qom.rst:75
msgid ""
"Alternatively several static types could be registered using helper macro "
"DEFINE_TYPES()"
msgstr ""

#: ../../../devel/qom.rst:78
msgid ""
"static const TypeInfo device_types_info[] = {\n"
"    {\n"
"        .name = TYPE_MY_DEVICE_A,\n"
"        .parent = TYPE_DEVICE,\n"
"        .instance_size = sizeof(MyDeviceA),\n"
"    },\n"
"    {\n"
"        .name = TYPE_MY_DEVICE_B,\n"
"        .parent = TYPE_DEVICE,\n"
"        .instance_size = sizeof(MyDeviceB),\n"
"    },\n"
"};\n"
"\n"
"DEFINE_TYPES(device_types_info)"
msgstr ""

#: ../../../devel/qom.rst:95
msgid ""
"Every type has an #ObjectClass associated with it.  #ObjectClass derivatives "
"are instantiated dynamically but there is only ever one instance for any "
"given type.  The #ObjectClass typically holds a table of function pointers "
"for the virtual methods implemented by this type."
msgstr ""

#: ../../../devel/qom.rst:100
msgid ""
"Using object_new(), a new #Object derivative will be instantiated.  You can "
"cast an #Object to a subclass (or base-class) type using "
"object_dynamic_cast().  You typically want to define macro wrappers around "
"OBJECT_CHECK() and OBJECT_CLASS_CHECK() to make it easier to convert to a "
"specific type:"
msgstr ""

#: ../../../devel/qom.rst:106
msgid "Typecasting macros"
msgstr ""

#: ../../../devel/qom.rst:106
msgid ""
"#define MY_DEVICE_GET_CLASS(obj) \\\n"
"   OBJECT_GET_CLASS(MyDeviceClass, obj, TYPE_MY_DEVICE)\n"
"#define MY_DEVICE_CLASS(klass) \\\n"
"   OBJECT_CLASS_CHECK(MyDeviceClass, klass, TYPE_MY_DEVICE)\n"
"#define MY_DEVICE(obj) \\\n"
"   OBJECT_CHECK(MyDevice, obj, TYPE_MY_DEVICE)"
msgstr ""

#: ../../../devel/qom.rst:116
msgid ""
"In case the ObjectClass implementation can be built as module a module_obj() "
"line must be added to make sure qemu loads the module when the object is "
"needed."
msgstr ""

#: ../../../devel/qom.rst:120
msgid "module_obj(TYPE_MY_DEVICE);"
msgstr ""

#: ../../../devel/qom.rst:125
msgid "Class Initialization"
msgstr ""

#: ../../../devel/qom.rst:127
msgid ""
"Before an object is initialized, the class for the object must be "
"initialized.  There is only one class object for all instance objects that "
"is created lazily."
msgstr ""

#: ../../../devel/qom.rst:131
msgid ""
"Classes are initialized by first initializing any parent classes (if "
"necessary).  After the parent class object has initialized, it will be "
"copied into the current class object and any additional storage in the class "
"object is zero filled."
msgstr ""

#: ../../../devel/qom.rst:136
msgid ""
"The effect of this is that classes automatically inherit any virtual "
"function pointers that the parent class has already initialized.  All other "
"fields will be zero filled."
msgstr ""

#: ../../../devel/qom.rst:140
msgid ""
"Once all of the parent classes have been initialized, #TypeInfo::class_init "
"is called to let the class being instantiated provide default initialize for "
"its virtual functions.  Here is how the above example might be modified to "
"introduce an overridden virtual function:"
msgstr ""

#: ../../../devel/qom.rst:145
msgid "Overriding a virtual function"
msgstr ""

#: ../../../devel/qom.rst:145
msgid ""
"#include \"qdev.h\"\n"
"\n"
"void my_device_class_init(ObjectClass *klass, void *class_data)\n"
"{\n"
"    DeviceClass *dc = DEVICE_CLASS(klass);\n"
"    dc->reset = my_device_reset;\n"
"}\n"
"\n"
"static const TypeInfo my_device_info = {\n"
"    .name = TYPE_MY_DEVICE,\n"
"    .parent = TYPE_DEVICE,\n"
"    .instance_size = sizeof(MyDevice),\n"
"    .class_init = my_device_class_init,\n"
"};"
msgstr ""

#: ../../../devel/qom.rst:163
msgid ""
"Introducing new virtual methods requires a class to define its own struct "
"and to add a .class_size member to the #TypeInfo.  Each method will also "
"have a wrapper function to call it easily:"
msgstr ""

#: ../../../devel/qom.rst:167
msgid "Defining an abstract class"
msgstr ""

#: ../../../devel/qom.rst:167
msgid ""
"#include \"qdev.h\"\n"
"\n"
"typedef struct MyDeviceClass\n"
"{\n"
"    DeviceClass parent_class;\n"
"\n"
"    void (*frobnicate) (MyDevice *obj);\n"
"} MyDeviceClass;\n"
"\n"
"static const TypeInfo my_device_info = {\n"
"    .name = TYPE_MY_DEVICE,\n"
"    .parent = TYPE_DEVICE,\n"
"    .instance_size = sizeof(MyDevice),\n"
"    .abstract = true, // or set a default in my_device_class_init\n"
"    .class_size = sizeof(MyDeviceClass),\n"
"};\n"
"\n"
"void my_device_frobnicate(MyDevice *obj)\n"
"{\n"
"    MyDeviceClass *klass = MY_DEVICE_GET_CLASS(obj);\n"
"\n"
"    klass->frobnicate(obj);\n"
"}"
msgstr ""

#: ../../../devel/qom.rst:195
msgid "Interfaces"
msgstr ""

#: ../../../devel/qom.rst:197
msgid ""
"Interfaces allow a limited form of multiple inheritance.  Instances are "
"similar to normal types except for the fact that are only defined by their "
"classes and never carry any state.  As a consequence, a pointer to an "
"interface instance should always be of incomplete type in order to be sure "
"it cannot be dereferenced.  That is, you should define the 'typedef struct "
"SomethingIf SomethingIf' so that you can pass around ``SomethingIf *si`` "
"arguments, but not define a ``struct SomethingIf { ... }``. The only things "
"you can validly do with a ``SomethingIf *`` are to pass it as an argument to "
"a method on its corresponding SomethingIfClass, or to dynamically cast it to "
"an object that implements the interface."
msgstr ""

#: ../../../devel/qom.rst:209
msgid "Methods"
msgstr ""

#: ../../../devel/qom.rst:211
msgid ""
"A *method* is a function within the namespace scope of a class. It usually "
"operates on the object instance by passing it as a strongly-typed first "
"argument. If it does not operate on an object instance, it is dubbed *class "
"method*."
msgstr ""

#: ../../../devel/qom.rst:217
msgid ""
"Methods cannot be overloaded. That is, the #ObjectClass and method name "
"uniquely identity the function to be called; the signature does not vary "
"except for trailing varargs."
msgstr ""

#: ../../../devel/qom.rst:221
msgid ""
"Methods are always *virtual*. Overriding a method in #TypeInfo.class_init of "
"a subclass leads to any user of the class obtained via OBJECT_GET_CLASS() "
"accessing the overridden function. The original function is not "
"automatically invoked. It is the responsibility of the overriding class to "
"determine whether and when to invoke the method being overridden."
msgstr ""

#: ../../../devel/qom.rst:228
msgid ""
"To invoke the method being overridden, the preferred solution is to store "
"the original value in the overriding class before overriding the method. "
"This corresponds to ``{super,base}.method(...)`` in Java and C# "
"respectively; this frees the overriding class from hardcoding its parent "
"class, which someone might choose to change at some point."
msgstr ""

#: ../../../devel/qom.rst:234
msgid "Overriding a virtual method"
msgstr ""

#: ../../../devel/qom.rst:234
msgid ""
"typedef struct MyState MyState;\n"
"\n"
"typedef void (*MyDoSomething)(MyState *obj);\n"
"\n"
"typedef struct MyClass {\n"
"    ObjectClass parent_class;\n"
"\n"
"    MyDoSomething do_something;\n"
"} MyClass;\n"
"\n"
"static void my_do_something(MyState *obj)\n"
"{\n"
"    // do something\n"
"}\n"
"\n"
"static void my_class_init(ObjectClass *oc, void *data)\n"
"{\n"
"    MyClass *mc = MY_CLASS(oc);\n"
"\n"
"    mc->do_something = my_do_something;\n"
"}\n"
"\n"
"static const TypeInfo my_type_info = {\n"
"    .name = TYPE_MY,\n"
"    .parent = TYPE_OBJECT,\n"
"    .instance_size = sizeof(MyState),\n"
"    .class_size = sizeof(MyClass),\n"
"    .class_init = my_class_init,\n"
"};\n"
"\n"
"typedef struct DerivedClass {\n"
"    MyClass parent_class;\n"
"\n"
"    MyDoSomething parent_do_something;\n"
"} DerivedClass;\n"
"\n"
"static void derived_do_something(MyState *obj)\n"
"{\n"
"    DerivedClass *dc = DERIVED_GET_CLASS(obj);\n"
"\n"
"    // do something here\n"
"    dc->parent_do_something(obj);\n"
"    // do something else here\n"
"}\n"
"\n"
"static void derived_class_init(ObjectClass *oc, void *data)\n"
"{\n"
"    MyClass *mc = MY_CLASS(oc);\n"
"    DerivedClass *dc = DERIVED_CLASS(oc);\n"
"\n"
"    dc->parent_do_something = mc->do_something;\n"
"    mc->do_something = derived_do_something;\n"
"}\n"
"\n"
"static const TypeInfo derived_type_info = {\n"
"    .name = TYPE_DERIVED,\n"
"    .parent = TYPE_MY,\n"
"    .class_size = sizeof(DerivedClass),\n"
"    .class_init = derived_class_init,\n"
"};"
msgstr ""

#: ../../../devel/qom.rst:298
msgid ""
"Alternatively, object_class_by_name() can be used to obtain the class and "
"its non-overridden methods for a specific type. This would correspond to "
"``MyClass::method(...)`` in C++."
msgstr ""

#: ../../../devel/qom.rst:302
msgid ""
"One example of such methods is ``DeviceClass.reset``. More examples can be "
"found at :ref:`device-life-cycle`."
msgstr ""

#: ../../../devel/qom.rst:306
msgid "Standard type declaration and definition macros"
msgstr ""

#: ../../../devel/qom.rst:308
msgid ""
"A lot of the code outlined above follows a standard pattern and naming "
"convention. To reduce the amount of boilerplate code that needs to be "
"written for a new type there are two sets of macros to generate the common "
"parts in a standard format."
msgstr ""

#: ../../../devel/qom.rst:313
msgid ""
"A type is declared using the OBJECT_DECLARE macro family. In types which do "
"not require any virtual functions in the class, the "
"OBJECT_DECLARE_SIMPLE_TYPE macro is suitable, and is commonly placed in the "
"header file:"
msgstr ""

#: ../../../devel/qom.rst:318
msgid "Declaring a simple type"
msgstr ""

#: ../../../devel/qom.rst:318
msgid "OBJECT_DECLARE_SIMPLE_TYPE(MyDevice, MY_DEVICE)"
msgstr ""

#: ../../../devel/qom.rst:323 ../../../devel/qom.rst:360
msgid "This is equivalent to the following:"
msgstr ""

#: ../../../devel/qom.rst:325
msgid "Expansion from declaring a simple type"
msgstr ""

#: ../../../devel/qom.rst:325
msgid ""
"typedef struct MyDevice MyDevice;\n"
"typedef struct MyDeviceClass MyDeviceClass;\n"
"\n"
"G_DEFINE_AUTOPTR_CLEANUP_FUNC(MyDeviceClass, object_unref)\n"
"\n"
"#define MY_DEVICE_GET_CLASS(void *obj) \\\n"
"        OBJECT_GET_CLASS(MyDeviceClass, obj, TYPE_MY_DEVICE)\n"
"#define MY_DEVICE_CLASS(void *klass) \\\n"
"        OBJECT_CLASS_CHECK(MyDeviceClass, klass, TYPE_MY_DEVICE)\n"
"#define MY_DEVICE(void *obj)\n"
"        OBJECT_CHECK(MyDevice, obj, TYPE_MY_DEVICE)\n"
"\n"
"struct MyDeviceClass {\n"
"    DeviceClass parent_class;\n"
"};"
msgstr ""

#: ../../../devel/qom.rst:344
msgid ""
"The 'struct MyDevice' needs to be declared separately. If the type requires "
"virtual functions to be declared in the class struct, then the alternative "
"OBJECT_DECLARE_TYPE() macro can be used. This does the same as "
"OBJECT_DECLARE_SIMPLE_TYPE(), but without the 'struct MyDeviceClass' "
"definition."
msgstr ""

#: ../../../devel/qom.rst:350
msgid ""
"To implement the type, the OBJECT_DEFINE macro family is available. For the "
"simplest case of a leaf class which doesn't need any of its own virtual "
"functions (i.e. which was declared with OBJECT_DECLARE_SIMPLE_TYPE) the "
"OBJECT_DEFINE_SIMPLE_TYPE macro is suitable:"
msgstr ""

#: ../../../devel/qom.rst:355
msgid "Defining a simple type"
msgstr ""

#: ../../../devel/qom.rst:355
msgid "OBJECT_DEFINE_SIMPLE_TYPE(MyDevice, my_device, MY_DEVICE, DEVICE)"
msgstr ""

#: ../../../devel/qom.rst:362
msgid "Expansion from defining a simple type"
msgstr ""

#: ../../../devel/qom.rst:362
msgid ""
"static void my_device_finalize(Object *obj);\n"
"static void my_device_class_init(ObjectClass *oc, void *data);\n"
"static void my_device_init(Object *obj);\n"
"\n"
"static const TypeInfo my_device_info = {\n"
"    .parent = TYPE_DEVICE,\n"
"    .name = TYPE_MY_DEVICE,\n"
"    .instance_size = sizeof(MyDevice),\n"
"    .instance_init = my_device_init,\n"
"    .instance_finalize = my_device_finalize,\n"
"    .class_init = my_device_class_init,\n"
"};\n"
"\n"
"static void\n"
"my_device_register_types(void)\n"
"{\n"
"    type_register_static(&my_device_info);\n"
"}\n"
"type_init(my_device_register_types);"
msgstr ""

#: ../../../devel/qom.rst:385
msgid ""
"This is sufficient to get the type registered with the type system, and the "
"three standard methods now need to be implemented along with any other logic "
"required for the type."
msgstr ""

#: ../../../devel/qom.rst:389
msgid ""
"If the class needs its own virtual methods, or has some other per-class "
"state it needs to store in its own class struct, then you can use the "
"OBJECT_DEFINE_TYPE macro. This does the same thing as "
"OBJECT_DEFINE_SIMPLE_TYPE, but it also sets the class_size of the type to "
"the size of the class struct."
msgstr ""

#: ../../../devel/qom.rst:395
msgid "Defining a type which needs a class struct"
msgstr ""

#: ../../../devel/qom.rst:395
msgid "OBJECT_DEFINE_TYPE(MyDevice, my_device, MY_DEVICE, DEVICE)"
msgstr ""

#: ../../../devel/qom.rst:400
msgid ""
"If the type needs to implement one or more interfaces, then the "
"OBJECT_DEFINE_SIMPLE_TYPE_WITH_INTERFACES() and "
"OBJECT_DEFINE_TYPE_WITH_INTERFACES() macros can be used instead. These "
"accept an array of interface type names. The difference between them is that "
"the former is for simple leaf classes that don't need a class struct, and "
"the latter is for when you will be defining a class struct."
msgstr ""

#: ../../../devel/qom.rst:408
msgid "Defining a simple type implementing interfaces"
msgstr ""

#: ../../../devel/qom.rst:408
msgid ""
"OBJECT_DEFINE_SIMPLE_TYPE_WITH_INTERFACES(MyDevice, my_device,\n"
"                                          MY_DEVICE, DEVICE,\n"
"                                          { TYPE_USER_CREATABLE },\n"
"                                          { NULL })"
msgstr ""

#: ../../../devel/qom.rst:416
msgid "Defining a type implementing interfaces"
msgstr ""

#: ../../../devel/qom.rst:416
msgid ""
"OBJECT_DEFINE_TYPE_WITH_INTERFACES(MyDevice, my_device,\n"
"                                   MY_DEVICE, DEVICE,\n"
"                                   { TYPE_USER_CREATABLE },\n"
"                                   { NULL })"
msgstr ""

#: ../../../devel/qom.rst:424
msgid ""
"If the type is not intended to be instantiated, then the "
"OBJECT_DEFINE_ABSTRACT_TYPE() macro can be used instead:"
msgstr ""

#: ../../../devel/qom.rst:427
msgid "Defining a simple abstract type"
msgstr ""

#: ../../../devel/qom.rst:427
msgid ""
"OBJECT_DEFINE_ABSTRACT_TYPE(MyDevice, my_device,\n"
"                            MY_DEVICE, DEVICE)"
msgstr ""

#: ../../../devel/qom.rst:436
msgid "Device Life-cycle"
msgstr ""

#: ../../../devel/qom.rst:438
msgid ""
"As class initialisation cannot fail devices have an two additional methods "
"to handle the creation of dynamic devices. The ``realize`` function is "
"called with ``Error **`` pointer which should be set if the device cannot "
"complete its setup. Otherwise on successful completion of the ``realize`` "
"method the device object is added to the QOM tree and made visible to the "
"guest."
msgstr ""

#: ../../../devel/qom.rst:445
msgid ""
"The reverse function is ``unrealize`` and should be were clean-up code lives "
"to tidy up after the system is done with the device."
msgstr ""

#: ../../../devel/qom.rst:448
msgid ""
"All devices can be instantiated by C code, however only some can created "
"dynamically via the command line or monitor."
msgstr ""

#: ../../../devel/qom.rst:451
msgid ""
"Likewise only some can be unplugged after creation and need an explicit "
"``unrealize`` implementation. This is determined by the ``user_creatable`` "
"variable in the root ``DeviceClass`` structure. Devices can only be "
"unplugged if their ``parent_bus`` has a registered ``HotplugHandler``."
msgstr ""

#: ../../../devel/qom.rst:458
msgid "API Reference"
msgstr ""

#: ../../../devel/qom.rst:460
msgid ""
"See the :ref:`QOM API<qom-api>` and :ref:`QDEV API<qdev-api>` documents for "
"the complete API description."
msgstr ""
