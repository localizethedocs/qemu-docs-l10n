# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../specs/ivshmem-spec.rst:3
msgid "Device Specification for Inter-VM shared memory device"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:5
msgid ""
"The Inter-VM shared memory device (ivshmem) is designed to share a memory "
"region between multiple QEMU processes running different guests and the "
"host.  In order for all guests to be able to pick up the shared memory area, "
"it is modeled by QEMU as a PCI device exposing said memory to the guest as a "
"PCI BAR."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:11
msgid ""
"The device can use a shared memory object on the host directly, or it can "
"obtain one from an ivshmem server."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:14
msgid ""
"In the latter case, the device can additionally interrupt its peers, and get "
"interrupted by its peers."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:17
msgid ""
"For information on configuring the ivshmem device on the QEMU command line, "
"see :doc:`../system/devices/ivshmem`."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:21
msgid "The ivshmem PCI device's guest interface"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:23
msgid ""
"The device has vendor ID 1af4, device ID 1110, revision 1.  Before QEMU "
"2.6.0, it had revision 0."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:27
msgid "PCI BARs"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:29
msgid "The ivshmem PCI device has two or three BARs:"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:31
msgid "BAR0 holds device registers (256 Byte MMIO)"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:32
msgid "BAR1 holds MSI-X table and PBA (only ivshmem-doorbell)"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:33
msgid "BAR2 maps the shared memory object"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:35
msgid "There are two ways to use this device:"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:37
msgid ""
"If you only need the shared memory part, BAR2 suffices.  This way, you have "
"access to the shared memory in the guest and can use it as you see fit."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:41
msgid ""
"If you additionally need the capability for peers to interrupt each other, "
"you need BAR0 and BAR1.  You will most likely want to write a kernel driver "
"to handle interrupts.  Requires the device to be configured for interrupts, "
"obviously."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:46
msgid ""
"Before QEMU 2.6.0, BAR2 can initially be invalid if the device is configured "
"for interrupts.  It becomes safely accessible only after the ivshmem server "
"provided the shared memory.  These devices have PCI revision 0 rather than "
"1.  Guest software should wait for the IVPosition register (described below) "
"to become non-negative before accessing BAR2."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:53
msgid ""
"Revision 0 of the device is not capable to tell guest software whether it is "
"configured for interrupts."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:57
msgid "PCI device registers"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:59
msgid "BAR 0 contains the following registers:"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:63
msgid ""
"Offset  Size  Access      On reset  Function\n"
"    0     4   read/write        0   Interrupt Mask\n"
"                                    bit 0: peer interrupt (rev 0)\n"
"                                           reserved       (rev 1)\n"
"                                    bit 1..31: reserved\n"
"    4     4   read/write        0   Interrupt Status\n"
"                                    bit 0: peer interrupt (rev 0)\n"
"                                           reserved       (rev 1)\n"
"                                    bit 1..31: reserved\n"
"    8     4   read-only   0 or ID   IVPosition\n"
"   12     4   write-only      N/A   Doorbell\n"
"                                    bit 0..15: vector\n"
"                                    bit 16..31: peer ID\n"
"   16   240   none            N/A   reserved"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:78
msgid ""
"Software should only access the registers as specified in column "
"\"Access\".  Reserved bits should be ignored on read, and preserved on write."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:82
msgid ""
"In revision 0 of the device, Interrupt Status and Mask Register together "
"control the legacy INTx interrupt when the device has no MSI-X capability: "
"INTx is asserted when the bit-wise AND of Status and Mask is non-zero and "
"the device has no MSI-X capability.  Interrupt Status Register bit 0 becomes "
"1 when an interrupt request from a peer is received.  Reading the register "
"clears it."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:89
msgid ""
"IVPosition Register: if the device is not configured for interrupts, this is "
"zero.  Else, it is the device's ID (between 0 and 65535)."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:92
msgid ""
"Before QEMU 2.6.0, the register may read -1 for a short while after reset.  "
"These devices have PCI revision 0 rather than 1."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:95
msgid ""
"There is no good way for software to find out whether the device is "
"configured for interrupts.  A positive IVPosition means interrupts, but zero "
"could be either."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:99
msgid ""
"Doorbell Register: writing this register requests to interrupt a peer. The "
"written value's high 16 bits are the ID of the peer to interrupt, and its "
"low 16 bits select an interrupt vector."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:103
msgid "If the device is not configured for interrupts, the write is ignored."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:105
msgid ""
"If the interrupt hasn't completed setup, the write is ignored.  The device "
"is not capable to tell guest software whether setup is complete.  Interrupts "
"can regress to this state on migration."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:109
msgid ""
"If the peer with the requested ID isn't connected, or it has fewer interrupt "
"vectors connected, the write is ignored.  The device is not capable to tell "
"guest software what peers are connected, or how many interrupt vectors are "
"connected."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:114
msgid ""
"The peer's interrupt for this vector then becomes pending.  There is no way "
"for software to clear the pending bit, and a polling mode of operation is "
"therefore impossible."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:118
msgid ""
"If the peer is a revision 0 device without MSI-X capability, its Interrupt "
"Status register is set to 1.  This asserts INTx unless masked by the "
"Interrupt Mask register.  The device is not capable to communicate the "
"interrupt vector to guest software then."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:123
msgid ""
"With multiple MSI-X vectors, different vectors can be used to indicate "
"different events have occurred.  The semantics of interrupt vectors are left "
"to the application."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:128
msgid "Interrupt infrastructure"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:130
msgid ""
"When configured for interrupts, the peers share eventfd objects in addition "
"to shared memory.  The shared resources are managed by an ivshmem server."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:135
msgid "The ivshmem server"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:137
msgid "The server listens on a UNIX domain socket."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:139
msgid "For each new client that connects to the server, the server"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:141
msgid "picks an ID,"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:142
msgid "creates eventfd file descriptors for the interrupt vectors,"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:143
msgid ""
"sends the ID and the file descriptor for the shared memory to the new client,"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:145
msgid ""
"sends connect notifications for the new client to the other clients (these "
"contain file descriptors for sending interrupts),"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:147
msgid ""
"sends connect notifications for the other clients to the new client, and"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:149
msgid ""
"sends interrupt setup messages to the new client (these contain file "
"descriptors for receiving interrupts)."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:152
msgid "The first client to connect to the server receives ID zero."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:154
msgid ""
"When a client disconnects from the server, the server sends disconnect "
"notifications to the other clients."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:157
msgid "The next section describes the protocol in detail."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:159
msgid ""
"If the server terminates without sending disconnect notifications for its "
"connected clients, the clients can elect to continue.  They can communicate "
"with each other normally, but won't receive disconnect notification on "
"disconnect, and no new clients can connect.  There is no way for the clients "
"to connect to a restarted server.  The device is not capable to tell guest "
"software whether the server is still up."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:166
msgid ""
"Example server code is in contrib/ivshmem-server/.  Not to be used in "
"production.  It assumes all clients use the same number of interrupt vectors."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:170
msgid ""
"A standalone client is in contrib/ivshmem-client/.  It can be useful for "
"debugging."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:174
msgid "The ivshmem Client-Server Protocol"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:176
msgid ""
"An ivshmem device configured for interrupts connects to an ivshmem server.  "
"This section details the protocol between the two."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:179
msgid ""
"The connection is one-way: the server sends messages to the client. Each "
"message consists of a single 8 byte little-endian signed number, and may be "
"accompanied by a file descriptor via SCM_RIGHTS.  Both client and server "
"close the connection on error."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:184
msgid ""
"Note: QEMU currently doesn't close the connection right on error, but only "
"when the character device is destroyed."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:187
msgid "On connect, the server sends the following messages in order:"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:189
msgid ""
"The protocol version number, currently zero.  The client should close the "
"connection on receipt of versions it can't handle."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:192
msgid ""
"The client's ID.  This is unique among all clients of this server. IDs must "
"be between 0 and 65535, because the Doorbell register provides only 16 bits "
"for them."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:196
msgid ""
"The number -1, accompanied by the file descriptor for the shared memory."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:199
msgid ""
"Connect notifications for existing other clients, if any.  This is a peer ID "
"(number between 0 and 65535 other than the client's ID), repeated N times.  "
"Each repetition is accompanied by one file descriptor.  These are for "
"interrupting the peer with that ID using vector 0,..,N-1, in order.  If the "
"client is configured for fewer vectors, it closes the extra file "
"descriptors.  If it is configured for more, the extra vectors remain "
"unconnected."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:207
msgid ""
"Interrupt setup.  This is the client's own ID, repeated N times. Each "
"repetition is accompanied by one file descriptor.  These are for receiving "
"interrupts from peers using vector 0,..,N-1, in order.  If the client is "
"configured for fewer vectors, it closes the extra file descriptors.  If it "
"is configured for more, the extra vectors remain unconnected."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:214
msgid "From then on, the server sends these kinds of messages:"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:216
msgid "Connection / disconnection notification.  This is a peer ID."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:218
msgid ""
"If the number comes with a file descriptor, it's a connection notification, "
"exactly like in step 4."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:221
msgid "Else, it's a disconnection notification for the peer with that ID."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:223
msgid "Known bugs:"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:225
msgid ""
"The protocol changed incompatibly in QEMU 2.5.  Before, messages were native "
"endian long, and there was no version number."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:228
msgid "The protocol is poorly designed."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:231
msgid "The ivshmem Client-Client Protocol"
msgstr ""

#: ../../../specs/ivshmem-spec.rst:233
msgid ""
"An ivshmem device configured for interrupts receives eventfd file "
"descriptors for interrupting peers and getting interrupted by peers from the "
"server, as explained in the previous section."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:237
msgid ""
"To interrupt a peer, the device writes the 8-byte integer 1 in native byte "
"order to the respective file descriptor."
msgstr ""

#: ../../../specs/ivshmem-spec.rst:240
msgid ""
"To receive an interrupt, the device reads and discards as many 8-byte "
"integers as it can."
msgstr ""
