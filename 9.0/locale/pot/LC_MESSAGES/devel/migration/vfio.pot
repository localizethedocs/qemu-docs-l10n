# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/migration/vfio.rst:3
msgid "VFIO device migration"
msgstr ""

#: ../../../devel/migration/vfio.rst:5
msgid ""
"Migration of virtual machine involves saving the state for each device that "
"the guest is running on source host and restoring this saved state on the "
"destination host. This document details how saving and restoring of VFIO "
"devices is done in QEMU."
msgstr ""

#: ../../../devel/migration/vfio.rst:10
msgid ""
"Migration of VFIO devices consists of two phases: the optional pre-copy "
"phase, and the stop-and-copy phase. The pre-copy phase is iterative and "
"allows to accommodate VFIO devices that have a large amount of data that "
"needs to be transferred. The iterative pre-copy phase of migration allows "
"for the guest to continue whilst the VFIO device state is transferred to the "
"destination, this helps to reduce the total downtime of the VM. VFIO devices "
"opt-in to pre-copy support by reporting the VFIO_MIGRATION_PRE_COPY flag in "
"the VFIO_DEVICE_FEATURE_MIGRATION ioctl."
msgstr ""

#: ../../../devel/migration/vfio.rst:19
msgid ""
"When pre-copy is supported, it's possible to further reduce downtime by "
"enabling \"switchover-ack\" migration capability. VFIO migration uAPI "
"defines \"initial bytes\" as part of its pre-copy data stream and recommends "
"that the initial bytes are sent and loaded in the destination before "
"stopping the source VM. Enabling this migration capability will guarantee "
"that and thus, can potentially reduce downtime even further."
msgstr ""

#: ../../../devel/migration/vfio.rst:26
msgid ""
"To support migration of multiple devices that might do P2P transactions "
"between themselves, VFIO migration uAPI defines an intermediate P2P "
"quiescent state. While in the P2P quiescent state, P2P DMA transactions "
"cannot be initiated by the device, but the device can respond to incoming "
"ones. Additionally, all outstanding P2P transactions are guaranteed to have "
"been completed by the time the device enters this state."
msgstr ""

#: ../../../devel/migration/vfio.rst:33
msgid ""
"All the devices that support P2P migration are first transitioned to the P2P "
"quiescent state and only then are they stopped or started. This makes "
"migration safe P2P-wise, since starting and stopping the devices is not done "
"atomically for all the devices together."
msgstr ""

#: ../../../devel/migration/vfio.rst:38
msgid ""
"Thus, multiple VFIO devices migration is allowed only if all the devices "
"support P2P migration. Single VFIO device migration is allowed regardless of "
"P2P migration support."
msgstr ""

#: ../../../devel/migration/vfio.rst:42
msgid ""
"A detailed description of the UAPI for VFIO device migration can be found in "
"the comment for the ``vfio_device_mig_state`` structure in the header file "
"linux-headers/linux/vfio.h."
msgstr ""

#: ../../../devel/migration/vfio.rst:46
msgid "VFIO implements the device hooks for the iterative approach as follows:"
msgstr ""

#: ../../../devel/migration/vfio.rst:48
msgid "A ``save_setup`` function that sets up migration on the source."
msgstr ""

#: ../../../devel/migration/vfio.rst:50
msgid ""
"A ``load_setup`` function that sets the VFIO device on the destination in "
"_RESUMING state."
msgstr ""

#: ../../../devel/migration/vfio.rst:53
msgid ""
"A ``state_pending_estimate`` function that reports an estimate of the "
"remaining pre-copy data that the vendor driver has yet to save for the VFIO "
"device."
msgstr ""

#: ../../../devel/migration/vfio.rst:57
msgid ""
"A ``state_pending_exact`` function that reads pending_bytes from the vendor "
"driver, which indicates the amount of data that the vendor driver has yet to "
"save for the VFIO device."
msgstr ""

#: ../../../devel/migration/vfio.rst:61
msgid ""
"An ``is_active_iterate`` function that indicates ``save_live_iterate`` is "
"active only when the VFIO device is in pre-copy states."
msgstr ""

#: ../../../devel/migration/vfio.rst:64
msgid ""
"A ``save_live_iterate`` function that reads the VFIO device's data from the "
"vendor driver during iterative pre-copy phase."
msgstr ""

#: ../../../devel/migration/vfio.rst:67
msgid ""
"A ``switchover_ack_needed`` function that checks if the VFIO device uses "
"\"switchover-ack\" migration capability when this capability is enabled."
msgstr ""

#: ../../../devel/migration/vfio.rst:70
msgid ""
"A ``save_state`` function to save the device config space if it is present."
msgstr ""

#: ../../../devel/migration/vfio.rst:72
msgid ""
"A ``save_live_complete_precopy`` function that sets the VFIO device in "
"_STOP_COPY state and iteratively copies the data for the VFIO device until "
"the vendor driver indicates that no data remains."
msgstr ""

#: ../../../devel/migration/vfio.rst:76
msgid ""
"A ``load_state`` function that loads the config section and the data "
"sections that are generated by the save functions above."
msgstr ""

#: ../../../devel/migration/vfio.rst:79
msgid ""
"``cleanup`` functions for both save and load that perform any migration "
"related cleanup."
msgstr ""

#: ../../../devel/migration/vfio.rst:83
msgid ""
"The VFIO migration code uses a VM state change handler to change the VFIO "
"device state when the VM state changes from running to not-running, and vice "
"versa."
msgstr ""

#: ../../../devel/migration/vfio.rst:87
msgid ""
"Similarly, a migration state change handler is used to trigger a transition "
"of the VFIO device state when certain changes of the migration state occur. "
"For example, the VFIO device state is transitioned back to _RUNNING in case "
"a migration failed or was canceled."
msgstr ""

#: ../../../devel/migration/vfio.rst:93
msgid "System memory dirty pages tracking"
msgstr ""

#: ../../../devel/migration/vfio.rst:95
msgid ""
"A ``log_global_start`` and ``log_global_stop`` memory listener callback "
"informs the VFIO dirty tracking module to start and stop dirty page "
"tracking. A ``log_sync`` memory listener callback queries the dirty page "
"bitmap from the dirty tracking module and marks system memory pages which "
"were DMA-ed by the VFIO device as dirty. The dirty page bitmap is queried "
"per container."
msgstr ""

#: ../../../devel/migration/vfio.rst:101
msgid ""
"Currently there are two ways dirty page tracking can be done: (1) Device "
"dirty tracking: In this method the device is responsible to log and report "
"its DMAs. This method can be used only if the device is capable of tracking "
"its DMAs. Discovering device capability, starting and stopping dirty "
"tracking, and syncing the dirty bitmaps from the device are done using the "
"DMA logging uAPI. More info about the uAPI can be found in the comments of "
"the ``vfio_device_feature_dma_logging_control`` and "
"``vfio_device_feature_dma_logging_report`` structures in the header file "
"linux-headers/linux/vfio.h."
msgstr ""

#: ../../../devel/migration/vfio.rst:112
msgid ""
"(2) VFIO IOMMU module: In this method dirty tracking is done by IOMMU. "
"However, there is currently no IOMMU support for dirty page tracking. For "
"this reason, all pages are perpetually marked dirty, unless the device "
"driver pins pages through external APIs in which case only those pinned "
"pages are perpetually marked dirty."
msgstr ""

#: ../../../devel/migration/vfio.rst:118
msgid ""
"If the above two methods are not supported, all pages are perpetually marked "
"dirty by QEMU."
msgstr ""

#: ../../../devel/migration/vfio.rst:121
msgid ""
"By default, dirty pages are tracked during pre-copy as well as stop-and-copy "
"phase. So, a page marked as dirty will be copied to the destination in both "
"phases. Copying dirty pages in pre-copy phase helps QEMU to predict if it "
"can achieve its downtime tolerances. If QEMU during pre-copy phase keeps "
"finding dirty pages continuously, then it understands that even in stop-and-"
"copy phase, it is likely to find dirty pages and can predict the downtime "
"accordingly."
msgstr ""

#: ../../../devel/migration/vfio.rst:128
msgid ""
"QEMU also provides a per device opt-out option ``pre-copy-dirty-page-"
"tracking`` which disables querying the dirty bitmap during pre-copy phase. "
"If it is set to off, all dirty pages will be copied to the destination in "
"stop-and-copy phase only."
msgstr ""

#: ../../../devel/migration/vfio.rst:134
msgid "System memory dirty pages tracking when vIOMMU is enabled"
msgstr ""

#: ../../../devel/migration/vfio.rst:136
msgid ""
"With vIOMMU, an IO virtual address range can get unmapped while in pre-copy "
"phase of migration. In that case, the unmap ioctl returns any dirty pages in "
"that range and QEMU reports corresponding guest physical pages dirty. During "
"stop-and-copy phase, an IOMMU notifier is used to get a callback for mapped "
"pages and then dirty pages bitmap is fetched from VFIO IOMMU modules for "
"those mapped ranges. If device dirty tracking is enabled with vIOMMU, live "
"migration will be blocked."
msgstr ""

#: ../../../devel/migration/vfio.rst:145
msgid "Flow of state changes during Live migration"
msgstr ""

#: ../../../devel/migration/vfio.rst:147
msgid ""
"Below is the state change flow during live migration for a VFIO device that "
"supports both precopy and P2P migration. The flow for devices that don't "
"support it is similar, except that the relevant states for precopy and P2P "
"are skipped. The values in the parentheses represent the VM state, the "
"migration state, and the VFIO device state, respectively."
msgstr ""

#: ../../../devel/migration/vfio.rst:155
msgid "Live migration save path"
msgstr ""

#: ../../../devel/migration/vfio.rst:159
msgid ""
"                         QEMU normal running state\n"
"                         (RUNNING, _NONE, _RUNNING)\n"
"                                    |\n"
"                   migrate_init spawns migration_thread\n"
"          Migration thread then calls each device's .save_setup()\n"
"                        (RUNNING, _SETUP, _PRE_COPY)\n"
"                                    |\n"
"                       (RUNNING, _ACTIVE, _PRE_COPY)\n"
"If device is active, get pending_bytes by .state_pending_{estimate,exact}()\n"
"     If total pending_bytes >= threshold_size, call .save_live_iterate()\n"
"              Data of VFIO device for pre-copy phase is copied\n"
"    Iterate till total pending bytes converge and are less than threshold\n"
"                                    |\n"
"     On migration completion, the vCPUs and the VFIO device are stopped\n"
"            The VFIO device is first put in P2P quiescent state\n"
"                  (FINISH_MIGRATE, _ACTIVE, _PRE_COPY_P2P)\n"
"                                    |\n"
"              Then the VFIO device is put in _STOP_COPY state\n"
"                   (FINISH_MIGRATE, _ACTIVE, _STOP_COPY)\n"
"       .save_live_complete_precopy() is called for each active device\n"
"    For the VFIO device, iterate in .save_live_complete_precopy() until\n"
"                             pending data is 0\n"
"                                    |\n"
"                   (POSTMIGRATE, _COMPLETED, _STOP_COPY)\n"
"          Migraton thread schedules cleanup bottom half and exits\n"
"                                    |\n"
"                         .save_cleanup() is called\n"
"                      (POSTMIGRATE, _COMPLETED, _STOP)"
msgstr ""

#: ../../../devel/migration/vfio.rst:189
msgid "Live migration resume path"
msgstr ""

#: ../../../devel/migration/vfio.rst:193
msgid ""
"           Incoming migration calls .load_setup() for each device\n"
"                        (RESTORE_VM, _ACTIVE, _STOP)\n"
"                                    |\n"
"   For each device, .load_state() is called for that device section data\n"
"                      (RESTORE_VM, _ACTIVE, _RESUMING)\n"
"                                    |\n"
"At the end, .load_cleanup() is called for each device and vCPUs are started\n"
"            The VFIO device is first put in P2P quiescent state\n"
"                      (RUNNING, _ACTIVE, _RUNNING_P2P)\n"
"                                    |\n"
"                         (RUNNING, _NONE, _RUNNING)"
msgstr ""

#: ../../../devel/migration/vfio.rst:206
msgid "Postcopy"
msgstr ""

#: ../../../devel/migration/vfio.rst:208
msgid "Postcopy migration is currently not supported for VFIO devices."
msgstr ""
