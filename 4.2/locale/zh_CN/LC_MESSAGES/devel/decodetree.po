# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/decodetree.rst:3
msgid "Decodetree Specification"
msgstr ""

#: ../../../devel/decodetree.rst:5
msgid ""
"A *decodetree* is built from instruction *patterns*.  A pattern may "
"represent a single architectural instruction or a group of same, depending "
"on what is convenient for further processing."
msgstr ""

#: ../../../devel/decodetree.rst:9
msgid ""
"Each pattern has both *fixedbits* and *fixedmask*, the combination of which "
"describes the condition under which the pattern is matched::"
msgstr ""

#: ../../../devel/decodetree.rst:12
msgid "(insn & fixedmask) == fixedbits"
msgstr ""

#: ../../../devel/decodetree.rst:14
msgid ""
"Each pattern may have *fields*, which are extracted from the insn and passed "
"along to the translator.  Examples of such are registers, immediates, and "
"sub-opcodes."
msgstr ""

#: ../../../devel/decodetree.rst:18
msgid ""
"In support of patterns, one may declare *fields*, *argument sets*, and "
"*formats*, each of which may be re-used to simplify further definitions."
msgstr ""

#: ../../../devel/decodetree.rst:22
msgid "Fields"
msgstr ""

#: ../../../devel/decodetree.rst:24 ../../../devel/decodetree.rst:66
#: ../../../devel/decodetree.rst:94 ../../../devel/decodetree.rst:141
#: ../../../devel/decodetree.rst:174
msgid "Syntax::"
msgstr ""

#: ../../../devel/decodetree.rst:26
msgid ""
"field_def     := '%' identifier ( unnamed_field )* ( !"
"function=identifier )?\n"
"unnamed_field := number ':' ( 's' ) number"
msgstr ""

#: ../../../devel/decodetree.rst:29
msgid ""
"For *unnamed_field*, the first number is the least-significant bit position "
"of the field and the second number is the length of the field.  If the 's' "
"is present, the field is considered signed.  If multiple ``unnamed_fields`` "
"are present, they are concatenated.  In this way one can define disjoint "
"fields."
msgstr ""

#: ../../../devel/decodetree.rst:34
msgid ""
"If ``!function`` is specified, the concatenated result is passed through the "
"named function, taking and returning an integral value."
msgstr ""

#: ../../../devel/decodetree.rst:37
msgid ""
"One may use ``!function`` with zero ``unnamed_fields``.  This case is called "
"a *parameter*, and the named function is only passed the ``DisasContext`` "
"and returns an integral value extracted from there."
msgstr ""

#: ../../../devel/decodetree.rst:41
msgid "A field with no ``unnamed_fields`` and no ``!function`` is in error."
msgstr ""

#: ../../../devel/decodetree.rst:43
msgid ""
"FIXME: the fields of the structure into which this result will be stored is "
"restricted to ``int``.  Which means that we cannot expand 64-bit items."
msgstr ""

#: ../../../devel/decodetree.rst:46
msgid "Field examples:"
msgstr ""

#: ../../../devel/decodetree.rst:49
msgid "Input"
msgstr ""

#: ../../../devel/decodetree.rst:49
msgid "Generated code"
msgstr ""

#: ../../../devel/decodetree.rst:51
msgid "%disp   0:s16"
msgstr ""

#: ../../../devel/decodetree.rst:51
msgid "sextract(i, 0, 16)"
msgstr ""

#: ../../../devel/decodetree.rst:53
msgid "%imm9   16:6 10:3"
msgstr ""

#: ../../../devel/decodetree.rst:53
msgid "extract(i, 16, 6) << 3 | extract(i, 10, 3)"
msgstr ""

#: ../../../devel/decodetree.rst:55
msgid "%disp12 0:s1 1:1 2:10"
msgstr ""

#: ../../../devel/decodetree.rst:55
msgid "sextract(i, 0, 1) << 11 |"
msgstr ""

#: ../../../devel/decodetree.rst:56
msgid "extract(i, 1, 1) << 10 | extract(i, 2, 10)"
msgstr ""

#: ../../../devel/decodetree.rst:59
msgid "%shimm8 5:s8 13:1"
msgstr ""

#: ../../../devel/decodetree.rst:60
msgid "!function=expand_shimm8"
msgstr ""

#: ../../../devel/decodetree.rst:59
msgid "expand_shimm8(sextract(i, 5, 8) << 1 |"
msgstr ""

#: ../../../devel/decodetree.rst:60
msgid "extract(i, 13, 1))"
msgstr ""

#: ../../../devel/decodetree.rst:64
msgid "Argument Sets"
msgstr ""

#: ../../../devel/decodetree.rst:68
msgid ""
"args_def    := '&' identifier ( args_elt )+ ( !extern )?\n"
"args_elt    := identifier"
msgstr ""

#: ../../../devel/decodetree.rst:71
msgid ""
"Each *args_elt* defines an argument within the argument set. Each argument "
"set will be rendered as a C structure \"arg_$name\" with each of the fields "
"being one of the member arguments."
msgstr ""

#: ../../../devel/decodetree.rst:75
msgid ""
"If ``!extern`` is specified, the backing structure is assumed to have been "
"already declared, typically via a second decoder."
msgstr ""

#: ../../../devel/decodetree.rst:78
msgid ""
"Argument sets are useful when one wants to define helper functions for the "
"translator functions that can perform operations on a common set of "
"arguments.  This can ensure, for instance, that the ``AND`` pattern and the "
"``OR`` pattern put their operands into the same named structure, so that a "
"common ``gen_logic_insn`` may be able to handle the operations common "
"between the two."
msgstr ""

#: ../../../devel/decodetree.rst:85
msgid "Argument set examples::"
msgstr ""

#: ../../../devel/decodetree.rst:87
msgid ""
"&reg3       ra rb rc\n"
"&loadstore  reg base offset"
msgstr ""

#: ../../../devel/decodetree.rst:92
msgid "Formats"
msgstr ""

#: ../../../devel/decodetree.rst:96
msgid ""
"fmt_def      := '@' identifier ( fmt_elt )+\n"
"fmt_elt      := fixedbit_elt | field_elt | field_ref | args_ref\n"
"fixedbit_elt := [01.-]+\n"
"field_elt    := identifier ':' 's'? number\n"
"field_ref    := '%' identifier | identifier '=' '%' identifier\n"
"args_ref     := '&' identifier"
msgstr ""

#: ../../../devel/decodetree.rst:103
msgid ""
"Defining a format is a handy way to avoid replicating groups of fields "
"across many instruction patterns."
msgstr ""

#: ../../../devel/decodetree.rst:106
msgid ""
"A *fixedbit_elt* describes a contiguous sequence of bits that must be 1, 0, "
"or don't care.  The difference between '.' and '-' is that '.' means that "
"the bit will be covered with a field or a final 0 or 1 from the pattern, and "
"'-' means that the bit is really ignored by the cpu and will not be "
"specified."
msgstr ""

#: ../../../devel/decodetree.rst:112
msgid ""
"A *field_elt* describes a simple field only given a width; the position of "
"the field is implied by its position with respect to other *fixedbit_elt* "
"and *field_elt*."
msgstr ""

#: ../../../devel/decodetree.rst:116
msgid ""
"If any *fixedbit_elt* or *field_elt* appear, then all bits must be defined. "
"Padding with a *fixedbit_elt* of all '.' is an easy way to accomplish that."
msgstr ""

#: ../../../devel/decodetree.rst:119
msgid ""
"A *field_ref* incorporates a field by reference.  This is the only way to "
"add a complex field to a format.  A field may be renamed in the process via "
"assignment to another identifier.  This is intended to allow the same "
"argument set be used with disjoint named fields."
msgstr ""

#: ../../../devel/decodetree.rst:124
msgid ""
"A single *args_ref* may specify an argument set to use for the format. The "
"set of fields in the format must be a subset of the arguments in the "
"argument set.  If an argument set is not specified, one will be inferred "
"from the set of fields."
msgstr ""

#: ../../../devel/decodetree.rst:129
msgid ""
"It is recommended, but not required, that all *field_ref* and *args_ref* "
"appear at the end of the line, not interleaving with *fixedbit_elf* or "
"*field_elt*."
msgstr ""

#: ../../../devel/decodetree.rst:133
msgid "Format examples::"
msgstr ""

#: ../../../devel/decodetree.rst:135
msgid ""
"@opr    ...... ra:5 rb:5 ... 0 ....... rc:5\n"
"@opi    ...... ra:5 lit:8    1 ....... rc:5"
msgstr ""

#: ../../../devel/decodetree.rst:139
msgid "Patterns"
msgstr ""

#: ../../../devel/decodetree.rst:143
msgid ""
"pat_def      := identifier ( pat_elt )+\n"
"pat_elt      := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | "
"const_elt\n"
"fmt_ref      := '@' identifier\n"
"const_elt    := identifier '=' number"
msgstr ""

#: ../../../devel/decodetree.rst:148
msgid ""
"The *fixedbit_elt* and *field_elt* specifiers are unchanged from formats. A "
"pattern that does not specify a named format will have one inferred from a "
"referenced argument set (if present) and the set of fields."
msgstr ""

#: ../../../devel/decodetree.rst:152
msgid ""
"A *const_elt* allows a argument to be set to a constant value.  This may "
"come in handy when fields overlap between patterns and one has to include "
"the values in the *fixedbit_elt* instead."
msgstr ""

#: ../../../devel/decodetree.rst:156
msgid "The decoder will call a translator function for each pattern matched."
msgstr ""

#: ../../../devel/decodetree.rst:158
msgid "Pattern examples::"
msgstr ""

#: ../../../devel/decodetree.rst:160
msgid ""
"addl_r   010000 ..... ..... .... 0000000 ..... @opr\n"
"addl_i   010000 ..... ..... .... 0000000 ..... @opi"
msgstr ""

#: ../../../devel/decodetree.rst:163
msgid "which will, in part, invoke::"
msgstr ""

#: ../../../devel/decodetree.rst:165
msgid "trans_addl_r(ctx, &arg_opr, insn)"
msgstr ""

#: ../../../devel/decodetree.rst:167
msgid "and::"
msgstr ""

#: ../../../devel/decodetree.rst:169
msgid "trans_addl_i(ctx, &arg_opi, insn)"
msgstr ""

#: ../../../devel/decodetree.rst:172
msgid "Pattern Groups"
msgstr ""

#: ../../../devel/decodetree.rst:176
msgid "group    := '{' ( pat_def | group )+ '}'"
msgstr ""

#: ../../../devel/decodetree.rst:178
msgid ""
"A *group* begins with a lone open-brace, with all subsequent lines indented "
"two spaces, and ending with a lone close-brace.  Groups may be nested, "
"increasing the required indentation of the lines within the nested group to "
"two spaces per nesting level."
msgstr ""

#: ../../../devel/decodetree.rst:183
msgid ""
"Unlike ungrouped patterns, grouped patterns are allowed to overlap. "
"Conflicts are resolved by selecting the patterns in order.  If all of the "
"fixedbits for a pattern match, its translate function will be called.  If "
"the translate function returns false, then subsequent patterns within the "
"group will be matched."
msgstr ""

#: ../../../devel/decodetree.rst:189
msgid ""
"The following example from PA-RISC shows specialization of the *or* "
"instruction::"
msgstr ""

#: ../../../devel/decodetree.rst:192
msgid ""
"{\n"
"  {\n"
"    nop   000010 ----- ----- 0000 001001 0 00000\n"
"    copy  000010 00000 r1:5  0000 001001 0 rt:5\n"
"  }\n"
"  or      000010 rt2:5 r1:5  cf:4 001001 0 rt:5\n"
"}"
msgstr ""

#: ../../../devel/decodetree.rst:200
msgid ""
"When the *cf* field is zero, the instruction has no side effects, and may be "
"specialized.  When the *rt* field is zero, the output is discarded and so "
"the instruction has no effect.  When the *rt2* field is zero, the operation "
"is ``reg[rt] | 0`` and so encodes the canonical register copy operation."
msgstr ""

#: ../../../devel/decodetree.rst:206
msgid "The output from the generator might look like::"
msgstr ""

#: ../../../devel/decodetree.rst:208
msgid ""
"switch (insn & 0xfc000fe0) {\n"
"case 0x08000240:\n"
"  /* 000010.. ........ ....0010 010..... */\n"
"  if ((insn & 0x0000f000) == 0x00000000) {\n"
"      /* 000010.. ........ 00000010 010..... */\n"
"      if ((insn & 0x0000001f) == 0x00000000) {\n"
"          /* 000010.. ........ 00000010 01000000 */\n"
"          extract_decode_Fmt_0(&u.f_decode0, insn);\n"
"          if (trans_nop(ctx, &u.f_decode0)) return true;\n"
"      }\n"
"      if ((insn & 0x03e00000) == 0x00000000) {\n"
"          /* 00001000 000..... 00000010 010..... */\n"
"          extract_decode_Fmt_1(&u.f_decode1, insn);\n"
"          if (trans_copy(ctx, &u.f_decode1)) return true;\n"
"      }\n"
"  }\n"
"  extract_decode_Fmt_2(&u.f_decode2, insn);\n"
"  if (trans_or(ctx, &u.f_decode2)) return true;\n"
"  return false;\n"
"}"
msgstr ""
