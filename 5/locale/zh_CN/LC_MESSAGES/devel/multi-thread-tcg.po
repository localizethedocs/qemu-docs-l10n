# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/multi-thread-tcg.rst:8
msgid "Introduction"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:10
msgid ""
"This document outlines the design for multi-threaded TCG (a.k.a MTTCG) "
"system-mode emulation. user-mode emulation has always mirrored the thread "
"structure of the translated executable although some of the changes done for "
"MTTCG system emulation have improved the stability of linux-user emulation."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:16
msgid ""
"The original system-mode TCG implementation was single threaded and dealt "
"with multiple CPUs with simple round-robin scheduling. This simplified a lot "
"of things but became increasingly limited as systems being emulated gained "
"additional cores and per-core performance gains for host systems started to "
"level off."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:23
msgid "vCPU Scheduling"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:25
msgid ""
"We introduce a new running mode where each vCPU will run on its own user-"
"space thread. This is enabled by default for all FE/BE combinations where "
"the host memory model is able to accommodate the guest (TCG_GUEST_DEFAULT_MO "
"& ~TCG_TARGET_DEFAULT_MO is zero) and the guest has had the required work "
"done to support this safely (TARGET_SUPPORTS_MTTCG)."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:32
msgid ""
"System emulation will fall back to the original round robin approach if:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:35
msgid "forced by --accel tcg,thread=single"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:36
msgid "enabling --icount mode"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:37
msgid "64 bit guests on 32 bit hosts (TCG_OVERSIZED_GUEST)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:39
msgid ""
"In the general case of running translated code there should be no inter-vCPU "
"dependencies and all vCPUs should be able to run at full speed. "
"Synchronisation will only be required while accessing internal shared data "
"structures or when the emulated architecture requires a coherent "
"representation of the emulated machine state."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:46
msgid "Shared Data Structures"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:49
msgid "Main Run Loop"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:51
msgid ""
"Even when there is no code being generated there are a number of structures "
"associated with the hot-path through the main run-loop. These are associated "
"with looking up the next translation block to execute. These include:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:56
msgid ""
"tb_jmp_cache (per-vCPU, cache of recent jumps) tb_ctx.htable (global hash "
"table, phys address->tb lookup)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:59
msgid ""
"As TB linking only occurs when blocks are in the same page this code is "
"critical to performance as looking up the next TB to execute is the most "
"common reason to exit the generated code."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:63
msgid ""
"DESIGN REQUIREMENT: Make access to lookup structures safe with multiple "
"reader/writer threads. Minimise any lock contention to do it."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:66
msgid ""
"The hot-path avoids using locks where possible. The tb_jmp_cache is updated "
"with atomic accesses to ensure consistent results. The fall back QHT based "
"hash table is also designed for lockless lookups. Locks are only taken when "
"code generation is required or TranslationBlocks have their block-to-block "
"jumps patched."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:73
msgid "Global TCG State"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:76
msgid "User-mode emulation"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:78
msgid ""
"We need to protect the entire code generation cycle including any post "
"generation patching of the translated code. This also implies a shared "
"translation buffer which contains code running on all cores. Any execution "
"path that comes to the main run loop will need to hold a mutex for code "
"generation. This also includes times when we need flush code or entries from "
"any shared lookups/caches. Structures held on a per-vCPU basis won't need "
"locking unless other vCPUs will need to modify them."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:87
msgid ""
"DESIGN REQUIREMENT: Add locking around all code generation and TB patching."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:90
#: ../../../devel/multi-thread-tcg.rst:149
#: ../../../devel/multi-thread-tcg.rst:204
#: ../../../devel/multi-thread-tcg.rst:243
#: ../../../devel/multi-thread-tcg.rst:301
#: ../../../devel/multi-thread-tcg.rst:356
msgid "(Current solution)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:92
msgid "Code generation is serialised with mmap_lock()."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:95
msgid "!User-mode emulation"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:97
msgid ""
"Each vCPU has its own TCG context and associated TCG region, thereby "
"requiring no locking during translation."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:101
msgid "Translation Blocks"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:103
msgid ""
"Currently the whole system shares a single code generation buffer which when "
"full will force a flush of all translations and start from scratch again. "
"Some operations also force a full flush of translations including:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:108
msgid "debugging operations (breakpoint insertion/removal)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:109
msgid "some CPU helper functions"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:110
msgid "linux-user spawning its first thread"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:112
msgid ""
"This is done with the async_safe_run_on_cpu() mechanism to ensure all vCPUs "
"are quiescent when changes are being made to shared global structures."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:116
msgid ""
"More granular translation invalidation events are typically due to a change "
"of the state of a physical page:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:119
msgid "code modification (self modify code, patching code)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:120
msgid "page changes (new page mapping in linux-user mode)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:122
msgid ""
"While setting the invalid flag in a TranslationBlock will stop it being used "
"when looked up in the hot-path there are a number of other book-keeping "
"structures that need to be safely cleared."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:126
msgid ""
"Any TranslationBlocks which have been patched to jump directly to the now "
"invalid blocks need the jump patches reversing so they will return to the C "
"code."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:130
msgid ""
"There are a number of look-up caches that need to be properly updated "
"including the:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:133
msgid "jump lookup cache"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:134
msgid "the physical-to-tb lookup hash table"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:135
msgid "the global page table"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:137
msgid ""
"The global page table (l1_map) which provides a multi-level look-up for "
"PageDesc structures which contain pointers to the start of a linked list of "
"all Translation Blocks in that page (see page_next)."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:141
msgid ""
"Both the jump patching and the page cache involve linked lists that the "
"invalidated TranslationBlock needs to be removed from."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:144
msgid "DESIGN REQUIREMENT: Safely handle invalidation of TBs"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:145
msgid "safely patch/revert direct jumps"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:146
msgid "remove central PageDesc lookup entries"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:147
msgid "ensure lookup caches/hashes are safely updated"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:151
msgid ""
"The direct jump themselves are updated atomically by the TCG "
"tb_set_jmp_target() code. Modification to the linked lists that allow "
"searching for linked pages are done under the protection of tb->jmp_lock, "
"where tb is the destination block of a jump. Each origin block keeps a "
"pointer to its destinations so that the appropriate lock can be acquired "
"before iterating over a jump list."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:158
msgid ""
"The global page table is a lockless radix tree; cmpxchg is used to "
"atomically insert new elements."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:161
msgid ""
"The lookup caches are updated atomically and the lookup hash uses QHT which "
"is designed for concurrent safe lookup."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:164
msgid ""
"Parallel code generation is supported. QHT is used at insertion time as the "
"synchronization point across threads, thereby ensuring that we only keep "
"track of a single TranslationBlock for each guest code block."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:169
msgid "Memory maps and TLBs"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:171
msgid ""
"The memory handling code is fairly critical to the speed of memory access in "
"the emulated system. The SoftMMU code is designed so the hot-path can be "
"handled entirely within translated code. This is handled with a per-vCPU TLB "
"structure which once populated will allow a series of accesses to the page "
"to occur without exiting the translated code. It is possible to set flags in "
"the TLB address which will ensure the slow-path is taken for each access. "
"This can be done to support:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:180
msgid "Memory regions (dividing up access to PIO, MMIO and RAM)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:181
msgid ""
"Dirty page tracking (for code gen, SMC detection, migration and display)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:182
msgid "Virtual TLB (for translating guest address->real address)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:184
msgid ""
"When the TLB tables are updated by a vCPU thread other than their own we "
"need to ensure it is done in a safe way so no inconsistent state is seen by "
"the vCPU thread."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:188
msgid ""
"Some operations require updating a number of vCPUs TLBs at the same time in "
"a synchronised manner."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:191
#: ../../../devel/multi-thread-tcg.rst:349
msgid "DESIGN REQUIREMENTS:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:193
msgid ""
"TLB Flush All/Page - can be across-vCPUs - cross vCPU TLB flush may need "
"other vCPU brought to halt - change may need to be visible to the calling "
"vCPU immediately"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:197
msgid ""
"TLB Flag Update - usually cross-vCPU - want change to be visible as soon as "
"possible"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:200
msgid ""
"TLB Update (update a CPUTLBEntry, via tlb_set_page_with_attrs) - This is a "
"per-vCPU table - by definition can't race - updated by its own thread when "
"the slow-path is forced"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:206
msgid ""
"We have updated cputlb.c to defer operations when a cross-vCPU operation "
"with async_run_on_cpu() which ensures each vCPU sees a coherent state when "
"it next runs its work (in a few instructions time)."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:211
msgid ""
"A new set up operations (tlb_flush_*_all_cpus) take an additional flag which "
"when set will force synchronisation by setting the source vCPUs work as "
"\"safe work\" and exiting the cpu run loop. This ensure by the time "
"execution restarts all flush operations have completed."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:216
msgid ""
"TLB flag updates are all done atomically and are also protected by the "
"corresponding page lock."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:219
msgid "(Known limitation)"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:221
msgid ""
"Not really a limitation but the wait mechanism is overly strict for some "
"architectures which only need flushes completed by a barrier instruction. "
"This could be a future optimisation."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:226
msgid "Emulated hardware state"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:228
msgid ""
"Currently thanks to KVM work any access to IO memory is automatically "
"protected by the global iothread mutex, also known as the BQL (Big Qemu "
"Lock). Any IO region that doesn't use global mutex is expected to do its own "
"locking."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:233
msgid ""
"However IO memory isn't the only way emulated hardware state can be "
"modified. Some architectures have model specific registers that trigger "
"hardware emulation features. Generally any translation helper that needs to "
"update more than a single vCPUs of state should take the BQL."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:239
msgid ""
"As the BQL, or global iothread mutex is shared across the system we push the "
"use of the lock as far down into the TCG code as possible to minimise "
"contention."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:245
msgid ""
"MMIO access automatically serialises hardware emulation by way of the BQL. "
"Currently Arm targets serialise all ARM_CP_IO register accesses and also "
"defer the reset/startup of vCPUs to the vCPU context by way of "
"async_run_on_cpu()."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:250
msgid ""
"Updates to interrupt state are also protected by the BQL as they can often "
"be cross vCPU."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:254
msgid "Memory Consistency"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:256
msgid ""
"Between emulated guests and host systems there are a range of memory "
"consistency models. Even emulating weakly ordered systems on strongly "
"ordered hosts needs to ensure things like store-after-load re-ordering can "
"be prevented when the guest wants to."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:262
msgid "Memory Barriers"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:264
msgid ""
"Barriers (sometimes known as fences) provide a mechanism for software to "
"enforce a particular ordering of memory operations from the point of view of "
"external observers (e.g. another processor core). They can apply to any "
"memory operations as well as just loads or stores."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:269
msgid ""
"The Linux kernel has an excellent `write-up <https://git.kernel.org/cgit/"
"linux/kernel/git/torvalds/linux.git/plain/Documentation/memory-barriers."
"txt>`_ on the various forms of memory barrier and the guarantees they can "
"provide."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:274
msgid ""
"Barriers are often wrapped around synchronisation primitives to provide "
"explicit memory ordering semantics. However they can be used by themselves "
"to provide safe lockless access by ensuring for example a change to a signal "
"flag will only be visible once the changes to payload are."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:280
msgid "DESIGN REQUIREMENT: Add a new tcg_memory_barrier op"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:282
msgid ""
"This would enforce a strong load/store ordering so all loads/stores complete "
"at the memory barrier. On single-core non-SMP strongly ordered backends this "
"could become a NOP."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:286
msgid ""
"Aside from explicit standalone memory barrier instructions there are also "
"implicit memory ordering semantics which comes with each guest memory access "
"instruction. For example all x86 load/stores come with fairly strong "
"guarantees of sequential consistency whereas Arm has special variants of "
"load/store instructions that imply acquire/release semantics."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:293
msgid ""
"In the case of a strongly ordered guest architecture being emulated on a "
"weakly ordered host the scope for a heavy performance impact is quite high."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:297
msgid "DESIGN REQUIREMENTS: Be efficient with use of memory barriers"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:298
msgid "host systems with stronger implied guarantees can skip some barriers"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:299
msgid "merge consecutive barriers to the strongest one"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:303
msgid ""
"The system currently has a tcg_gen_mb() which will add memory barrier "
"operations if code generation is being done in a parallel context. The "
"tcg_optimize() function attempts to merge barriers up to their strongest "
"form before any load/store operations. The solution was originally developed "
"and tested for linux-user based systems. All backends have been converted to "
"emit fences when required. So far the following front-ends have been updated "
"to emit fences when required:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:311
msgid "target-i386"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:312
msgid "target-arm"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:313
msgid "target-aarch64"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:314
msgid "target-alpha"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:315
msgid "target-mips"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:318
msgid "Memory Control and Maintenance"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:320
msgid ""
"This includes a class of instructions for controlling system cache "
"behaviour. While QEMU doesn't model cache behaviour these instructions are "
"often seen when code modification has taken place to ensure the changes take "
"effect."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:326
msgid "Synchronisation Primitives"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:328
msgid ""
"There are two broad types of synchronisation primitives found in modern "
"ISAs: atomic instructions and exclusive regions."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:331
msgid ""
"The first type offer a simple atomic instruction which will guarantee some "
"sort of test and conditional store will be truly atomic w.r.t. other cores "
"sharing access to the memory. The classic example is the x86 cmpxchg "
"instruction."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:336
msgid ""
"The second type offer a pair of load/store instructions which offer a "
"guarantee that a region of memory has not been touched between the load and "
"store instructions. An example of this is Arm's ldrex/strex pair where the "
"strex instruction will return a flag indicating a successful store only if "
"no other CPU has accessed the memory region since the ldrex."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:343
msgid ""
"Traditionally TCG has generated a series of operations that work because "
"they are within the context of a single translation block so will have "
"completed before another CPU is scheduled. However with the ability to have "
"multiple threads running to emulate multiple CPUs we will need to explicitly "
"expose these semantics."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:350
msgid "Support classic atomic instructions"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:351
msgid "Support load/store exclusive (or load link/store conditional) pairs"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:352
msgid "Generic enough infrastructure to support all guest architectures"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:353
msgid "CURRENT OPEN QUESTIONS:"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:354
msgid "How problematic is the ABA problem in general?"
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:358
msgid ""
"The TCG provides a number of atomic helpers (tcg_gen_atomic_*) which can be "
"used directly or combined to emulate other instructions like Arm's ldrex/"
"strex instructions. While they are susceptible to the ABA problem so far "
"common guests have not implemented patterns where this may be a problem - "
"typically presenting a locking ABI which assumes cmpxchg like semantics."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:365
msgid ""
"The code also includes a fall-back for cases where multi-threaded TCG ops "
"can't work (e.g. guest atomic width > host atomic width). In this case an "
"EXCP_ATOMIC exit occurs and the instruction is emulated with an exclusive "
"lock which ensures all emulation is serialised."
msgstr ""

#: ../../../devel/multi-thread-tcg.rst:370
msgid ""
"While the atomic helpers look good enough for now there may be a need to "
"look at solutions that can more closely model the guest architectures "
"semantics."
msgstr ""
