# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../interop/bitmaps.rst:10
msgid "Dirty Bitmaps and Incremental Backup"
msgstr ""

#: ../../../interop/bitmaps.rst:12
msgid ""
"Dirty Bitmaps are in-memory objects that track writes to block devices. They "
"can be used in conjunction with various block job operations to perform "
"incremental or differential backup regimens."
msgstr ""

#: ../../../interop/bitmaps.rst:16
msgid ""
"This document explains the conceptual mechanisms, as well as up-to-date, "
"complete and comprehensive documentation on the API to manipulate them. "
"(Hopefully, the \"why\", \"what\", and \"how\".)"
msgstr ""

#: ../../../interop/bitmaps.rst:20
msgid ""
"The intended audience for this document is developers who are adding QEMU "
"backup features to management applications, or power users who run and "
"administer QEMU directly via QMP."
msgstr ""

#: ../../../interop/bitmaps.rst:24
msgid "Contents"
msgstr ""

#: ../../../interop/bitmaps.rst:27
msgid "Overview"
msgstr "概覽"

#: ../../../interop/bitmaps.rst:29
msgid ""
"Bitmaps are bit vectors where each '1' bit in the vector indicates a "
"modified (\"dirty\") segment of the corresponding block device. The size of "
"the segment that is tracked is the granularity of the bitmap. If the "
"granularity of a bitmap is 64K, each '1' bit means that a 64K region as a "
"whole may have changed in some way, possibly by as little as one byte."
msgstr ""

#: ../../../interop/bitmaps.rst:35
msgid ""
"Smaller granularities mean more accurate tracking of modified disk data, but "
"requires more computational overhead and larger bitmap sizes. Larger "
"granularities mean smaller bitmap sizes, but less targeted backups."
msgstr ""

#: ../../../interop/bitmaps.rst:39
msgid "The size of a bitmap (in bytes) can be computed as such:"
msgstr ""

#: ../../../interop/bitmaps.rst:40
msgid "``size`` = ceil(ceil(``image_size`` / ``granularity``) / 8)"
msgstr ""

#: ../../../interop/bitmaps.rst:42
msgid "e.g. the size of a 64KiB granularity bitmap on a 2TiB image is:"
msgstr ""

#: ../../../interop/bitmaps.rst:43
msgid "``size`` = ((2147483648K / 64K) / 8)"
msgstr ""

#: ../../../interop/bitmaps.rst:44
msgid "= 4194304B = 4MiB."
msgstr ""

#: ../../../interop/bitmaps.rst:46
msgid ""
"QEMU uses these bitmaps when making incremental backups to know which "
"sections of the file to copy out. They are not enabled by default and must "
"be explicitly added in order to begin tracking writes."
msgstr ""

#: ../../../interop/bitmaps.rst:50
msgid ""
"Bitmaps can be created at any time and can be attached to any arbitrary "
"block node in the storage graph, but are most useful conceptually when "
"attached to the root node attached to the guest's storage device model."
msgstr ""

#: ../../../interop/bitmaps.rst:54
msgid ""
"That is to say: It's likely most useful to track the guest's writes to disk, "
"but you could theoretically track things like qcow2 metadata changes by "
"attaching the bitmap elsewhere in the storage graph. This is beyond the "
"scope of this document."
msgstr ""

#: ../../../interop/bitmaps.rst:59
msgid ""
"QEMU supports persisting these bitmaps to disk via the qcow2 image format. "
"Bitmaps which are stored or loaded in this way are called \"persistent\", "
"whereas bitmaps that are not are called \"transient\"."
msgstr ""

#: ../../../interop/bitmaps.rst:63
msgid ""
"QEMU also supports the migration of both transient bitmaps (tracking any "
"arbitrary image format) or persistent bitmaps (qcow2) via live migration."
msgstr ""

#: ../../../interop/bitmaps.rst:67
msgid "Supported Image Formats"
msgstr ""

#: ../../../interop/bitmaps.rst:69
msgid "QEMU supports all documented features below on the qcow2 image format."
msgstr ""

#: ../../../interop/bitmaps.rst:71
msgid ""
"However, qcow2 is only strictly necessary for the persistence feature, which "
"writes bitmap data to disk upon close. If persistence is not required for a "
"specific use case, all bitmap features excepting persistence are available "
"for any arbitrary image format."
msgstr ""

#: ../../../interop/bitmaps.rst:76
msgid ""
"For example, Dirty Bitmaps can be combined with the 'raw' image format, but "
"any changes to the bitmap will be discarded upon exit."
msgstr ""

#: ../../../interop/bitmaps.rst:79
msgid ""
"Transient bitmaps will not be saved on QEMU exit! Persistent bitmaps are "
"available only on qcow2 images."
msgstr ""

#: ../../../interop/bitmaps.rst:83
msgid "Dirty Bitmap Names"
msgstr ""

#: ../../../interop/bitmaps.rst:85
msgid ""
"Bitmap objects need a method to reference them in the API. All API-created "
"and managed bitmaps have a human-readable name chosen by the user at "
"creation time."
msgstr ""

#: ../../../interop/bitmaps.rst:89
msgid ""
"A bitmap's name is unique to the node, but bitmaps attached to different "
"nodes can share the same name. Therefore, all bitmaps are addressed via "
"their (node, name) pair."
msgstr ""

#: ../../../interop/bitmaps.rst:93
msgid "The name of a user-created bitmap cannot be empty (\"\")."
msgstr ""

#: ../../../interop/bitmaps.rst:95
msgid ""
"Transient bitmaps can have JSON unicode names that are effectively not "
"length limited. (QMP protocol may restrict messages to less than 64MiB.)"
msgstr ""

#: ../../../interop/bitmaps.rst:98
msgid ""
"Persistent storage formats may impose their own requirements on bitmap names "
"and namespaces. Presently, only qcow2 supports persistent bitmaps. See docs/"
"interop/qcow2.txt for more details on restrictions. Notably:"
msgstr ""

#: ../../../interop/bitmaps.rst:102
msgid "qcow2 bitmap names are limited to between 1 and 1023 bytes long."
msgstr ""

#: ../../../interop/bitmaps.rst:104
msgid "No two bitmaps saved to the same qcow2 file may share the same name."
msgstr ""

#: ../../../interop/bitmaps.rst:106
msgid ""
"QEMU occasionally uses bitmaps for internal use which have no name. They are "
"hidden from API query calls, cannot be manipulated by the external API, are "
"never persistent, nor ever migrated."
msgstr ""

#: ../../../interop/bitmaps.rst:111
msgid "Bitmap Status"
msgstr ""

#: ../../../interop/bitmaps.rst:113
msgid ""
"Dirty Bitmap objects can be queried with the QMP command `query-block <qemu-"
"qmp-ref.html#index-query_002dblock>`_, and are visible via the "
"`BlockDirtyInfo <qemu-qmp-ref.html#index-BlockDirtyInfo>`_ QAPI structure."
msgstr ""

#: ../../../interop/bitmaps.rst:117
msgid ""
"This struct shows the name, granularity, and dirty byte count for each "
"bitmap. Additionally, it shows several boolean status indicators:"
msgstr ""

#: ../../../interop/bitmaps.rst:120
msgid "``recording``: This bitmap is recording writes."
msgstr ""

#: ../../../interop/bitmaps.rst:121
msgid "``busy``: This bitmap is in-use by an operation."
msgstr ""

#: ../../../interop/bitmaps.rst:122
msgid "``persistent``: This bitmap is a persistent type."
msgstr ""

#: ../../../interop/bitmaps.rst:123
msgid "``inconsistent``: This bitmap is corrupted and cannot be used."
msgstr ""

#: ../../../interop/bitmaps.rst:125
msgid ""
"The ``+busy`` status prohibits you from deleting, clearing, or otherwise "
"modifying a bitmap, and happens when the bitmap is being used for a backup "
"operation or is in the process of being loaded from a migration. Many of the "
"commands documented below will refuse to work on such bitmaps."
msgstr ""

#: ../../../interop/bitmaps.rst:130
msgid ""
"The ``+inconsistent`` status similarly prohibits almost all operations, "
"notably allowing only the ``block-dirty-bitmap-remove`` operation."
msgstr ""

#: ../../../interop/bitmaps.rst:133
msgid ""
"There is also a deprecated ``status`` field of type `DirtyBitmapStatus <qemu-"
"qmp-ref.html#index-DirtyBitmapStatus>`_. A bitmap historically had five "
"visible states:"
msgstr ""

#: ../../../interop/bitmaps.rst:137
msgid ""
"``Frozen``: This bitmap is currently in-use by an operation and is "
"immutable. It can't be deleted, renamed, reset, etc."
msgstr ""

#: ../../../interop/bitmaps.rst:140 ../../../interop/bitmaps.rst:153
msgid "(This is now ``+busy``.)"
msgstr ""

#: ../../../interop/bitmaps.rst:142
msgid "``Disabled``: This bitmap is not recording new writes."
msgstr ""

#: ../../../interop/bitmaps.rst:144
msgid "(This is now ``-recording -busy``.)"
msgstr ""

#: ../../../interop/bitmaps.rst:146
msgid "``Active``: This bitmap is recording new writes."
msgstr ""

#: ../../../interop/bitmaps.rst:148
msgid "(This is now ``+recording -busy``.)"
msgstr ""

#: ../../../interop/bitmaps.rst:150
msgid ""
"``Locked``: This bitmap is in-use by an operation, and is immutable. The "
"difference from \"Frozen\" was primarily implementation details."
msgstr ""

#: ../../../interop/bitmaps.rst:155
msgid ""
"``Inconsistent``: This persistent bitmap was not saved to disk correctly, "
"and can no longer be used. It remains in memory to serve as an indicator of "
"failure."
msgstr ""

#: ../../../interop/bitmaps.rst:159
msgid "(This is now ``+inconsistent``.)"
msgstr ""

#: ../../../interop/bitmaps.rst:161
msgid ""
"These states are directly replaced by the status indicators and should not "
"be used. The difference between ``Frozen`` and ``Locked`` is an "
"implementation detail and should not be relevant to external users."
msgstr ""

#: ../../../interop/bitmaps.rst:166
msgid "Basic QMP Usage"
msgstr ""

#: ../../../interop/bitmaps.rst:168
msgid ""
"The primary interface to manipulating bitmap objects is via the QMP "
"interface. If you are not familiar, see docs/interop/qmp-intro.txt for a "
"broad overview, and `qemu-qmp-ref <qemu-qmp-ref.html>`_ for a full reference "
"of all QMP commands."
msgstr ""

#: ../../../interop/bitmaps.rst:174
msgid "Supported Commands"
msgstr ""

#: ../../../interop/bitmaps.rst:176
msgid "There are six primary bitmap-management API commands:"
msgstr ""

#: ../../../interop/bitmaps.rst:178 ../../../interop/bitmaps.rst:525
msgid "``block-dirty-bitmap-add``"
msgstr ""

#: ../../../interop/bitmaps.rst:179
msgid "``block-dirty-bitmap-remove``"
msgstr ""

#: ../../../interop/bitmaps.rst:180 ../../../interop/bitmaps.rst:526
msgid "``block-dirty-bitmap-clear``"
msgstr ""

#: ../../../interop/bitmaps.rst:181 ../../../interop/bitmaps.rst:528
msgid "``block-dirty-bitmap-disable``"
msgstr ""

#: ../../../interop/bitmaps.rst:182 ../../../interop/bitmaps.rst:527
msgid "``block-dirty-bitmap-enable``"
msgstr ""

#: ../../../interop/bitmaps.rst:183 ../../../interop/bitmaps.rst:529
msgid "``block-dirty-bitmap-merge``"
msgstr ""

#: ../../../interop/bitmaps.rst:185
msgid "And one related query command:"
msgstr ""

#: ../../../interop/bitmaps.rst:187
msgid "``query-block``"
msgstr ""

#: ../../../interop/bitmaps.rst:190
msgid "Creation: block-dirty-bitmap-add"
msgstr ""

#: ../../../interop/bitmaps.rst:192
msgid ""
"`block-dirty-bitmap-add <qemu-qmp-ref.html#index-"
"block_002ddirty_002dbitmap_002dadd>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:195
msgid ""
"Creates a new bitmap that tracks writes to the specified node. granularity, "
"persistence, and recording state can be adjusted at creation time."
msgstr ""

#: ../../../interop/bitmaps.rst:198 ../../../interop/bitmaps.rst:218
#: ../../../interop/bitmaps.rst:253 ../../../interop/bitmaps.rst:279
#: ../../../interop/bitmaps.rst:308 ../../../interop/bitmaps.rst:346
#: ../../../interop/bitmaps.rst:390 ../../../interop/bitmaps.rst:420
msgid "Example"
msgstr ""

#: ../../../interop/bitmaps.rst:200
msgid "to create a new, actively recording persistent bitmap:"
msgstr ""

#: ../../../interop/bitmaps.rst:202
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-add\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"name\": \"bitmap0\",\n"
"       \"persistent\": true,\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:214
msgid ""
"This bitmap will have a default granularity that matches the cluster size of "
"its associated drive, if available, clamped to between [4KiB, 64KiB]. The "
"current default for qcow2 is 64KiB."
msgstr ""

#: ../../../interop/bitmaps.rst:220
msgid ""
"To create a new, disabled (``-recording``), transient bitmap that tracks "
"changes in 32KiB segments:"
msgstr ""

#: ../../../interop/bitmaps.rst:223
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-add\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"name\": \"bitmap1\",\n"
"       \"granularity\": 32768,\n"
"       \"disabled\": true\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:237
msgid "Deletion: block-dirty-bitmap-remove"
msgstr ""

#: ../../../interop/bitmaps.rst:239
msgid ""
"`block-dirty-bitmap-remove <qemu-qmp-ref.html#index-"
"block_002ddirty_002dbitmap_002dremove>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:242
msgid "Deletes a bitmap. Bitmaps that are ``+busy`` cannot be removed."
msgstr ""

#: ../../../interop/bitmaps.rst:244
msgid ""
"Deleting a bitmap does not impact any other bitmaps attached to the same "
"node, nor does it affect any backups already created from this bitmap or "
"node."
msgstr ""

#: ../../../interop/bitmaps.rst:248
msgid ""
"Because bitmaps are only unique to the node to which they are attached, you "
"must specify the node/drive name here, too."
msgstr ""

#: ../../../interop/bitmaps.rst:251
msgid "Deleting a persistent bitmap will remove it from the qcow2 file."
msgstr ""

#: ../../../interop/bitmaps.rst:255
msgid "Remove a bitmap named ``bitmap0`` from node ``drive0``:"
msgstr ""

#: ../../../interop/bitmaps.rst:257
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-remove\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"name\": \"bitmap0\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:269
msgid "Resetting: block-dirty-bitmap-clear"
msgstr ""

#: ../../../interop/bitmaps.rst:271
msgid ""
"`block-dirty-bitmap-clear <qemu-qmp-ref.html#index-"
"block_002ddirty_002dbitmap_002dclear>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:274
msgid ""
"Clears all dirty bits from a bitmap. ``+busy`` bitmaps cannot be cleared."
msgstr ""

#: ../../../interop/bitmaps.rst:276
msgid ""
"An incremental backup created from an empty bitmap will copy no data, as if "
"nothing has changed."
msgstr ""

#: ../../../interop/bitmaps.rst:281
msgid "Clear all dirty bits from bitmap ``bitmap0`` on node ``drive0``:"
msgstr ""

#: ../../../interop/bitmaps.rst:283
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-clear\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"name\": \"bitmap0\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:295
msgid "Enabling: block-dirty-bitmap-enable"
msgstr ""

#: ../../../interop/bitmaps.rst:297
msgid ""
"`block-dirty-bitmap-enable <qemu-qmp-ref.html#index-"
"block_002ddirty_002dbitmap_002denable>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:300
msgid ""
"\"Enables\" a bitmap, setting the ``recording`` bit to true, causing writes "
"to begin being recorded. ``+busy`` bitmaps cannot be enabled."
msgstr ""

#: ../../../interop/bitmaps.rst:303
msgid ""
"Bitmaps default to being enabled when created, unless configured otherwise."
msgstr ""

#: ../../../interop/bitmaps.rst:305
msgid ""
"Persistent enabled bitmaps will remember their ``+recording`` status on load."
msgstr ""

#: ../../../interop/bitmaps.rst:310
msgid "To set ``+recording`` on bitmap ``bitmap0`` on node ``drive0``:"
msgstr ""

#: ../../../interop/bitmaps.rst:312
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-enable\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"name\": \"bitmap0\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:324
msgid "Enabling: block-dirty-bitmap-disable"
msgstr ""

#: ../../../interop/bitmaps.rst:326
msgid ""
"`block-dirty-bitmap-disable <qemu-qmp-ref.html#index-"
"block_002ddirty_002dbitmap_002ddisable>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:329
msgid ""
"\"Disables\" a bitmap, setting the ``recording`` bit to false, causing "
"further writes to begin being ignored. ``+busy`` bitmaps cannot be disabled."
msgstr ""

#: ../../../interop/bitmaps.rst:334
msgid ""
"This is potentially dangerous: QEMU makes no effort to stop any writes if "
"there are disabled bitmaps on a node, and will not mark any disabled bitmaps "
"as ``+inconsistent`` if any such writes do happen. Backups made from such "
"bitmaps will not be able to be used to reconstruct a coherent image."
msgstr ""

#: ../../../interop/bitmaps.rst:339
msgid ""
"Disabling a bitmap may be useful for examining which sectors of a disk "
"changed during a specific time period, or for explicit management of "
"differential backup windows."
msgstr ""

#: ../../../interop/bitmaps.rst:343
msgid ""
"Persistent disabled bitmaps will remember their ``-recording`` status on "
"load."
msgstr ""

#: ../../../interop/bitmaps.rst:348
msgid "To set ``-recording`` on bitmap ``bitmap0`` on node ``drive0``:"
msgstr ""

#: ../../../interop/bitmaps.rst:350
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-disable\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"name\": \"bitmap0\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:362
msgid "Merging, Copying: block-dirty-bitmap-merge"
msgstr ""

#: ../../../interop/bitmaps.rst:364
msgid ""
"`block-dirty-bitmap-merge <qemu-qmp-ref.html#index-"
"block_002ddirty_002dbitmap_002dmerge>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:367
msgid ""
"Merges one or more bitmaps into a target bitmap. For any segment that is "
"dirty in any one source bitmap, the target bitmap will mark that segment "
"dirty."
msgstr ""

#: ../../../interop/bitmaps.rst:370
msgid ""
"Merge takes one or more bitmaps as a source and merges them together into a "
"single destination, such that any segment marked as dirty in any source "
"bitmap(s) will be marked dirty in the destination bitmap."
msgstr ""

#: ../../../interop/bitmaps.rst:374
msgid ""
"Merge does not create the destination bitmap if it does not exist. A blank "
"bitmap can be created beforehand to achieve the same effect."
msgstr ""

#: ../../../interop/bitmaps.rst:377
msgid ""
"The destination is not cleared prior to merge, so subsequent merge "
"operations will continue to cumulatively mark more segments as dirty."
msgstr ""

#: ../../../interop/bitmaps.rst:380
msgid ""
"If the merge operation should fail, the destination bitmap is guaranteed to "
"be unmodified. The operation may fail if the source or destination bitmaps "
"are busy, or have different granularities."
msgstr ""

#: ../../../interop/bitmaps.rst:384
msgid ""
"Bitmaps can only be merged on the same node. There is only one \"node\" "
"argument, so all bitmaps must be attached to that same node."
msgstr ""

#: ../../../interop/bitmaps.rst:387
msgid ""
"Copy can be achieved by merging from a single source to an empty destination."
msgstr ""

#: ../../../interop/bitmaps.rst:392
msgid ""
"Merge the data from ``bitmap0`` into the bitmap ``new_bitmap`` on node "
"``drive0``. If ``new_bitmap`` was empty prior to this command, this achieves "
"a copy."
msgstr ""

#: ../../../interop/bitmaps.rst:396
msgid ""
"-> { \"execute\": \"block-dirty-bitmap-merge\",\n"
"     \"arguments\": {\n"
"       \"node\": \"drive0\",\n"
"       \"target\": \"new_bitmap\",\n"
"       \"bitmaps\": [ \"bitmap0\" ]\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:409
msgid "Querying: query-block"
msgstr ""

#: ../../../interop/bitmaps.rst:411
msgid "`query-block <qemu-qmp-ref.html#index-query_002dblock>`_:"
msgstr ""

#: ../../../interop/bitmaps.rst:414
msgid ""
"Not strictly a bitmaps command, but will return information about any "
"bitmaps attached to nodes serving as the root for guest devices."
msgstr ""

#: ../../../interop/bitmaps.rst:417
msgid ""
"The \"inconsistent\" bit will not appear when it is false, appearing only "
"when the value is true to indicate there is a problem."
msgstr ""

#: ../../../interop/bitmaps.rst:422
msgid ""
"Query the block sub-system of QEMU. The following json has trimmed "
"irrelevant keys from the response to highlight only the bitmap-relevant "
"portions of the API. This result highlights a bitmap ``bitmap0`` attached to "
"the root node of device ``drive0``."
msgstr ""

#: ../../../interop/bitmaps.rst:427
msgid ""
"-> {\n"
"     \"execute\": \"query-block\",\n"
"     \"arguments\": {}\n"
"   }\n"
"\n"
"<- {\n"
"     \"return\": [ {\n"
"       \"dirty-bitmaps\": [ {\n"
"         \"status\": \"active\",\n"
"         \"count\": 0,\n"
"         \"busy\": false,\n"
"         \"name\": \"bitmap0\",\n"
"         \"persistent\": false,\n"
"         \"recording\": true,\n"
"         \"granularity\": 65536\n"
"       } ],\n"
"       \"device\": \"drive0\",\n"
"     } ]\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:450
msgid "Bitmap Persistence"
msgstr ""

#: ../../../interop/bitmaps.rst:452
msgid ""
"As outlined in `Supported Image Formats`_, QEMU can persist bitmaps to qcow2 "
"files. Demonstrated in `Creation: block-dirty-bitmap-add`_, passing "
"``persistent: true`` to ``block-dirty-bitmap-add`` will persist that bitmap "
"to disk."
msgstr ""

#: ../../../interop/bitmaps.rst:457
msgid ""
"Persistent bitmaps will be automatically loaded into memory upon load, and "
"will be written back to disk upon close. Their usage should be mostly "
"transparent."
msgstr ""

#: ../../../interop/bitmaps.rst:461
msgid ""
"However, if QEMU does not get a chance to close the file cleanly, the bitmap "
"will be marked as ``+inconsistent`` at next load and considered unsafe to "
"use for any operation. At this point, the only valid operation on such "
"bitmaps is ``block-dirty-bitmap-remove``."
msgstr ""

#: ../../../interop/bitmaps.rst:466
msgid ""
"Losing a bitmap in this way does not invalidate any existing backups that "
"have been made from this bitmap, but no further backups will be able to be "
"issued for this chain."
msgstr ""

#: ../../../interop/bitmaps.rst:471
msgid "Transactions"
msgstr ""

#: ../../../interop/bitmaps.rst:473
msgid ""
"Transactions are a QMP feature that allows you to submit multiple QMP "
"commands at once, being guaranteed that they will all succeed or fail "
"atomically, together. The interaction of bitmaps and transactions are "
"demonstrated below."
msgstr ""

#: ../../../interop/bitmaps.rst:477
msgid ""
"See `transaction <qemu-qmp.ref.html#index-transaction>`_ in the QMP "
"reference for more details."
msgstr ""

#: ../../../interop/bitmaps.rst:481
msgid "Justification"
msgstr ""

#: ../../../interop/bitmaps.rst:483
msgid ""
"Bitmaps can generally be modified at any time, but certain operations often "
"only make sense when paired directly with other commands. When a VM is "
"paused, it's easy to ensure that no guest writes occur between individual "
"QMP commands. When a VM is running, this is difficult to accomplish with "
"individual QMP commands that may allow guest writes to occur between each "
"command."
msgstr ""

#: ../../../interop/bitmaps.rst:490
msgid "For example, using only individual QMP commands, we could:"
msgstr ""

#: ../../../interop/bitmaps.rst:492
msgid "Boot the VM in a paused state."
msgstr ""

#: ../../../interop/bitmaps.rst:493
msgid "Create a full drive backup of drive0."
msgstr ""

#: ../../../interop/bitmaps.rst:494
msgid ""
"Create a new bitmap attached to drive0, confident that nothing has been "
"written to drive0 in the meantime."
msgstr ""

#: ../../../interop/bitmaps.rst:496
msgid "Resume execution of the VM."
msgstr ""

#: ../../../interop/bitmaps.rst:497 ../../../interop/bitmaps.rst:513
msgid "At a later point, issue incremental backups from ``bitmap0``."
msgstr ""

#: ../../../interop/bitmaps.rst:499
msgid ""
"At this point, the bitmap and drive backup would be correctly in sync, and "
"incremental backups made from this point forward would be correctly aligned "
"to the full drive backup."
msgstr ""

#: ../../../interop/bitmaps.rst:503
msgid ""
"This is not particularly useful if we decide we want to start incremental "
"backups after the VM has been running for a while, for which we would want "
"to perform actions such as the following:"
msgstr ""

#: ../../../interop/bitmaps.rst:507
msgid "Boot the VM and begin execution."
msgstr ""

#: ../../../interop/bitmaps.rst:508
msgid "Using a single transaction, perform the following operations:"
msgstr ""

#: ../../../interop/bitmaps.rst:510
msgid "Create ``bitmap0``."
msgstr ""

#: ../../../interop/bitmaps.rst:511
msgid "Create a full drive backup of ``drive0``."
msgstr ""

#: ../../../interop/bitmaps.rst:515
msgid ""
"As a consideration, if ``bitmap0`` is created prior to the full drive "
"backup, incremental backups can still be authored from this bitmap, but they "
"will copy extra segments reflecting writes that occurred prior to the backup "
"operation. Transactions allow us to narrow critical points in time to reduce "
"waste, or, in the other direction, to ensure that no segments are omitted."
msgstr ""

#: ../../../interop/bitmaps.rst:523
msgid "Supported Bitmap Transactions"
msgstr ""

#: ../../../interop/bitmaps.rst:531
msgid ""
"The usages for these commands are identical to their respective QMP "
"commands, but see the sections below for concrete examples."
msgstr ""

#: ../../../interop/bitmaps.rst:535
msgid "Incremental Backups - Push Model"
msgstr ""

#: ../../../interop/bitmaps.rst:537
msgid ""
"Incremental backups are simply partial disk images that can be combined with "
"other partial disk images on top of a base image to reconstruct a full "
"backup from the point in time at which the incremental backup was issued."
msgstr ""

#: ../../../interop/bitmaps.rst:541
msgid ""
"The \"Push Model\" here references the fact that QEMU is \"pushing\" the "
"modified blocks out to a destination. We will be using the `drive-backup "
"<qemu-qmp-ref.html#index-drive_002dbackup>`_ and `blockdev-backup <qemu-qmp-"
"ref.html#index-blockdev_002dbackup>`_ QMP commands to create both full and "
"incremental backups."
msgstr ""

#: ../../../interop/bitmaps.rst:547
msgid ""
"Both of these commands are jobs, which have their own QMP API for querying "
"and management documented in `Background jobs <qemu-qmp-ref.html#Background-"
"jobs>`_."
msgstr ""

#: ../../../interop/bitmaps.rst:552
msgid "Example: New Incremental Backup Anchor Point"
msgstr ""

#: ../../../interop/bitmaps.rst:554
msgid ""
"As outlined in the Transactions - `Justification`_ section, perhaps we want "
"to create a new incremental backup chain attached to a drive."
msgstr ""

#: ../../../interop/bitmaps.rst:557
msgid ""
"This example creates a new, full backup of \"drive0\" and accompanies it "
"with a new, empty bitmap that records writes from this point in time forward."
msgstr ""

#: ../../../interop/bitmaps.rst:560
msgid ""
"Any new writes that happen after this command is issued, even while the "
"backup job runs, will be written locally and not to the backup destination. "
"These writes will be recorded in the bitmap accordingly."
msgstr ""

#: ../../../interop/bitmaps.rst:565
msgid ""
"-> {\n"
"     \"execute\": \"transaction\",\n"
"     \"arguments\": {\n"
"       \"actions\": [\n"
"         {\n"
"           \"type\": \"block-dirty-bitmap-add\",\n"
"           \"data\": {\n"
"             \"node\": \"drive0\",\n"
"             \"name\": \"bitmap0\"\n"
"           }\n"
"         },\n"
"         {\n"
"           \"type\": \"drive-backup\",\n"
"           \"data\": {\n"
"             \"device\": \"drive0\",\n"
"             \"target\": \"/path/to/drive0.full.qcow2\",\n"
"             \"sync\": \"full\",\n"
"             \"format\": \"qcow2\"\n"
"           }\n"
"         }\n"
"       ]\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"<- {\n"
"     \"timestamp\": {\n"
"       \"seconds\": 1555436945,\n"
"       \"microseconds\": 179620\n"
"     },\n"
"     \"data\": {\n"
"       \"status\": \"created\",\n"
"       \"id\": \"drive0\"\n"
"     },\n"
"     \"event\": \"JOB_STATUS_CHANGE\"\n"
"   }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"status\": \"concluded\",\n"
"       \"id\": \"drive0\"\n"
"     },\n"
"     \"event\": \"JOB_STATUS_CHANGE\"\n"
"   }\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"status\": \"null\",\n"
"       \"id\": \"drive0\"\n"
"     },\n"
"     \"event\": \"JOB_STATUS_CHANGE\"\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:637
msgid ""
"A full explanation of the job transition semantics and the JOB_STATUS_CHANGE "
"event are beyond the scope of this document and will be omitted in all "
"subsequent examples; above, several more events have been omitted for "
"brevity."
msgstr ""

#: ../../../interop/bitmaps.rst:641
msgid ""
"Subsequent examples will omit all events except BLOCK_JOB_COMPLETED except "
"where necessary to illustrate workflow differences."
msgstr ""

#: ../../../interop/bitmaps.rst:644
msgid ""
"Omitted events and json objects will be represented by ellipses: ``...``"
msgstr ""

#: ../../../interop/bitmaps.rst:648
msgid "Example: Resetting an Incremental Backup Anchor Point"
msgstr ""

#: ../../../interop/bitmaps.rst:650
msgid ""
"If we want to start a new backup chain with an existing bitmap, we can also "
"use a transaction to reset the bitmap while making a new full backup:"
msgstr ""

#: ../../../interop/bitmaps.rst:653
msgid ""
"-> {\n"
"     \"execute\": \"transaction\",\n"
"     \"arguments\": {\n"
"       \"actions\": [\n"
"       {\n"
"         \"type\": \"block-dirty-bitmap-clear\",\n"
"         \"data\": {\n"
"           \"node\": \"drive0\",\n"
"           \"name\": \"bitmap0\"\n"
"         }\n"
"       },\n"
"       {\n"
"         \"type\": \"drive-backup\",\n"
"         \"data\": {\n"
"           \"device\": \"drive0\",\n"
"           \"target\": \"/path/to/drive0.new_full.qcow2\",\n"
"           \"sync\": \"full\",\n"
"           \"format\": \"qcow2\"\n"
"         }\n"
"       }\n"
"     ]\n"
"   }\n"
" }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"..."
msgstr ""

#: ../../../interop/bitmaps.rst:697
msgid ""
"The result of this example is identical to the first, but we clear an "
"existing bitmap instead of adding a new one."
msgstr ""

#: ../../../interop/bitmaps.rst:700
msgid ""
"In both of these examples, \"bitmap0\" is tied conceptually to the creation "
"of new, full backups. This relationship is not saved or remembered by QEMU; "
"it is up to the operator or management layer to remember which bitmaps are "
"associated with which backups."
msgstr ""

#: ../../../interop/bitmaps.rst:706
msgid "Example: First Incremental Backup"
msgstr ""

#: ../../../interop/bitmaps.rst:708
msgid "Create a full backup and sync it to a dirty bitmap using any method:"
msgstr ""

#: ../../../interop/bitmaps.rst:710
msgid "Either of the two live backup method demonstrated above,"
msgstr ""

#: ../../../interop/bitmaps.rst:711
msgid ""
"Using QMP commands with the VM paused as in the `Justification`_ section, or"
msgstr ""

#: ../../../interop/bitmaps.rst:713
msgid ""
"With the VM offline, manually copy the image and start the VM in a paused "
"state, careful to add a new bitmap before the VM begins execution."
msgstr ""

#: ../../../interop/bitmaps.rst:716
msgid "Whichever method is chosen, let's assume that at the end of this step:"
msgstr ""

#: ../../../interop/bitmaps.rst:718
msgid "The full backup is named ``drive0.full.qcow2``."
msgstr ""

#: ../../../interop/bitmaps.rst:719
msgid "The bitmap we created is named ``bitmap0``, attached to ``drive0``."
msgstr ""

#: ../../../interop/bitmaps.rst:721
msgid ""
"Create a destination image for the incremental backup that utilizes the full "
"backup as a backing image."
msgstr ""

#: ../../../interop/bitmaps.rst:724
msgid "Let's assume the new incremental image is named ``drive0.inc0.qcow2``:"
msgstr ""

#: ../../../interop/bitmaps.rst:726 ../../../interop/bitmaps.rst:1117
msgid ""
"$ qemu-img create -f qcow2 drive0.inc0.qcow2 \\\n"
"  -b drive0.full.qcow2 -F qcow2"
msgstr ""

#: ../../../interop/bitmaps.rst:731
msgid "Issue an incremental backup command:"
msgstr ""

#: ../../../interop/bitmaps.rst:733
msgid ""
"-> {\n"
"     \"execute\": \"drive-backup\",\n"
"     \"arguments\": {\n"
"       \"device\": \"drive0\",\n"
"       \"bitmap\": \"bitmap0\",\n"
"       \"target\": \"drive0.inc0.qcow2\",\n"
"       \"format\": \"qcow2\",\n"
"       \"sync\": \"incremental\",\n"
"       \"mode\": \"existing\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"..."
msgstr ""

#: ../../../interop/bitmaps.rst:765
msgid ""
"This copies any blocks modified since the full backup was created into the "
"``drive0.inc0.qcow2`` file. During the operation, ``bitmap0`` is marked "
"``+busy``. If the operation is successful, ``bitmap0`` will be cleared to "
"reflect the \"incremental\" backup regimen, which only copies out new "
"changes from each incremental backup."
msgstr ""

#: ../../../interop/bitmaps.rst:771
msgid ""
"Any new writes that occur after the backup operation starts do not get "
"copied to the destination. The backup's \"point in time\" is when the backup "
"starts, not when it ends. These writes are recorded in a special bitmap that "
"gets re-added to bitmap0 when the backup ends so that the next incremental "
"backup can copy them out."
msgstr ""

#: ../../../interop/bitmaps.rst:778
msgid "Example: Second Incremental Backup"
msgstr ""

#: ../../../interop/bitmaps.rst:780
msgid ""
"Create a new destination image for the incremental backup that points to the "
"previous one, e.g.: ``drive0.inc1.qcow2``"
msgstr ""

#: ../../../interop/bitmaps.rst:783
msgid ""
"$ qemu-img create -f qcow2 drive0.inc1.qcow2 \\\n"
"  -b drive0.inc0.qcow2 -F qcow2"
msgstr ""

#: ../../../interop/bitmaps.rst:788
msgid ""
"Issue a new incremental backup command. The only difference here is that we "
"have changed the target image below."
msgstr ""

#: ../../../interop/bitmaps.rst:791
msgid ""
"-> {\n"
"     \"execute\": \"drive-backup\",\n"
"     \"arguments\": {\n"
"       \"device\": \"drive0\",\n"
"       \"bitmap\": \"bitmap0\",\n"
"       \"target\": \"drive0.inc1.qcow2\",\n"
"       \"format\": \"qcow2\",\n"
"       \"sync\": \"incremental\",\n"
"       \"mode\": \"existing\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"..."
msgstr ""

#: ../../../interop/bitmaps.rst:823
msgid ""
"Because the first incremental backup from the previous example completed "
"successfully, ``bitmap0`` was synchronized with ``drive0.inc0.qcow2``. Here, "
"we use ``bitmap0`` again to create a new incremental backup that targets the "
"previous one, creating a chain of three images:"
msgstr ""

#: ../../../interop/bitmaps.rst:828
msgid "Diagram"
msgstr ""

#: ../../../interop/bitmaps.rst:830
msgid ""
"+-------------------+   +-------------------+   +-------------------+\n"
"| drive0.full.qcow2 |<--| drive0.inc0.qcow2 |<--| drive0.inc1.qcow2 |\n"
"+-------------------+   +-------------------+   +-------------------+"
msgstr ""

#: ../../../interop/bitmaps.rst:836
msgid ""
"Each new incremental backup re-synchronizes the bitmap to the latest backup "
"authored, allowing a user to continue to \"consume\" it to create new "
"backups on top of an existing chain."
msgstr ""

#: ../../../interop/bitmaps.rst:840
msgid ""
"In the above diagram, neither drive0.inc1.qcow2 nor drive0.inc0.qcow2 are "
"complete images by themselves, but rely on their backing chain to "
"reconstruct a full image. The dependency terminates with each full backup."
msgstr ""

#: ../../../interop/bitmaps.rst:844
msgid ""
"Each backup in this chain remains independent, and is unchanged by new "
"entries made later in the chain. For instance, drive0.inc0.qcow2 remains a "
"perfectly valid backup of the disk as it was when that backup was issued."
msgstr ""

#: ../../../interop/bitmaps.rst:849
msgid "Example: Incremental Push Backups without Backing Files"
msgstr ""

#: ../../../interop/bitmaps.rst:851
msgid ""
"Backup images are best kept off-site, so we often will not have the "
"preceding backups in a chain available to link against. This is not a "
"problem at backup time; we simply do not set the backing image when creating "
"the destination image:"
msgstr ""

#: ../../../interop/bitmaps.rst:856
msgid ""
"Create a new destination image with no backing file set. We will need to "
"specify the size of the base image, because the backing file isn't available "
"for QEMU to use to determine it."
msgstr ""

#: ../../../interop/bitmaps.rst:860
msgid "$ qemu-img create -f qcow2 drive0.inc2.qcow2 64G"
msgstr ""

#: ../../../interop/bitmaps.rst:864
msgid ""
"Alternatively, you can omit ``mode: \"existing\"`` from the push backup "
"commands to have QEMU create an image without a backing file for you, but "
"you lose control over format options like compatibility and preallocation "
"presets."
msgstr ""

#: ../../../interop/bitmaps.rst:869
msgid ""
"Issue a new incremental backup command. Apart from the new destination "
"image, there is no difference from the last two examples."
msgstr ""

#: ../../../interop/bitmaps.rst:872
msgid ""
"-> {\n"
"     \"execute\": \"drive-backup\",\n"
"     \"arguments\": {\n"
"       \"device\": \"drive0\",\n"
"       \"bitmap\": \"bitmap0\",\n"
"       \"target\": \"drive0.inc2.qcow2\",\n"
"       \"format\": \"qcow2\",\n"
"       \"sync\": \"incremental\",\n"
"       \"mode\": \"existing\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"..."
msgstr ""

#: ../../../interop/bitmaps.rst:904
msgid ""
"The only difference from the perspective of the user is that you will need "
"to set the backing image when attempting to restore the backup:"
msgstr ""

#: ../../../interop/bitmaps.rst:907
msgid ""
"$ qemu-img rebase drive0.inc2.qcow2 \\\n"
"  -u -b drive0.inc1.qcow2"
msgstr ""

#: ../../../interop/bitmaps.rst:912
msgid ""
"This uses the \"unsafe\" rebase mode to simply set the backing file to a "
"file that isn't present."
msgstr ""

#: ../../../interop/bitmaps.rst:915
msgid ""
"It is also possible to use ``--image-opts`` to specify the entire backing "
"chain by hand as an ephemeral property at runtime, but that is beyond the "
"scope of this document."
msgstr ""

#: ../../../interop/bitmaps.rst:920
msgid "Example: Multi-drive Incremental Backup"
msgstr ""

#: ../../../interop/bitmaps.rst:922
msgid ""
"Assume we have a VM with two drives, \"drive0\" and \"drive1\" and we wish "
"to back both of them up such that the two backups represent the same crash-"
"consistent point in time."
msgstr ""

#: ../../../interop/bitmaps.rst:926
msgid "For each drive, create an empty image:"
msgstr ""

#: ../../../interop/bitmaps.rst:928
msgid ""
"$ qemu-img create -f qcow2 drive0.full.qcow2 64G\n"
"$ qemu-img create -f qcow2 drive1.full.qcow2 64G"
msgstr ""

#: ../../../interop/bitmaps.rst:933
msgid ""
"Create a full (anchor) backup for each drive, with accompanying bitmaps:"
msgstr ""

#: ../../../interop/bitmaps.rst:935
msgid ""
"-> {\n"
"     \"execute\": \"transaction\",\n"
"     \"arguments\": {\n"
"       \"actions\": [\n"
"         {\n"
"           \"type\": \"block-dirty-bitmap-add\",\n"
"           \"data\": {\n"
"             \"node\": \"drive0\",\n"
"             \"name\": \"bitmap0\"\n"
"           }\n"
"         },\n"
"         {\n"
"           \"type\": \"block-dirty-bitmap-add\",\n"
"           \"data\": {\n"
"             \"node\": \"drive1\",\n"
"             \"name\": \"bitmap0\"\n"
"           }\n"
"         },\n"
"         {\n"
"           \"type\": \"drive-backup\",\n"
"           \"data\": {\n"
"             \"device\": \"drive0\",\n"
"             \"target\": \"/path/to/drive0.full.qcow2\",\n"
"             \"sync\": \"full\",\n"
"             \"format\": \"qcow2\"\n"
"           }\n"
"         },\n"
"         {\n"
"           \"type\": \"drive-backup\",\n"
"           \"data\": {\n"
"             \"device\": \"drive1\",\n"
"             \"target\": \"/path/to/drive1.full.qcow2\",\n"
"             \"sync\": \"full\",\n"
"             \"format\": \"qcow2\"\n"
"           }\n"
"         }\n"
"       ]\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive1\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"..."
msgstr ""

#: ../../../interop/bitmaps.rst:1009
msgid ""
"Later, create new destination images for each of the incremental backups "
"that point to their respective full backups:"
msgstr ""

#: ../../../interop/bitmaps.rst:1012
msgid ""
"$ qemu-img create -f qcow2 drive0.inc0.qcow2 \\\n"
"  -b drive0.full.qcow2 -F qcow2\n"
"$ qemu-img create -f qcow2 drive1.inc0.qcow2 \\\n"
"  -b drive1.full.qcow2 -F qcow2"
msgstr ""

#: ../../../interop/bitmaps.rst:1019
msgid "Issue a multi-drive incremental push backup transaction:"
msgstr ""

#: ../../../interop/bitmaps.rst:1021
msgid ""
"-> {\n"
"     \"execute\": \"transaction\",\n"
"     \"arguments\": {\n"
"       \"actions\": [\n"
"         {\n"
"           \"type\": \"drive-backup\",\n"
"           \"data\": {\n"
"             \"device\": \"drive0\",\n"
"             \"bitmap\": \"bitmap0\",\n"
"             \"format\": \"qcow2\",\n"
"             \"mode\": \"existing\",\n"
"             \"sync\": \"incremental\",\n"
"             \"target\": \"drive0.inc0.qcow2\"\n"
"           }\n"
"         },\n"
"         {\n"
"           \"type\": \"drive-backup\",\n"
"           \"data\": {\n"
"             \"device\": \"drive1\",\n"
"             \"bitmap\": \"bitmap0\",\n"
"             \"format\": \"qcow2\",\n"
"             \"mode\": \"existing\",\n"
"             \"sync\": \"incremental\",\n"
"             \"target\": \"drive1.inc0.qcow2\"\n"
"           }\n"
"         },\n"
"       ]\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive1\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 68719476736,\n"
"       \"offset\": 68719476736\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }\n"
"\n"
"..."
msgstr ""

#: ../../../interop/bitmaps.rst:1086
msgid "Push Backup Errors & Recovery"
msgstr ""

#: ../../../interop/bitmaps.rst:1088
msgid ""
"In the event of an error that occurs after a push backup job is successfully "
"launched, either by an individual QMP command or a QMP transaction, the user "
"will receive a ``BLOCK_JOB_COMPLETE`` event with a failure message, "
"accompanied by a ``BLOCK_JOB_ERROR`` event."
msgstr ""

#: ../../../interop/bitmaps.rst:1093
msgid ""
"In the case of a job being cancelled, the user will receive a "
"``BLOCK_JOB_CANCELLED`` event instead of a pair of COMPLETE and ERROR events."
msgstr ""

#: ../../../interop/bitmaps.rst:1097
msgid ""
"In either failure case, the bitmap used for the failed operation is not "
"cleared. It will contain all of the dirty bits it did at the start of the "
"operation, plus any new bits that got marked during the operation."
msgstr ""

#: ../../../interop/bitmaps.rst:1101
msgid ""
"Effectively, the \"point in time\" that a bitmap is recording differences "
"against is kept at the issuance of the last successful incremental backup, "
"instead of being moved forward to the start of this now-failed backup."
msgstr ""

#: ../../../interop/bitmaps.rst:1105
msgid ""
"Once the underlying problem is addressed (e.g. more storage space is "
"allocated on the destination), the incremental backup command can be retried "
"with the same bitmap."
msgstr ""

#: ../../../interop/bitmaps.rst:1110
msgid "Example: Individual Failures"
msgstr ""

#: ../../../interop/bitmaps.rst:1112
msgid ""
"Incremental Push Backup jobs that fail individually behave simply as "
"described above. This example demonstrates the single-job failure case:"
msgstr ""

#: ../../../interop/bitmaps.rst:1115
msgid "Create a target image:"
msgstr ""

#: ../../../interop/bitmaps.rst:1122
msgid "Attempt to create an incremental backup via QMP:"
msgstr ""

#: ../../../interop/bitmaps.rst:1124 ../../../interop/bitmaps.rst:1178
msgid ""
"-> {\n"
"     \"execute\": \"drive-backup\",\n"
"     \"arguments\": {\n"
"       \"device\": \"drive0\",\n"
"       \"bitmap\": \"bitmap0\",\n"
"       \"target\": \"drive0.inc0.qcow2\",\n"
"       \"format\": \"qcow2\",\n"
"       \"sync\": \"incremental\",\n"
"       \"mode\": \"existing\"\n"
"     }\n"
"   }\n"
"\n"
"<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:1140
msgid "Receive a pair of events indicating failure:"
msgstr ""

#: ../../../interop/bitmaps.rst:1142
msgid ""
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"action\": \"report\",\n"
"       \"operation\": \"write\"\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_ERROR\"\n"
"   }\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"speed\": 0,\n"
"       \"offset\": 0,\n"
"       \"len\": 67108864,\n"
"       \"error\": \"No space left on device\",\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\"\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1167
msgid "Delete the failed image, and re-create it."
msgstr ""

#: ../../../interop/bitmaps.rst:1169
msgid ""
"$ rm drive0.inc0.qcow2\n"
"$ qemu-img create -f qcow2 drive0.inc0.qcow2 \\\n"
"  -b drive0.full.qcow2 -F qcow2"
msgstr ""

#: ../../../interop/bitmaps.rst:1175
msgid ""
"Retry the command after fixing the underlying problem, such as freeing up "
"space on the backup volume:"
msgstr ""

#: ../../../interop/bitmaps.rst:1194
msgid "Receive confirmation that the job completed successfully:"
msgstr ""

#: ../../../interop/bitmaps.rst:1196 ../../../interop/bitmaps.rst:1276
msgid ""
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 67108864,\n"
"       \"offset\": 67108864\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1211
msgid "Example: Partial Transactional Failures"
msgstr ""

#: ../../../interop/bitmaps.rst:1213
msgid ""
"QMP commands like `drive-backup <qemu-qmp-ref.html#index-drive_002dbackup>`_ "
"conceptually only start a job, and so transactions containing these commands "
"may succeed even if the job it created later fails. This might have "
"surprising interactions with notions of how a \"transaction\" ought to "
"behave."
msgstr ""

#: ../../../interop/bitmaps.rst:1218
msgid ""
"This distinction means that on occasion, a transaction containing such job "
"launching commands may appear to succeed and return success, but later "
"individual jobs associated with the transaction may fail. It is possible "
"that a management application may have to deal with a partial backup failure "
"after a \"successful\" transaction."
msgstr ""

#: ../../../interop/bitmaps.rst:1224
msgid ""
"If multiple backup jobs are specified in a single transaction, if one of "
"those jobs fails, it will not interact with the other backup jobs in any way "
"by default. The job(s) that succeeded will clear the dirty bitmap associated "
"with the operation, but the job(s) that failed will not. It is therefore not "
"safe to delete any incremental backups that were created successfully in "
"this scenario, even though others failed."
msgstr ""

#: ../../../interop/bitmaps.rst:1231
msgid ""
"This example illustrates a transaction with two backup jobs, where one fails "
"and one succeeds:"
msgstr ""

#: ../../../interop/bitmaps.rst:1234
msgid "Issue the transaction to start a backup of both drives."
msgstr ""

#: ../../../interop/bitmaps.rst:1236
msgid ""
"-> {\n"
"     \"execute\": \"transaction\",\n"
"     \"arguments\": {\n"
"       \"actions\": [\n"
"       {\n"
"         \"type\": \"drive-backup\",\n"
"         \"data\": {\n"
"           \"device\": \"drive0\",\n"
"           \"bitmap\": \"bitmap0\",\n"
"           \"format\": \"qcow2\",\n"
"           \"mode\": \"existing\",\n"
"           \"sync\": \"incremental\",\n"
"           \"target\": \"drive0.inc0.qcow2\"\n"
"         }\n"
"       },\n"
"       {\n"
"         \"type\": \"drive-backup\",\n"
"         \"data\": {\n"
"           \"device\": \"drive1\",\n"
"           \"bitmap\": \"bitmap0\",\n"
"           \"format\": \"qcow2\",\n"
"           \"mode\": \"existing\",\n"
"           \"sync\": \"incremental\",\n"
"           \"target\": \"drive1.inc0.qcow2\"\n"
"         }\n"
"       }]\n"
"     }\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1267 ../../../interop/bitmaps.rst:1402
msgid ""
"Receive notice that the Transaction was accepted, and jobs were launched:"
msgstr ""

#: ../../../interop/bitmaps.rst:1270 ../../../interop/bitmaps.rst:1404
msgid "<- { \"return\": {} }"
msgstr ""

#: ../../../interop/bitmaps.rst:1274
msgid "Receive notice that the first job has completed:"
msgstr ""

#: ../../../interop/bitmaps.rst:1290
msgid "Receive notice that the second job has failed:"
msgstr ""

#: ../../../interop/bitmaps.rst:1292
msgid ""
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive1\",\n"
"       \"action\": \"report\",\n"
"       \"operation\": \"read\"\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_ERROR\"\n"
"   }\n"
"\n"
"...\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"speed\": 0,\n"
"       \"offset\": 0,\n"
"       \"len\": 67108864,\n"
"       \"error\": \"Input/output error\",\n"
"       \"device\": \"drive1\",\n"
"       \"type\": \"backup\"\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1319
msgid ""
"At the conclusion of the above example, ``drive0.inc0.qcow2`` is valid and "
"must be kept, but ``drive1.inc0.qcow2`` is incomplete and should be deleted. "
"If a VM-wide incremental backup of all drives at a point-in-time is to be "
"made, new backups for both drives will need to be made, taking into account "
"that a new incremental backup for drive0 needs to be based on top of "
"``drive0.inc0.qcow2``."
msgstr ""

#: ../../../interop/bitmaps.rst:1326
msgid ""
"For this example, an incremental backup for ``drive0`` was created, but not "
"for ``drive1``. The last VM-wide crash-consistent backup that is available "
"in this case is the full backup:"
msgstr ""

#: ../../../interop/bitmaps.rst:1330
msgid ""
"[drive0.full.qcow2] <-- [drive0.inc0.qcow2]\n"
"[drive1.full.qcow2]"
msgstr ""

#: ../../../interop/bitmaps.rst:1335
msgid ""
"To repair this, issue a new incremental backup across both drives. The "
"result will be backup chains that resemble the following:"
msgstr ""

#: ../../../interop/bitmaps.rst:1338
msgid ""
"[drive0.full.qcow2] <-- [drive0.inc0.qcow2] <-- [drive0.inc1.qcow2]\n"
"[drive1.full.qcow2] <-------------------------- [drive1.inc1.qcow2]"
msgstr ""

#: ../../../interop/bitmaps.rst:1344
msgid "Example: Grouped Completion Mode"
msgstr ""

#: ../../../interop/bitmaps.rst:1346
msgid ""
"While jobs launched by transactions normally complete or fail individually, "
"it's possible to instruct them to complete or fail together as a group. QMP "
"transactions take an optional properties structure that can affect the "
"behavior of the transaction."
msgstr ""

#: ../../../interop/bitmaps.rst:1351
msgid ""
"The ``completion-mode`` transaction property can be either ``individual`` "
"which is the default legacy behavior described above, or ``grouped``, "
"detailed below."
msgstr ""

#: ../../../interop/bitmaps.rst:1355
msgid ""
"In ``grouped`` completion mode, no jobs will report success until all jobs "
"are ready to report success. If any job fails, all other jobs will be "
"cancelled."
msgstr ""

#: ../../../interop/bitmaps.rst:1358
msgid ""
"Regardless of if a participating incremental backup job failed or was "
"cancelled, their associated bitmaps will all be held at their existing "
"points-in-time, as in individual failure cases."
msgstr ""

#: ../../../interop/bitmaps.rst:1362
msgid ""
"Here's the same multi-drive backup scenario from `Example: Partial "
"Transactional Failures`_, but with the ``grouped`` completion-mode property "
"applied:"
msgstr ""

#: ../../../interop/bitmaps.rst:1366
msgid "Issue the multi-drive incremental backup transaction:"
msgstr ""

#: ../../../interop/bitmaps.rst:1368
msgid ""
"-> {\n"
"     \"execute\": \"transaction\",\n"
"     \"arguments\": {\n"
"       \"properties\": {\n"
"         \"completion-mode\": \"grouped\"\n"
"       },\n"
"       \"actions\": [\n"
"       {\n"
"         \"type\": \"drive-backup\",\n"
"         \"data\": {\n"
"           \"device\": \"drive0\",\n"
"           \"bitmap\": \"bitmap0\",\n"
"           \"format\": \"qcow2\",\n"
"           \"mode\": \"existing\",\n"
"           \"sync\": \"incremental\",\n"
"           \"target\": \"drive0.inc0.qcow2\"\n"
"         }\n"
"       },\n"
"       {\n"
"         \"type\": \"drive-backup\",\n"
"         \"data\": {\n"
"           \"device\": \"drive1\",\n"
"           \"bitmap\": \"bitmap0\",\n"
"           \"format\": \"qcow2\",\n"
"           \"mode\": \"existing\",\n"
"           \"sync\": \"incremental\",\n"
"           \"target\": \"drive1.inc0.qcow2\"\n"
"         }\n"
"       }]\n"
"     }\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1408
msgid "Receive notification that the backup job for ``drive1`` has failed:"
msgstr ""

#: ../../../interop/bitmaps.rst:1410
msgid ""
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive1\",\n"
"       \"action\": \"report\",\n"
"       \"operation\": \"read\"\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_ERROR\"\n"
"   }\n"
"\n"
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"speed\": 0,\n"
"       \"offset\": 0,\n"
"       \"len\": 67108864,\n"
"       \"error\": \"Input/output error\",\n"
"       \"device\": \"drive1\",\n"
"       \"type\": \"backup\"\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_COMPLETED\"\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1435
msgid "Receive notification that the job for ``drive0`` has been cancelled:"
msgstr ""

#: ../../../interop/bitmaps.rst:1437
msgid ""
"<- {\n"
"     \"timestamp\": {...},\n"
"     \"data\": {\n"
"       \"device\": \"drive0\",\n"
"       \"type\": \"backup\",\n"
"       \"speed\": 0,\n"
"       \"len\": 67108864,\n"
"       \"offset\": 16777216\n"
"     },\n"
"     \"event\": \"BLOCK_JOB_CANCELLED\"\n"
"   }"
msgstr ""

#: ../../../interop/bitmaps.rst:1451
msgid ""
"At the conclusion of *this* example, both jobs have been aborted due to a "
"failure. Both destination images should be deleted and are no longer of use."
msgstr ""

#: ../../../interop/bitmaps.rst:1454
msgid "The transaction as a whole can simply be re-issued at a later time."
msgstr ""

#: ../../../interop/bitmaps.rst:1456
msgid ""
"<!--\n"
"The FreeBSD Documentation License\n"
"\n"
"Redistribution and use in source (ReST) and 'compiled' forms (SGML, HTML,\n"
"PDF, PostScript, RTF and so forth) with or without modification, are\n"
"permitted provided that the following conditions are met:\n"
"\n"
"Redistributions of source code (ReST) must retain the above copyright "
"notice,\n"
"this list of conditions and the following disclaimer of this file "
"unmodified.\n"
"\n"
"Redistributions in compiled form (transformed to other DTDs, converted to\n"
"PDF, PostScript, RTF and other formats) must reproduce the above copyright\n"
"notice, this list of conditions and the following disclaimer in the\n"
"documentation and/or other materials provided with the distribution.\n"
"\n"
"THIS DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "
"\"AS\n"
"IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, "
"THE\n"
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n"
"ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n"
"LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n"
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n"
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n"
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n"
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n"
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF\n"
"THE POSSIBILITY OF SUCH DAMAGE.\n"
"-->"
msgstr ""
