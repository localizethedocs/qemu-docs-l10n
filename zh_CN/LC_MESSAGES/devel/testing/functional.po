# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-03 08:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/testing/functional.rst:4
msgid "Functional testing with Python"
msgstr ""

#: ../../../devel/testing/functional.rst:6
msgid ""
"The ``tests/functional`` directory hosts functional tests written in Python. "
"They are usually higher level tests, and may interact with external "
"resources and with various guest operating systems."
msgstr ""

#: ../../../devel/testing/functional.rst:10
msgid ""
"The tests should be written in the style of the Python `unittest`_ "
"framework, using stdio for the TAP protocol. The folder ``tests/functional/"
"qemu_test`` provides classes (e.g. the ``QemuBaseTest``, ``QemuUserTest`` "
"and the ``QemuSystemTest`` classes) and utility functions that help to get "
"your test into the right shape, e.g. by replacing the 'stdout' python object "
"to redirect the normal output of your test to stderr instead."
msgstr ""

#: ../../../devel/testing/functional.rst:17
msgid ""
"Note that if you don't use one of the QemuBaseTest based classes for your "
"test, or if you spawn subprocesses from your test, you have to make sure "
"that there is no TAP-incompatible output written to stdio, e.g. either by "
"prefixing every line with a \"# \" to mark the output as a TAP comment, or e."
"g. by capturing the stdout output of subprocesses (redirecting it to stderr "
"is OK)."
msgstr ""

#: ../../../devel/testing/functional.rst:24
msgid "Tests based on ``qemu_test.QemuSystemTest`` can easily:"
msgstr ""

#: ../../../devel/testing/functional.rst:26
msgid ""
"Customize the command line arguments given to the convenience ``self.vm`` "
"attribute (a QEMUMachine instance)"
msgstr ""

#: ../../../devel/testing/functional.rst:29
msgid ""
"Interact with the QEMU monitor, send QMP commands and check their results"
msgstr ""

#: ../../../devel/testing/functional.rst:32
msgid ""
"Interact with the guest OS, using the convenience console device (which may "
"be useful to assert the effectiveness and correctness of command line "
"arguments or QMP commands)"
msgstr ""

#: ../../../devel/testing/functional.rst:36
msgid ""
"Download (and cache) remote data files, such as firmware and kernel images"
msgstr ""

#: ../../../devel/testing/functional.rst:40
msgid "Running tests"
msgstr ""

#: ../../../devel/testing/functional.rst:42
msgid "You can run the functional tests simply by executing:"
msgstr ""

#: ../../../devel/testing/functional.rst:44
msgid "make check-functional"
msgstr ""

#: ../../../devel/testing/functional.rst:48
msgid ""
"It is also possible to run tests for a certain target only, for example the "
"following line will only run the tests for the x86_64 target:"
msgstr ""

#: ../../../devel/testing/functional.rst:51
msgid "make check-functional-x86_64"
msgstr ""

#: ../../../devel/testing/functional.rst:55
msgid ""
"To run a single test file without the meson test runner, you can also "
"execute the file directly by specifying two environment variables first, the "
"PYTHONPATH that has to include the python folder and the tests/functional "
"folder of the source tree, and QEMU_TEST_QEMU_BINARY that has to point to "
"the QEMU binary that should be used for the test. The current working "
"directory should be your build folder. For example::"
msgstr ""

#: ../../../devel/testing/functional.rst:62
msgid ""
"$ export PYTHONPATH=../python:../tests/functional\n"
"$ export QEMU_TEST_QEMU_BINARY=$PWD/qemu-system-x86_64\n"
"$ pyvenv/bin/python3 ../tests/functional/test_file.py"
msgstr ""

#: ../../../devel/testing/functional.rst:66
msgid ""
"The test framework will automatically purge any scratch files created during "
"the tests. If needing to debug a failed test, it is possible to keep these "
"files around on disk by setting ``QEMU_TEST_KEEP_SCRATCH=1`` as an env "
"variable.  Any preserved files will be deleted the next time the test is run "
"without this variable set."
msgstr ""

#: ../../../devel/testing/functional.rst:73
msgid "Logging"
msgstr ""

#: ../../../devel/testing/functional.rst:75
msgid ""
"The framework collects log files for each test in the build directory in the "
"following subfolder::"
msgstr ""

#: ../../../devel/testing/functional.rst:78
msgid "<builddir>/tests/functional/<arch>/<fileid>.<classid>.<testname>/"
msgstr ""

#: ../../../devel/testing/functional.rst:80
msgid "There are usually three log files:"
msgstr ""

#: ../../../devel/testing/functional.rst:82
msgid ""
"``base.log`` contains the generic logging information that is written by the "
"calls to the logging functions in the test code (e.g. by calling the ``self."
"log.info()`` or ``self.log.debug()`` functions)."
msgstr ""

#: ../../../devel/testing/functional.rst:85
msgid "``console.log`` contains the output of the serial console of the guest."
msgstr ""

#: ../../../devel/testing/functional.rst:86
msgid ""
"``default.log`` contains the output of QEMU. This file could be named "
"differently if the test chooses to use a different identifier for the guest "
"VM (e.g. when the test spins up multiple VMs)."
msgstr ""

#: ../../../devel/testing/functional.rst:91
msgid "Introduction to writing tests"
msgstr ""

#: ../../../devel/testing/functional.rst:93
msgid ""
"The ``tests/functional/qemu_test`` directory provides the ``qemu_test`` "
"Python module, containing the ``qemu_test.QemuSystemTest`` class. Here is a "
"simple usage example:"
msgstr ""

#: ../../../devel/testing/functional.rst:97
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"from qemu_test import QemuSystemTest\n"
"\n"
"class Version(QemuSystemTest):\n"
"\n"
"    def test_qmp_human_info_version(self):\n"
"        self.vm.launch()\n"
"        res = self.vm.cmd('human-monitor-command',\n"
"                          command_line='info version')\n"
"        self.assertRegex(res, r'^(\\d+\\.\\d+\\.\\d)')\n"
"\n"
"if __name__ == '__main__':\n"
"    QemuSystemTest.main()"
msgstr ""

#: ../../../devel/testing/functional.rst:114
msgid ""
"By providing the \"hash bang\" line at the beginning of the script, marking "
"the file as executable and by calling into QemuSystemTest.main(), the test "
"can also be run stand-alone, without a test runner. OTOH when run via a test "
"runner, the QemuSystemTest.main() function takes care of running the test "
"functions in the right fassion (e.g. with TAP output that is required by the "
"meson test runner)."
msgstr ""

#: ../../../devel/testing/functional.rst:122
msgid "The ``qemu_test.QemuSystemTest`` base test class"
msgstr ""

#: ../../../devel/testing/functional.rst:124
msgid ""
"The ``qemu_test.QemuSystemTest`` class has a number of characteristics that "
"are worth being mentioned."
msgstr ""

#: ../../../devel/testing/functional.rst:127
msgid ""
"First of all, it attempts to give each test a ready to use QEMUMachine "
"instance, available at ``self.vm``.  Because many tests will tweak the QEMU "
"command line, launching the QEMUMachine (by using ``self.vm.launch()``) is "
"left to the test writer."
msgstr ""

#: ../../../devel/testing/functional.rst:132
msgid ""
"The base test class has also support for tests with more than one "
"QEMUMachine. The way to get machines is through the ``self.get_vm()`` method "
"which will return a QEMUMachine instance. The ``self.get_vm()`` method "
"accepts arguments that will be passed to the QEMUMachine creation and also "
"an optional ``name`` attribute so you can identify a specific machine and "
"get it more than once through the tests methods. A simple and hypothetical "
"example follows:"
msgstr ""

#: ../../../devel/testing/functional.rst:140
msgid ""
"from qemu_test import QemuSystemTest\n"
"\n"
"class MultipleMachines(QemuSystemTest):\n"
"    def test_multiple_machines(self):\n"
"        first_machine = self.get_vm()\n"
"        second_machine = self.get_vm()\n"
"        self.get_vm(name='third_machine').launch()\n"
"\n"
"        first_machine.launch()\n"
"        second_machine.launch()\n"
"\n"
"        first_res = first_machine.cmd(\n"
"            'human-monitor-command',\n"
"            command_line='info version')\n"
"\n"
"        second_res = second_machine.cmd(\n"
"            'human-monitor-command',\n"
"            command_line='info version')\n"
"\n"
"        third_res = self.get_vm(name='third_machine').cmd(\n"
"            'human-monitor-command',\n"
"            command_line='info version')\n"
"\n"
"        self.assertEqual(first_res, second_res, third_res)"
msgstr ""

#: ../../../devel/testing/functional.rst:167
msgid ""
"At test \"tear down\", ``qemu_test.QemuSystemTest`` handles all the "
"QEMUMachines shutdown."
msgstr ""

#: ../../../devel/testing/functional.rst:171
msgid "QEMUMachine"
msgstr ""

#: ../../../devel/testing/functional.rst:173
msgid ""
"The QEMUMachine API is already widely used in the Python iotests, device-"
"crash-test and other Python scripts.  It's a wrapper around the execution of "
"a QEMU binary, giving its users:"
msgstr ""

#: ../../../devel/testing/functional.rst:177
msgid ""
"the ability to set command line arguments to be given to the QEMU binary"
msgstr ""

#: ../../../devel/testing/functional.rst:180
msgid ""
"a ready to use QMP connection and interface, which can be used to send "
"commands and inspect its results, as well as asynchronous events"
msgstr ""

#: ../../../devel/testing/functional.rst:184
msgid ""
"convenience methods to set commonly used command line arguments in a more "
"succinct and intuitive way"
msgstr ""

#: ../../../devel/testing/functional.rst:188
msgid "QEMU binary selection"
msgstr ""

#: ../../../devel/testing/functional.rst:190
msgid ""
"The QEMU binary used for the ``self.vm`` QEMUMachine instance will primarily "
"depend on the value of the ``qemu_bin`` instance attribute. If it is not "
"explicitly set by the test code, its default value will be the result the "
"QEMU_TEST_QEMU_BINARY environment variable."
msgstr ""

#: ../../../devel/testing/functional.rst:196
msgid "Debugging hung QEMU"
msgstr ""

#: ../../../devel/testing/functional.rst:198
msgid ""
"When test cases go wrong it may be helpful to debug a stalled QEMU process. "
"While the QEMUMachine class owns the primary QMP monitor socket, it is "
"possible to request a second QMP monitor be created by setting the "
"``QEMU_TEST_QMP_BACKDOOR`` env variable to refer to a UNIX socket name. The "
"``qmp-shell`` command can then be attached to the stalled QEMU to examine "
"its live state."
msgstr ""

#: ../../../devel/testing/functional.rst:206
msgid "Attribute reference"
msgstr ""

#: ../../../devel/testing/functional.rst:209
msgid "QemuBaseTest"
msgstr ""

#: ../../../devel/testing/functional.rst:211
msgid ""
"The following attributes are available on any ``qemu_test.QemuBaseTest`` "
"instance."
msgstr ""

#: ../../../devel/testing/functional.rst:215
msgid "arch"
msgstr ""

#: ../../../devel/testing/functional.rst:217
msgid "The target architecture of the QEMU binary."
msgstr ""

#: ../../../devel/testing/functional.rst:219
msgid ""
"Tests are also free to use this attribute value, for their own needs. A test "
"may, for instance, use this value when selecting the architecture of a "
"kernel or disk image to boot a VM with."
msgstr ""

#: ../../../devel/testing/functional.rst:224
msgid "qemu_bin"
msgstr ""

#: ../../../devel/testing/functional.rst:226
msgid ""
"The preserved value of the ``QEMU_TEST_QEMU_BINARY`` environment variable."
msgstr ""

#: ../../../devel/testing/functional.rst:230
msgid "QemuUserTest"
msgstr ""

#: ../../../devel/testing/functional.rst:232
msgid ""
"The QemuUserTest class can be used for running an executable via the "
"usermode emulation binaries."
msgstr ""

#: ../../../devel/testing/functional.rst:236
msgid "QemuSystemTest"
msgstr ""

#: ../../../devel/testing/functional.rst:238
msgid ""
"The QemuSystemTest class can be used for running tests via one of the qemu-"
"system-* binaries."
msgstr ""

#: ../../../devel/testing/functional.rst:242
msgid "vm"
msgstr ""

#: ../../../devel/testing/functional.rst:244
msgid ""
"A QEMUMachine instance, initially configured according to the given "
"``qemu_bin`` parameter."
msgstr ""

#: ../../../devel/testing/functional.rst:248
msgid "cpu"
msgstr ""

#: ../../../devel/testing/functional.rst:250
msgid ""
"The cpu model that will be set to all QEMUMachine instances created by the "
"test."
msgstr ""

#: ../../../devel/testing/functional.rst:254
msgid "machine"
msgstr ""

#: ../../../devel/testing/functional.rst:256
msgid ""
"The machine type that will be set to all QEMUMachine instances created by "
"the test. By using the set_machine() function of the QemuSystemTest class to "
"set this attribute, you can automatically check whether the machine is "
"available to skip the test in case it is not built into the QEMU binary."
msgstr ""

#: ../../../devel/testing/functional.rst:263
msgid "Asset handling"
msgstr ""

#: ../../../devel/testing/functional.rst:265
msgid ""
"Many functional tests download assets (e.g. Linux kernels, initrds, firmware "
"images, etc.) from the internet to be able to run tests with them. This "
"imposes additional challenges to the test framework."
msgstr ""

#: ../../../devel/testing/functional.rst:269
msgid ""
"First there is the problem that some people might not have an unconstrained "
"internet connection, so such tests should not be run by default when running "
"``make check``. To accomplish this situation, the tests that download files "
"should only be added to the \"thorough\" speed mode in the meson.build file, "
"while the \"quick\" speed mode is fine for functional tests that can be run "
"without downloading files. ``make check`` then only runs the quick "
"functional tests along with the other quick tests from the other test "
"suites. If you choose to run only ``make check-functional``, the "
"\"thorough\" tests will be executed, too. And to run all functional tests "
"along with the others, you can use something like::"
msgstr ""

#: ../../../devel/testing/functional.rst:281
msgid "make -j$(nproc) check SPEED=thorough"
msgstr ""

#: ../../../devel/testing/functional.rst:283
msgid ""
"The second problem with downloading files from the internet are time "
"constraints. The time for downloading files should not be taken into account "
"when the test is running and the timeout of the test is ticking (since "
"downloading can be very slow, depending on the network bandwidth). This "
"problem is solved by downloading the assets ahead of time, before the tests "
"are run. This pre-caching is done with the qemu_test.Asset class. To use it "
"in your test, declare an asset in your test class with its URL and SHA256 "
"checksum like this::"
msgstr ""

#: ../../../devel/testing/functional.rst:292
msgid ""
"from qemu_test import Asset\n"
"\n"
"ASSET_somename = Asset(\n"
"    ('https://www.qemu.org/assets/images/qemu_head_200.png'),\n"
"    '34b74cad46ea28a2966c1d04e102510daf1fd73e6582b6b74523940d5da029dd')"
msgstr ""

#: ../../../devel/testing/functional.rst:298
msgid ""
"In your test function, you can then get the file name of the cached asset "
"like this::"
msgstr ""

#: ../../../devel/testing/functional.rst:301
msgid ""
"def test_function(self):\n"
"    file_path = self.ASSET_somename.fetch()"
msgstr ""

#: ../../../devel/testing/functional.rst:304
msgid ""
"The pre-caching will be done automatically when running ``make check-"
"functional`` (but not when running e.g. ``make check-functional-<target>``). "
"In case you just want to download the assets without running the tests, you "
"can do so by running::"
msgstr ""

#: ../../../devel/testing/functional.rst:309
msgid "make precache-functional"
msgstr ""

#: ../../../devel/testing/functional.rst:311
msgid ""
"The cache is populated in the ``~/.cache/qemu/download`` directory by "
"default, but the location can be changed by setting the "
"``QEMU_TEST_CACHE_DIR`` environment variable."
msgstr ""

#: ../../../devel/testing/functional.rst:315
msgid ""
"To force the test suite to re-download the cache, even if still valid, set "
"the ``QEMU_TEST_REFRESH_CACHE`` environment variable."
msgstr ""

#: ../../../devel/testing/functional.rst:319
msgid "Skipping tests"
msgstr ""

#: ../../../devel/testing/functional.rst:321
msgid ""
"Since the test framework is based on the common Python unittest framework, "
"you can use the usual Python decorators which allow for easily skipping "
"tests running under certain conditions, for example, on the lack of a binary "
"on the test system or when the running environment is a CI system. For "
"further information about those decorators, please refer to:"
msgstr ""

#: ../../../devel/testing/functional.rst:327
msgid ""
"https://docs.python.org/3/library/unittest.html#skipping-tests-and-expected-"
"failures"
msgstr ""

#: ../../../devel/testing/functional.rst:329
msgid ""
"While the conditions for skipping tests are often specifics of each one, "
"there are recurring scenarios identified by the QEMU developers and the use "
"of environment variables became a kind of standard way to enable/disable "
"tests."
msgstr ""

#: ../../../devel/testing/functional.rst:333
msgid "Here is a list of the most used variables:"
msgstr ""

#: ../../../devel/testing/functional.rst:336
msgid "QEMU_TEST_ALLOW_LARGE_STORAGE"
msgstr ""

#: ../../../devel/testing/functional.rst:337
msgid ""
"Tests which are going to fetch or produce assets considered *large* are not "
"going to run unless that ``QEMU_TEST_ALLOW_LARGE_STORAGE=1`` is exported on "
"the environment."
msgstr ""

#: ../../../devel/testing/functional.rst:341
msgid ""
"The definition of *large* is a bit arbitrary here, but it usually means an "
"asset which occupies at least 1GB of size on disk when uncompressed."
msgstr ""

#: ../../../devel/testing/functional.rst:345
msgid "QEMU_TEST_ALLOW_UNTRUSTED_CODE"
msgstr ""

#: ../../../devel/testing/functional.rst:346
msgid ""
"There are tests which will boot a kernel image or firmware that can be "
"considered not safe to run on the developer's workstation, thus they are "
"skipped by default. The definition of *not safe* is also arbitrary but "
"usually it means a blob which either its source or build process aren't "
"public available."
msgstr ""

#: ../../../devel/testing/functional.rst:352
msgid ""
"You should export ``QEMU_TEST_ALLOW_UNTRUSTED_CODE=1`` on the environment in "
"order to allow tests which make use of those kind of assets."
msgstr ""

#: ../../../devel/testing/functional.rst:356
msgid "QEMU_TEST_FLAKY_TESTS"
msgstr ""

#: ../../../devel/testing/functional.rst:357
msgid ""
"Some tests are not working reliably and thus are disabled by default. This "
"includes tests that don't run reliably on GitLab's CI which usually expose "
"real issues that are rarely seen on developer machines due to the "
"constraints of the CI environment. If you encounter a similar situation then "
"raise a bug and then mark the test as shown on the code snippet below:"
msgstr ""

#: ../../../devel/testing/functional.rst:364
msgid ""
"# See https://gitlab.com/qemu-project/qemu/-/issues/nnnn\n"
"@skipUnless(os.getenv('QEMU_TEST_FLAKY_TESTS'), 'Test is unstable on "
"GitLab')\n"
"def test(self):\n"
"    do_something()"
msgstr ""

#: ../../../devel/testing/functional.rst:371
msgid ""
"Tests should not live in this state forever and should either be fixed or "
"eventually removed."
msgstr ""

#: ../../../devel/testing/functional.rst:375
msgid "QEMU_TEST_ALLOW_SLOW"
msgstr ""

#: ../../../devel/testing/functional.rst:376
msgid ""
"Tests that have a very long runtime and might run into timeout issues e.g. "
"if the QEMU binary has been compiled with debugging options enabled. To "
"avoid these timeout issues by default and to save some precious CPU cycles "
"during normal testing, such tests are disabled by default unless the "
"QEMU_TEST_ALLOW_SLOW environment variable has been set."
msgstr ""
