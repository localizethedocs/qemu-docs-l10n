# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/qdev-api.rst:5
msgid "QEMU Device (qdev) API Reference"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1
msgid "**The QEMU Device API**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:15
msgid ""
"All modern devices should represented as a derived QOM class of TYPE_DEVICE. "
"The device API introduces the additional methods of **realize** and "
"**unrealize** to represent additional stages in a device objects life cycle."
msgstr ""

#: ../../../../include/hw/qdev-core.h:23
msgid "Devices are constructed in two stages:"
msgstr ""

#: ../../../../include/hw/qdev-core.h:25
msgid "object instantiation via object_initialize() and"
msgstr ""

#: ../../../../include/hw/qdev-core.h:26
msgid ""
"device realization via the :c:type:`DeviceState.realized <DeviceState>` "
"property"
msgstr ""

#: ../../../../include/hw/qdev-core.h:28
msgid ""
"The former may not fail (and must not abort or exit, since it is called "
"during device introspection already), and the latter may return error "
"information to the caller and must be re-entrant. Trivial field "
"initializations should go into :c:type:`TypeInfo.instance_init <TypeInfo>`. "
"Operations depending on **props** static properties should go into "
"**realize**. After successful realization, setting static properties will "
"fail."
msgstr ""

#: ../../../../include/hw/qdev-core.h:35
msgid ""
"As an interim step, the :c:type:`DeviceState.realized <DeviceState>` "
"property can also be set with qdev_realize(). In the future, devices will "
"propagate this state change to their children and along busses they expose. "
"The point in time will be deferred to machine creation, so that values set "
"in **realize** will not be introspectable beforehand. Therefore devices must "
"not create children during **realize**; they should initialize them via "
"object_initialize() in their own :c:type:`TypeInfo.instance_init <TypeInfo>` "
"and forward the realization events appropriately."
msgstr ""

#: ../../../../include/hw/qdev-core.h:45
msgid ""
"Any type may override the **realize** and/or **unrealize** callbacks but "
"needs to call the parent type's implementation if keeping their "
"functionality is desired. Refer to QOM documentation for further discussion "
"and examples."
msgstr ""

#: ../../../../include/hw/qdev-core.h:50
msgid ""
"Since TYPE_DEVICE doesn't implement **realize** and **unrealize**, types "
"derived directly from it need not call their parent's **realize** and "
"**unrealize**. For other types consult the documentation and implementation "
"of the respective parent types."
msgstr ""

#: ../../../../include/hw/qdev-core.h:58
msgid ""
"To hide a device, a DeviceListener function hide_device() needs to be "
"registered. It can be used to defer adding a device and therefore hide it "
"from the guest. The handler registering to this DeviceListener can save the "
"QOpts passed to it for re-using it later. It must return if it wants the "
"device to be hidden or visible. When the handler function decides the device "
"shall be visible it will be added with qdev_device_add() and realized as any "
"other device. Otherwise qdev_device_add() will return early without adding "
"the device. The guest will not see a \"hidden\" device until it was marked "
"visible and qdev_device_add called again."
msgstr ""

#: ../../../../include/hw/qdev-core.h:101
msgid "The base class for all devices."
msgstr ""

#: ../../../../include/hw/qdev-core.h:103
#: ../../../../include/hw/qdev-core.h:217
#: ../../../../include/hw/qdev-core.h:369
msgid "**Definition**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:107
msgid ""
"struct DeviceClass {\n"
"  unsigned long categories[BITS_TO_LONGS(DEVICE_CATEGORY_MAX)];\n"
"  const char *fw_name;\n"
"  const char *desc;\n"
"  const Property *props_;\n"
"  bool user_creatable;\n"
"  bool hotpluggable;\n"
"  DeviceReset legacy_reset;\n"
"  DeviceRealize realize;\n"
"  DeviceUnrealize unrealize;\n"
"  DeviceSyncConfig sync_config;\n"
"  const VMStateDescription *vmsd;\n"
"  const char *bus_type;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:122
#: ../../../../include/hw/qdev-core.h:242
#: ../../../../include/hw/qdev-core.h:386
msgid "**Members**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:121
msgid "``categories``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:122
msgid "device categories device belongs to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:125
msgid "``fw_name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:126
msgid "name used to identify device to firmware interfaces"
msgstr ""

#: ../../../../include/hw/qdev-core.h:129
msgid "``desc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:130
msgid "human readable description of device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:134
msgid "``props_``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:135
msgid ""
"properties associated with device, should only be assigned by using "
"device_class_set_props(). The underscore ensures a compile-time error if "
"someone attempts to assign dc->props directly."
msgstr ""

#: ../../../../include/hw/qdev-core.h:142
msgid "``user_creatable``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:143
msgid "Can user instantiate with -device / device_add?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:145
msgid ""
"All devices should support instantiation with device_add, and this flag "
"should not exist.  But we're not there, yet.  Some devices fail to "
"instantiate with cryptic error messages. Others instantiate, but don't "
"work.  Exposing users to such behavior would be cruel; clearing this flag "
"will protect them. It should never be cleared without a comment explaining "
"why it is cleared."
msgstr ""

#: ../../../../include/hw/qdev-core.h:153
msgid "TODO remove once we're there"
msgstr ""

#: ../../../../include/hw/qdev-core.h:110
msgid "``hotpluggable``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:111
msgid ""
"indicates if :c:type:`DeviceClass <DeviceClass>` is hotpluggable, available "
"as readonly \"hotpluggable\" property of :c:type:`DeviceState <DeviceState>` "
"instance"
msgstr ""

#: ../../../../include/hw/qdev-core.h:159
msgid "``legacy_reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:160
msgid "deprecated device reset method pointer"
msgstr ""

#: ../../../../include/hw/qdev-core.h:162
msgid ""
"Modern code should use the ResettableClass interface to implement a multi-"
"phase reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:165
msgid "TODO: remove once every reset callback is unused"
msgstr ""

#: ../../../../include/hw/qdev-core.h:103
msgid "``realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:104
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``true``."
msgstr ""

#: ../../../../include/hw/qdev-core.h:105
msgid "``unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:106
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``false``."
msgstr ""

#: ../../../../include/hw/qdev-core.h:107
msgid "``sync_config``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:108
msgid ""
"Callback function invoked when QMP command device-sync-config is called. "
"Should synchronize device configuration from host to guest part and notify "
"the guest about the change."
msgstr ""

#: ../../../../include/hw/qdev-core.h:172
msgid "``vmsd``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:173
msgid "device state serialisation description for migration/save/restore"
msgstr ""

#: ../../../../include/hw/qdev-core.h:178
msgid "``bus_type``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:179
msgid "bus type private: to qdev / bus."
msgstr ""

#: ../../../../include/hw/qdev-core.h:215
msgid "common device state, accessed with qdev helpers"
msgstr ""

#: ../../../../include/hw/qdev-core.h:221
msgid ""
"struct DeviceState {\n"
"  char *id;\n"
"  char *canonical_path;\n"
"  bool realized;\n"
"  bool pending_deleted_event;\n"
"  int64_t pending_deleted_expires_ms;\n"
"  QDict *opts;\n"
"  int hotplugged;\n"
"  bool allow_unplug_during_migration;\n"
"  BusState *parent_bus;\n"
"  NamedGPIOListHead gpios;\n"
"  NamedClockListHead clocks;\n"
"  BusStateHead child_bus;\n"
"  int num_child_bus;\n"
"  int instance_id_alias;\n"
"  int alias_required_for_version;\n"
"  ResettableState reset;\n"
"  GSList *unplug_blockers;\n"
"  MemReentrancyGuard mem_reentrancy_guard;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:226
msgid "``id``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:227
msgid "global device id"
msgstr ""

#: ../../../../include/hw/qdev-core.h:230
msgid "``canonical_path``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:231
msgid "canonical path of realized device in the QOM tree"
msgstr ""

#: ../../../../include/hw/qdev-core.h:234
#: ../../../../include/hw/qdev-core.h:374
msgid "``realized``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:235
msgid "has device been realized?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:238
msgid "``pending_deleted_event``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:239
msgid "track pending deletion events during unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:242
msgid "``pending_deleted_expires_ms``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:243
msgid "optional timeout for deletion events"
msgstr ""

#: ../../../../include/hw/qdev-core.h:246
msgid "``opts``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:247
msgid "QDict of options for the device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:250
msgid "``hotplugged``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:251
msgid "was device added after PHASE_MACHINE_READY?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:254
msgid "``allow_unplug_during_migration``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:255
msgid "can device be unplugged during migration"
msgstr ""

#: ../../../../include/hw/qdev-core.h:258
msgid "``parent_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:259
msgid "bus this device belongs to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:262
msgid "``gpios``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:263
msgid "QLIST of named GPIOs the device provides."
msgstr ""

#: ../../../../include/hw/qdev-core.h:266
msgid "``clocks``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:267
msgid "QLIST of named clocks the device provides."
msgstr ""

#: ../../../../include/hw/qdev-core.h:270
msgid "``child_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:271
msgid "QLIST of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:274
msgid "``num_child_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:275
msgid "number of **child_bus** entries"
msgstr ""

#: ../../../../include/hw/qdev-core.h:278
msgid "``instance_id_alias``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:279
msgid "device alias for handling legacy migration setups"
msgstr ""

#: ../../../../include/hw/qdev-core.h:282
msgid "``alias_required_for_version``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:283
msgid "indicates **instance_id_alias** is needed for migration"
msgstr ""

#: ../../../../include/hw/qdev-core.h:287
#: ../../../../include/hw/qdev-core.h:400
msgid "``reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:288
msgid "ResettableState for the device; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/qdev-core.h:291
msgid "``unplug_blockers``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:292
msgid "list of reasons to block unplugging of device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:295
msgid "``mem_reentrancy_guard``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:296
msgid "Is the device currently in mmio/pio/dma?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:298
msgid "Used to prevent re-entrancy confusing things."
msgstr ""

#: ../../../../include/hw/qdev-core.h:301
#: ../../../../include/hw/qdev-core.h:408
#: ../../../../include/hw/qdev-core.h:438
#: ../../../../include/hw/qdev-core.h:450
#: ../../../../include/hw/qdev-core.h:476
#: ../../../../include/hw/qdev-core.h:495
#: ../../../../include/hw/qdev-core.h:521
#: ../../../../include/hw/qdev-core.h:592
#: ../../../../include/hw/qdev-core.h:610
#: ../../../../include/hw/qdev-core.h:633
#: ../../../../include/hw/qdev-core.h:653
#: ../../../../include/hw/qdev-core.h:686
#: ../../../../include/hw/qdev-core.h:713
#: ../../../../include/hw/qdev-core.h:734
#: ../../../../include/hw/qdev-core.h:759
#: ../../../../include/hw/qdev-core.h:778
#: ../../../../include/hw/qdev-core.h:808
#: ../../../../include/hw/qdev-core.h:835
#: ../../../../include/hw/qdev-core.h:851
#: ../../../../include/hw/qdev-core.h:899
#: ../../../../include/hw/qdev-core.h:908
#: ../../../../include/hw/qdev-core.h:940
#: ../../../../include/hw/qdev-core.h:952
#: ../../../../include/hw/qdev-core.h:967
#: ../../../../include/hw/qdev-core.h:982
#: ../../../../include/hw/qdev-core.h:1003
#: ../../../../include/hw/qdev-core.h:1043
#: ../../../../include/hw/qdev-core.h:1072
msgid "**Description**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:217
msgid ""
"This structure should not be accessed directly.  We declare it here so that "
"it can be embedded in individual device state structures."
msgstr ""

#: ../../../../include/hw/qdev-core.h:373
msgid ""
"struct BusState {\n"
"  DeviceState *parent;\n"
"  char *name;\n"
"  HotplugHandler *hotplug_handler;\n"
"  int max_index;\n"
"  bool realized;\n"
"  bool full;\n"
"  int num_children;\n"
"  BusChildHead children;\n"
"  BusStateEntry sibling;\n"
"  ResettableState reset;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:370
msgid "``parent``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:371
msgid "parent Device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:371
msgid "``name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:372
msgid "name of bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:372
msgid "``hotplug_handler``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:373
msgid "link to a hotplug handler associated with bus."
msgstr ""

#: ../../../../include/hw/qdev-core.h:373
msgid "``max_index``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:374
msgid "max number of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:375
msgid "is the bus itself realized?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:375
msgid "``full``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:376
msgid "is the bus full?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:376
msgid "``num_children``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:377
msgid "current number of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:391
msgid "``children``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:392
msgid ""
"an RCU protected QTAILQ, thus readers must use RCU to access it, and writers "
"must hold the big qemu lock"
msgstr ""

#: ../../../../include/hw/qdev-core.h:396
msgid "``sibling``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:397
msgid "next bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:401
msgid "ResettableState for the bus; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/qdev-core.h:406
msgid "a global property type"
msgstr ""

#: ../../../../include/hw/qdev-core.h:412
msgid ""
"An error is fatal for non-hotplugged devices, when the global is applied."
msgstr ""

#: ../../../../include/hw/qdev-core.h:435
msgid "Create a device on the heap"
msgstr ""

#: ../../../../include/hw/qdev-core.h:437
#: ../../../../include/hw/qdev-core.h:449
#: ../../../../include/hw/qdev-core.h:461
#: ../../../../include/hw/qdev-core.h:473
#: ../../../../include/hw/qdev-core.h:492
#: ../../../../include/hw/qdev-core.h:520
#: ../../../../include/hw/qdev-core.h:546
#: ../../../../include/hw/qdev-core.h:564
#: ../../../../include/hw/qdev-core.h:572
#: ../../../../include/hw/qdev-core.h:581
#: ../../../../include/hw/qdev-core.h:608
#: ../../../../include/hw/qdev-core.h:630
#: ../../../../include/hw/qdev-core.h:650
#: ../../../../include/hw/qdev-core.h:681
#: ../../../../include/hw/qdev-core.h:710
#: ../../../../include/hw/qdev-core.h:730
#: ../../../../include/hw/qdev-core.h:756
#: ../../../../include/hw/qdev-core.h:775
#: ../../../../include/hw/qdev-core.h:804
#: ../../../../include/hw/qdev-core.h:818
#: ../../../../include/hw/qdev-core.h:831
#: ../../../../include/hw/qdev-core.h:848
#: ../../../../include/hw/qdev-core.h:898
#: ../../../../include/hw/qdev-core.h:907
#: ../../../../include/hw/qdev-core.h:916
#: ../../../../include/hw/qdev-core.h:924
#: ../../../../include/hw/qdev-core.h:938
#: ../../../../include/hw/qdev-core.h:949
#: ../../../../include/hw/qdev-core.h:965
#: ../../../../include/hw/qdev-core.h:979
#: ../../../../include/hw/qdev-core.h:1002
#: ../../../../include/hw/qdev-core.h:1042
#: ../../../../include/hw/qdev-core.h:1068
msgid "**Parameters**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:439
#: ../../../../include/hw/qdev-core.h:451
#: ../../../../include/hw/qdev-core.h:631
#: ../../../../include/hw/qdev-core.h:683
#: ../../../../include/hw/qdev-core.h:711
#: ../../../../include/hw/qdev-core.h:732
#: ../../../../include/hw/qdev-core.h:806
#: ../../../../include/hw/qdev-core.h:821
#: ../../../../include/hw/qdev-core.h:833
#: ../../../../include/hw/qdev-core.h:850
msgid "``const char *name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:436
msgid "device type to create (we assert() that this type exists)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:438
msgid ""
"This only allocates the memory and initializes the device state structure, "
"ready for the caller to set properties if they wish. The device still needs "
"to be realized."
msgstr ""

#: ../../../../include/hw/qdev-core.h:442
#: ../../../../include/hw/qdev-core.h:453
#: ../../../../include/hw/qdev-core.h:464
#: ../../../../include/hw/qdev-core.h:485
#: ../../../../include/hw/qdev-core.h:513
#: ../../../../include/hw/qdev-core.h:550
#: ../../../../include/hw/qdev-core.h:584
#: ../../../../include/hw/qdev-core.h:623
#: ../../../../include/hw/qdev-core.h:643
#: ../../../../include/hw/qdev-core.h:723
#: ../../../../include/hw/qdev-core.h:744
#: ../../../../include/hw/qdev-core.h:917
#: ../../../../include/hw/qdev-core.h:925
#: ../../../../include/hw/qdev-core.h:1008
#: ../../../../include/hw/qdev-core.h:1074
msgid "**Return**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:442
msgid "a derived DeviceState object with a reference count of 1."
msgstr ""

#: ../../../../include/hw/qdev-core.h:447
msgid "Try to create a device on the heap"
msgstr ""

#: ../../../../include/hw/qdev-core.h:448
msgid "device type to create"
msgstr ""

#: ../../../../include/hw/qdev-core.h:450
msgid ""
"This is like qdev_new(), except it returns ``NULL`` when type **name** does "
"not exist, rather than asserting."
msgstr ""

#: ../../../../include/hw/qdev-core.h:453
msgid ""
"a derived DeviceState object with a reference count of 1 or NULL if type "
"**name** does not exist."
msgstr ""

#: ../../../../include/hw/qdev-core.h:459
msgid "check if device is realized"
msgstr ""

#: ../../../../include/hw/qdev-core.h:463
#: ../../../../include/hw/qdev-core.h:475
#: ../../../../include/hw/qdev-core.h:494
#: ../../../../include/hw/qdev-core.h:522
#: ../../../../include/hw/qdev-core.h:548
#: ../../../../include/hw/qdev-core.h:566
#: ../../../../include/hw/qdev-core.h:574
#: ../../../../include/hw/qdev-core.h:583
#: ../../../../include/hw/qdev-core.h:610
#: ../../../../include/hw/qdev-core.h:632
#: ../../../../include/hw/qdev-core.h:652
#: ../../../../include/hw/qdev-core.h:683
#: ../../../../include/hw/qdev-core.h:712
#: ../../../../include/hw/qdev-core.h:732
#: ../../../../include/hw/qdev-core.h:758
#: ../../../../include/hw/qdev-core.h:777
#: ../../../../include/hw/qdev-core.h:806
#: ../../../../include/hw/qdev-core.h:820
#: ../../../../include/hw/qdev-core.h:833
#: ../../../../include/hw/qdev-core.h:850
#: ../../../../include/hw/qdev-core.h:900
#: ../../../../include/hw/qdev-core.h:918
#: ../../../../include/hw/qdev-core.h:1004
msgid "``DeviceState *dev``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:460
msgid "The device to check."
msgstr ""

#: ../../../../include/hw/qdev-core.h:462
msgid "**Context**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:462
msgid "May be called outside big qemu lock."
msgstr ""

#: ../../../../include/hw/qdev-core.h:463
msgid "true if the device has been fully constructed, false otherwise."
msgstr ""

#: ../../../../include/hw/qdev-core.h:471
msgid "Realize **dev**."
msgstr ""

#: ../../../../include/hw/qdev-core.h:472
#: ../../../../include/hw/qdev-core.h:491
msgid "device to realize"
msgstr ""

#: ../../../../include/hw/qdev-core.h:474
#: ../../../../include/hw/qdev-core.h:493
#: ../../../../include/hw/qdev-core.h:909
#: ../../../../include/hw/qdev-core.h:926
#: ../../../../include/hw/qdev-core.h:1044
msgid "``BusState *bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:473
#: ../../../../include/hw/qdev-core.h:492
msgid "bus to plug it into (may be NULL)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:475
#: ../../../../include/hw/qdev-core.h:494
#: ../../../../include/hw/qdev-core.h:583
#: ../../../../include/hw/qdev-core.h:1071
msgid "``Error **errp``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:474
#: ../../../../include/hw/qdev-core.h:493
#: ../../../../include/hw/qdev-core.h:1070
msgid "pointer to error object"
msgstr ""

#: ../../../../include/hw/qdev-core.h:476
msgid ""
"\"Realize\" the device, i.e. perform the second phase of device "
"initialization. **dev** must not be plugged into a bus already. If **bus**, "
"plug **dev** into **bus**.  This takes a reference to **dev**. If **dev** "
"has no QOM parent, make one up, taking another reference."
msgstr ""

#: ../../../../include/hw/qdev-core.h:482
msgid ""
"If you created **dev** using qdev_new(), you probably want to use "
"qdev_realize_and_unref() instead."
msgstr ""

#: ../../../../include/hw/qdev-core.h:485
#: ../../../../include/hw/qdev-core.h:513
msgid "true on success, else false setting **errp** with error"
msgstr ""

#: ../../../../include/hw/qdev-core.h:490
msgid "Realize **dev** and drop a reference"
msgstr ""

#: ../../../../include/hw/qdev-core.h:495
msgid ""
"Realize **dev** and drop a reference. This is like qdev_realize(), except "
"the caller must hold a (private) reference, which is dropped on return "
"regardless of success or failure.  Intended use::"
msgstr ""

#: ../../../../include/hw/qdev-core.h:500
msgid ""
"dev = qdev_new();\n"
"[...]\n"
"qdev_realize_and_unref(dev, bus, errp);"
msgstr ""

#: ../../../../include/hw/qdev-core.h:504
msgid "Now **dev** can go away without further ado."
msgstr ""

#: ../../../../include/hw/qdev-core.h:506
msgid ""
"If you are embedding the device into some other QOM device and initialized "
"it via some variant on object_initialize_child() then do not use this "
"function, because that family of functions arrange for the only reference to "
"the child device to be held by the parent via the child<> property, and so "
"the reference-count-drop done here would be incorrect. For that use case you "
"want qdev_realize()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:518
msgid "Unrealize a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:519
msgid "device to unrealize"
msgstr ""

#: ../../../../include/hw/qdev-core.h:521
msgid ""
"This function will \"unrealize\" a device, which is the first phase of "
"correctly destroying a device that has been realized. It will:"
msgstr ""

#: ../../../../include/hw/qdev-core.h:524
msgid ""
"unrealize any child buses by calling qbus_unrealize() (this will recursively "
"unrealize any devices on those buses)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:526
msgid "call the unrealize method of **dev**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:528
msgid ""
"The device can then be freed by causing its reference count to go to zero."
msgstr ""

#: ../../../../include/hw/qdev-core.h:531
msgid ""
"Warning: most devices in QEMU do not expect to be unrealized.  Only devices "
"which are hot-unpluggable should be unrealized (as part of the unplugging "
"process); all other devices are expected to last for the life of the "
"simulation and should not be unrealized and freed."
msgstr ""

#: ../../../../include/hw/qdev-core.h:544
msgid "Get handler responsible for device wiring"
msgstr ""

#: ../../../../include/hw/qdev-core.h:545
msgid "the device we want the HOTPLUG_HANDLER for."
msgstr ""

#: ../../../../include/hw/qdev-core.h:547
msgid "**Note**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:547
msgid ""
"in case **dev** has a parent bus, it will be returned as handler unless "
"machine handler overrides it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:550
msgid ""
"pointer to object that implements TYPE_HOTPLUG_HANDLER interface or NULL if "
"there aren't any."
msgstr ""

#: ../../../../include/hw/qdev-core.h:562
msgid "Add an unplug blocker to a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:564
msgid "Device to be blocked from unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:566
#: ../../../../include/hw/qdev-core.h:574
msgid "``Error *reason``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:565
msgid "Reason for blocking"
msgstr ""

#: ../../../../include/hw/qdev-core.h:570
msgid "Remove an unplug blocker from a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:572
msgid "Device to be unblocked"
msgstr ""

#: ../../../../include/hw/qdev-core.h:573
msgid ""
"Pointer to the Error used with qdev_add_unplug_blocker. Used as a handle to "
"lookup the blocker for deletion."
msgstr ""

#: ../../../../include/hw/qdev-core.h:579
msgid "Confirm if a device is blocked from unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:581
msgid "Device to be tested"
msgstr ""

#: ../../../../include/hw/qdev-core.h:582
msgid "The reasons why the device is blocked, if any"
msgstr ""

#: ../../../../include/hw/qdev-core.h:584
msgid ""
"true (also setting **errp**) if device is blocked from unplug, false "
"otherwise"
msgstr ""

#: ../../../../include/hw/qdev-core.h:590
msgid "Polarity of a GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:592
msgid ""
"GPIO lines use either positive (active-high) logic, or negative (active-low) "
"logic."
msgstr ""

#: ../../../../include/hw/qdev-core.h:595
msgid ""
"In active-high logic (``GPIO_POLARITY_ACTIVE_HIGH``), a pin is active when "
"the voltage on the pin is high (relative to ground); whereas in active-low "
"logic (``GPIO_POLARITY_ACTIVE_LOW``), a pin is active when the voltage on "
"the pin is low (or grounded)."
msgstr ""

#: ../../../../include/hw/qdev-core.h:606
msgid "Get one of a device's anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:607
#: ../../../../include/hw/qdev-core.h:629
msgid "Device whose GPIO we want"
msgstr ""

#: ../../../../include/hw/qdev-core.h:609
#: ../../../../include/hw/qdev-core.h:632
#: ../../../../include/hw/qdev-core.h:651
#: ../../../../include/hw/qdev-core.h:684
#: ../../../../include/hw/qdev-core.h:712
#: ../../../../include/hw/qdev-core.h:733
#: ../../../../include/hw/qdev-core.h:758
#: ../../../../include/hw/qdev-core.h:777
#: ../../../../include/hw/qdev-core.h:807
#: ../../../../include/hw/qdev-core.h:822
#: ../../../../include/hw/qdev-core.h:834
msgid "``int n``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:608
msgid "Number of the anonymous GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:610
msgid ""
"Returns the qemu_irq corresponding to an anonymous input GPIO line (which "
"the device has set up with qdev_init_gpio_in()). The index **n** of the GPIO "
"line must be valid (i.e. be at least 0 and less than the total number of "
"anonymous input GPIOs the device has); this function will assert() if passed "
"an invalid index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:616
msgid ""
"This function is intended to be used by board code or SoC \"container\" "
"device models to wire up the GPIO lines; usually the return value will be "
"passed to qdev_connect_gpio_out() or a similar function to connect another "
"device's output GPIO line to this input."
msgstr ""

#: ../../../../include/hw/qdev-core.h:621
msgid "For named input GPIO lines, use qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:623
msgid "qemu_irq corresponding to anonymous input GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:628
msgid "Get one of a device's named input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:630
msgid "Name of the input GPIO array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:631
msgid "Number of the GPIO line in that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:633
msgid ""
"Returns the qemu_irq corresponding to a single input GPIO line in a named "
"array of input GPIO lines on a device (which the device has set up with "
"qdev_init_gpio_in_named()). The **name** string must correspond to an input "
"GPIO array which exists on the device, and the index **n** of the GPIO line "
"must be valid (i.e. be at least 0 and less than the total number of input "
"GPIOs in that array); this function will assert() if passed an invalid name "
"or index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:641
msgid "For anonymous input GPIO lines, use qdev_get_gpio_in()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:643
msgid "qemu_irq corresponding to named input GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:648
msgid "Connect one of a device's anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:649
#: ../../../../include/hw/qdev-core.h:681
msgid "Device whose GPIO to connect"
msgstr ""

#: ../../../../include/hw/qdev-core.h:650
msgid "Number of the anonymous output GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:652
msgid "``qemu_irq pin``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:651
#: ../../../../include/hw/qdev-core.h:684
msgid "qemu_irq to connect the output line to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:653
msgid ""
"This function connects an anonymous output GPIO line on a device up to an "
"arbitrary qemu_irq, so that when the device asserts that output GPIO line, "
"the qemu_irq's callback is invoked. The index **n** of the GPIO line must be "
"valid (i.e. be at least 0 and less than the total number of anonymous output "
"GPIOs the device has created with qdev_init_gpio_out()); otherwise this "
"function will assert()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:660
#: ../../../../include/hw/qdev-core.h:694
msgid ""
"Outbound GPIO lines can be connected to any qemu_irq, but the common case is "
"connecting them to another device's inbound GPIO line, using the qemu_irq "
"returned by qdev_get_gpio_in() or qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:664
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq. (Warning: "
"there is no assertion or other guard to catch this error: the model will "
"just not do the right thing.) Instead, for fan-out you can use the "
"TYPE_SPLIT_IRQ device: connect a device's outbound GPIO to the splitter's "
"input, and connect each of the splitter's outputs to a different device.  "
"For fan-in you can use the TYPE_OR_IRQ device, which is a model of a logical "
"OR gate with multiple inputs and one output."
msgstr ""

#: ../../../../include/hw/qdev-core.h:674
msgid "For named output GPIO lines, use qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:679
msgid "Connect one of a device's named output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:682
#: ../../../../include/hw/qdev-core.h:710
#: ../../../../include/hw/qdev-core.h:731
msgid "Name of the output GPIO array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:683
msgid ""
"Number of the output GPIO line within that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:685
msgid "``qemu_irq input_pin``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:686
msgid ""
"This function connects a single GPIO output in a named array of output GPIO "
"lines on a device up to an arbitrary qemu_irq, so that when the device "
"asserts that output GPIO line, the qemu_irq's callback is invoked. The "
"**name** string must correspond to an output GPIO array which exists on the "
"device, and the index **n** of the GPIO line must be valid (i.e. be at least "
"0 and less than the total number of output GPIOs in that array); this "
"function will assert() if passed an invalid name or index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:698
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq; see "
"qdev_connect_gpio_out() for details."
msgstr ""

#: ../../../../include/hw/qdev-core.h:702
msgid "For anonymous output GPIO lines, use qdev_connect_gpio_out()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:708
msgid "Get the qemu_irq connected to an output GPIO"
msgstr ""

#: ../../../../include/hw/qdev-core.h:709
msgid "Device whose output GPIO we are interested in"
msgstr ""

#: ../../../../include/hw/qdev-core.h:711
msgid "Number of the output GPIO line within that array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:713
msgid ""
"Returns whatever qemu_irq is currently connected to the specified output "
"GPIO line of **dev**. This will be NULL if the output GPIO line has never "
"been wired up to the anything.  Note that the qemu_irq returned does not "
"belong to **dev** -- it will be the input GPIO or IRQ of whichever device "
"the board code has connected up to **dev**'s output GPIO."
msgstr ""

#: ../../../../include/hw/qdev-core.h:720
msgid ""
"You probably don't need to use this function -- it is used only by the "
"platform-bus subsystem."
msgstr ""

#: ../../../../include/hw/qdev-core.h:723
msgid "qemu_irq associated with GPIO or NULL if un-wired."
msgstr ""

#: ../../../../include/hw/qdev-core.h:728
msgid "Intercept an existing GPIO connection"
msgstr ""

#: ../../../../include/hw/qdev-core.h:729
msgid "Device to intercept the outbound GPIO line from"
msgstr ""

#: ../../../../include/hw/qdev-core.h:731
msgid "``qemu_irq icpt``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:730
msgid "New qemu_irq to connect instead"
msgstr ""

#: ../../../../include/hw/qdev-core.h:732
msgid "Number of the GPIO line in the array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:735
msgid ""
"This function is provided only for use by the qtest testing framework and is "
"not suitable for use in non-testing parts of QEMU."
msgstr ""

#: ../../../../include/hw/qdev-core.h:738
msgid ""
"This function breaks an existing connection of an outbound GPIO line from "
"**dev**, and replaces it with the new qemu_irq **icpt**, as if "
"``qdev_connect_gpio_out_named(dev, icpt, name, n)`` had been called. The "
"previously connected qemu_irq is returned, so it can be restored by a second "
"call to qdev_intercept_gpio_out() if desired."
msgstr ""

#: ../../../../include/hw/qdev-core.h:744
msgid "old disconnected qemu_irq if one existed"
msgstr ""

#: ../../../../include/hw/qdev-core.h:754
msgid "create an array of anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:755
#: ../../../../include/hw/qdev-core.h:817
msgid "Device to create input GPIOs for"
msgstr ""

#: ../../../../include/hw/qdev-core.h:757
#: ../../../../include/hw/qdev-core.h:819
#: ../../../../include/hw/qdev-core.h:832
msgid "``qemu_irq_handler handler``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:756
#: ../../../../include/hw/qdev-core.h:818
msgid "Function to call when GPIO line value is set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:757
#: ../../../../include/hw/qdev-core.h:776
msgid "Number of GPIO lines to create"
msgstr ""

#: ../../../../include/hw/qdev-core.h:759
msgid ""
"Devices should use functions in the qdev_init_gpio_in* family in their "
"instance_init or realize methods to create any input GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO input whose "
"purpose is obvious. Note that input GPIO lines can serve as 'sinks' for IRQ "
"lines."
msgstr ""

#: ../../../../include/hw/qdev-core.h:767
msgid ""
"See qdev_get_gpio_in() for how code that uses such a device can get hold of "
"an input GPIO line to manipulate it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:773
msgid "create an array of anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:774
#: ../../../../include/hw/qdev-core.h:803
msgid "Device to create output GPIOs for"
msgstr ""

#: ../../../../include/hw/qdev-core.h:776
#: ../../../../include/hw/qdev-core.h:805
msgid "``qemu_irq *pins``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:775
#: ../../../../include/hw/qdev-core.h:804
msgid "Pointer to qemu_irq or qemu_irq array for the GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:778
msgid ""
"Devices should use functions in the qdev_init_gpio_out* family in their "
"instance_init or realize methods to create any output GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO output whose "
"purpose is obvious."
msgstr ""

#: ../../../../include/hw/qdev-core.h:785
msgid ""
"The **pins** argument should be a pointer to either a \"qemu_irq\" (if **n** "
"== 1) or a \"qemu_irq []\" array (if **n** > 1) in the device's state "
"structure. The device implementation can then raise and lower the GPIO line "
"by calling qemu_set_irq(). (If anything is connected to the other end of the "
"GPIO this will cause the handler function for that input GPIO to be called.)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:792
msgid ""
"See qdev_connect_gpio_out() for how code that uses such a device can connect "
"to one of its output GPIO lines."
msgstr ""

#: ../../../../include/hw/qdev-core.h:795
msgid ""
"There is no need to release the **pins** allocated array because it will be "
"automatically released when **dev** calls its instance_finalize() handler."
msgstr ""

#: ../../../../include/hw/qdev-core.h:802
msgid "create an array of named output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:805
msgid "Name to give this array of GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:806
msgid "Number of GPIO lines to create in this array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:808
msgid ""
"Like qdev_init_gpio_out(), but creates an array of GPIO output lines with a "
"name. Code using the device can then connect these GPIO lines using "
"qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:816
#: ../../../../include/hw/qdev-core.h:829
msgid "create an array of input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:820
msgid "``void *opaque``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:819
msgid "Opaque data pointer to pass to **handler**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:820
#: ../../../../include/hw/qdev-core.h:832
msgid "Name of the GPIO input (must be unique for this device)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:821
#: ../../../../include/hw/qdev-core.h:833
msgid "Number of GPIO lines in this input set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:830
msgid "device to add array to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:831
msgid "a &typedef qemu_irq_handler function to call when GPIO is set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:835
msgid ""
"Like qdev_init_gpio_in_named_with_opaque(), but the opaque pointer passed to "
"the handler is **dev** (which is the most commonly desired behaviour)."
msgstr ""

#: ../../../../include/hw/qdev-core.h:846
msgid "create GPIO lines on container which pass through to device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:847
msgid "Device which has GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:849
msgid "``DeviceState *container``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:848
msgid "Container device which needs to expose them"
msgstr ""

#: ../../../../include/hw/qdev-core.h:849
msgid "Name of GPIO array to pass through (NULL for the anonymous GPIO array)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:851
msgid ""
"In QEMU, complicated devices like SoCs are often modelled with a "
"\"container\" QOM device which itself contains other QOM devices and which "
"wires them up appropriately. This function allows the container to create "
"GPIO arrays on itself which simply pass through to a GPIO array of one of "
"its internal devices."
msgstr ""

#: ../../../../include/hw/qdev-core.h:857
msgid ""
"If **dev** has both input and output GPIOs named **name** then both will be "
"passed through. It is not possible to pass a subset of the array with this "
"function."
msgstr ""

#: ../../../../include/hw/qdev-core.h:861
msgid ""
"To users of the container device, the GPIO array created on **container** "
"behaves exactly like any other."
msgstr ""

#: ../../../../include/hw/qdev-core.h:896
msgid "perform a recursive cold reset on a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:897
msgid "device to reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:899
msgid ""
"Reset device **dev** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/qdev-core.h:905
msgid "perform a recursive cold reset on a bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:906
msgid "bus to reset"
msgstr ""

#: ../../../../include/hw/qdev-core.h:908
msgid ""
"Reset bus **bus** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/qdev-core.h:914
msgid "check device reset state"
msgstr ""

#: ../../../../include/hw/qdev-core.h:915
msgid "device to check"
msgstr ""

#: ../../../../include/hw/qdev-core.h:917
msgid "true if the device **dev** is currently being reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:922
msgid "check bus reset state"
msgstr ""

#: ../../../../include/hw/qdev-core.h:923
msgid "bus to check"
msgstr ""

#: ../../../../include/hw/qdev-core.h:925
msgid "true if the bus **bus** is currently being reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:936
msgid "add a set of properties to an device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:940
#: ../../../../include/hw/qdev-core.h:951
#: ../../../../include/hw/qdev-core.h:967
#: ../../../../include/hw/qdev-core.h:981
msgid "``DeviceClass *dc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:937
msgid "the parent DeviceClass all devices inherit"
msgstr ""

#: ../../../../include/hw/qdev-core.h:939
msgid "``const Property *props``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:938
msgid "an array of properties, terminate by DEFINE_PROP_END_OF_LIST()"
msgstr ""

#: ../../../../include/hw/qdev-core.h:940
msgid ""
"This will add a set of properties to the object. It will fault if you "
"attempt to add an existing property defined by a parent class. To modify an "
"inherited property you need to use????"
msgstr ""

#: ../../../../include/hw/qdev-core.h:947
msgid "set up for chaining realize fns"
msgstr ""

#: ../../../../include/hw/qdev-core.h:948
#: ../../../../include/hw/qdev-core.h:964
#: ../../../../include/hw/qdev-core.h:978
msgid "The device class"
msgstr ""

#: ../../../../include/hw/qdev-core.h:950
msgid "``DeviceRealize dev_realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:949
#: ../../../../include/hw/qdev-core.h:979
msgid "the device realize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:951
msgid "``DeviceRealize *parent_realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:950
msgid "somewhere to save the parents realize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:952
msgid ""
"This is intended to be used when the new realize function will eventually "
"call its parent realization function during creation. This requires storing "
"the function call somewhere (usually in the instance structure) so you can "
"eventually call dc->parent_realize(dev, errp)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:963
msgid "set the DeviceClass::reset method"
msgstr ""

#: ../../../../include/hw/qdev-core.h:966
msgid "``DeviceReset dev_reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:965
msgid "the reset function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:967
msgid ""
"This function sets the DeviceClass::reset method. This is widely used in "
"existing code, but new code should prefer to use the Resettable API as "
"documented in docs/devel/reset.rst. In addition, devices which need to chain "
"to their parent class's reset methods or which need to be subclassed must "
"use Resettable."
msgstr ""

#: ../../../../include/hw/qdev-core.h:977
msgid "set up for chaining unrealize fns"
msgstr ""

#: ../../../../include/hw/qdev-core.h:980
msgid "``DeviceUnrealize dev_unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:981
msgid "``DeviceUnrealize *parent_unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:980
msgid "somewhere to save the parents unrealize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:982
msgid ""
"This is intended to be used when the new unrealize function will eventually "
"call its parent unrealization function during the unrealize phase. This "
"requires storing the function call somewhere (usually in the instance "
"structure) so you can eventually call dc->parent_unrealize(dev);"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1000
msgid "Return a human-readable name for a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1001
msgid "The device. Must be a valid and non-NULL pointer."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1004
msgid "This function is intended for user friendly error messages."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1006
msgid "Use g_free() to free it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1006
msgid ""
"A newly allocated string containing the device id if not null, else the "
"object canonical path."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1040
msgid "Mark this bus as full, so no more devices can be attached"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1041
msgid "Bus to mark as full"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1043
msgid ""
"By default, QEMU will allow devices to be plugged into a bus up to the bus "
"class's device count limit. Calling this function marks a particular bus as "
"full, so that no more devices can be plugged into it. In particular this "
"means that the bus will not be considered as a candidate for plugging in "
"devices created by the user on the commandline or via the monitor. If a "
"machine has multiple buses of a given type, such as I2C, where some of those "
"buses in the real hardware are used only for internal devices and some are "
"exposed via expansion ports, you can use this function to mark the internal-"
"only buses as full after you have created all their internal devices. Then "
"user created devices will appear on the expansion-port bus where guest "
"software expects them."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1066
msgid "check if device should be hidden"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1070
msgid "``const QDict *opts``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1068
msgid "options QDict"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1070
msgid "``bool from_json``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1069
msgid "true if **opts** entries are typed, false for all strings"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1072
msgid "When a device is added via qdev_device_add() this will be called."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1074
msgid "if the device should be added now or not."
msgstr ""
