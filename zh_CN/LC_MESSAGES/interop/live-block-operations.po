# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../interop/live-block-operations.rst:11
msgid "Live Block Device Operations"
msgstr ""

#: ../../../interop/live-block-operations.rst:13
msgid ""
"QEMU Block Layer currently (as of QEMU 2.9) supports four major kinds of "
"live block device jobs -- stream, commit, mirror, and backup.  These can be "
"used to manipulate disk image chains to accomplish certain tasks, namely: "
"live copy data from backing files into overlays; shorten long disk image "
"chains by merging data from overlays into backing files; live synchronize "
"data from a disk image chain (including current active disk) to another "
"target image; and point-in-time (and incremental) backups of a block "
"device.  Below is a description of the said block (QMP) primitives, and some "
"(non-exhaustive list of) examples to illustrate their use."
msgstr ""

#: ../../../interop/live-block-operations.rst:25
msgid ""
"The file ``qapi/block-core.json`` in the QEMU source tree has the canonical "
"QEMU API (QAPI) schema documentation for the QMP primitives discussed here."
msgstr ""

#: ../../../interop/live-block-operations.rst:32
msgid "Contents"
msgstr ""

#: ../../../interop/live-block-operations.rst:35
msgid "Disk image backing chain notation"
msgstr ""

#: ../../../interop/live-block-operations.rst:37
msgid ""
"A simple disk image chain.  (This can be created live using QMP ``blockdev-"
"snapshot-sync``, or offline via ``qemu-img``)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:40
msgid ""
"               (Live QEMU)\n"
"                    |\n"
"                    .\n"
"                    V\n"
"\n"
"        [A] <----- [B]\n"
"\n"
"(backing file)    (overlay)"
msgstr ""

#: ../../../interop/live-block-operations.rst:49
msgid ""
"The arrow can be read as: Image [A] is the backing file of disk image [B].  "
"And live QEMU is currently writing to image [B], consequently, it is also "
"referred to as the \"active layer\"."
msgstr ""

#: ../../../interop/live-block-operations.rst:53
msgid ""
"There are two kinds of terminology that are common when referring to files "
"in a disk image backing chain:"
msgstr ""

#: ../../../interop/live-block-operations.rst:56
msgid ""
"Directional: 'base' and 'top'.  Given the simple disk image chain above, "
"image [A] can be referred to as 'base', and image [B] as 'top'.  (This "
"terminology can be seen in the QAPI schema file, block-core.json.)"
msgstr ""

#: ../../../interop/live-block-operations.rst:61
msgid ""
"Relational: 'backing file' and 'overlay'.  Again, taking the same simple "
"disk image chain from the above, disk image [A] is referred to as the "
"backing file, and image [B] as overlay."
msgstr ""

#: ../../../interop/live-block-operations.rst:65
msgid "Throughout this document, we will use the relational terminology."
msgstr ""

#: ../../../interop/live-block-operations.rst:68
msgid ""
"The overlay files can generally be any format that supports a backing file, "
"although QCOW2 is the preferred format and the one used in this document."
msgstr ""

#: ../../../interop/live-block-operations.rst:74
msgid "Brief overview of live block QMP primitives"
msgstr ""

#: ../../../interop/live-block-operations.rst:76
msgid ""
"The following are the four different kinds of live block operations that "
"QEMU block layer supports."
msgstr ""

#: ../../../interop/live-block-operations.rst:79
msgid ""
"``block-stream``: Live copy of data from backing files into overlay files."
msgstr ""

#: ../../../interop/live-block-operations.rst:82
msgid "Once the 'stream' operation has finished, three things to note:"
msgstr ""

#: ../../../interop/live-block-operations.rst:85
msgid ""
"QEMU rewrites the backing chain to remove reference to the now-streamed and "
"redundant backing file;"
msgstr ""

#: ../../../interop/live-block-operations.rst:89
msgid ""
"the streamed file *itself* won't be removed by QEMU, and must be explicitly "
"discarded by the user;"
msgstr ""

#: ../../../interop/live-block-operations.rst:92
msgid ""
"the streamed file remains valid -- i.e. further overlays can be created "
"based on it.  Refer the ``block-stream`` section further below for more "
"details."
msgstr ""

#: ../../../interop/live-block-operations.rst:97
msgid ""
"``block-commit``: Live merge of data from overlay files into backing files "
"(with the optional goal of removing the overlay file from the chain).  Since "
"QEMU 2.0, this includes \"active ``block-commit``\" (i.e. merge the current "
"active layer into the base image)."
msgstr ""

#: ../../../interop/live-block-operations.rst:102
msgid ""
"Once the 'commit' operation has finished, there are three things to note "
"here as well:"
msgstr ""

#: ../../../interop/live-block-operations.rst:105
msgid ""
"QEMU rewrites the backing chain to remove reference to now-redundant overlay "
"images that have been committed into a backing file;"
msgstr ""

#: ../../../interop/live-block-operations.rst:109
msgid ""
"the committed file *itself* won't be removed by QEMU -- it ought to be "
"manually removed;"
msgstr ""

#: ../../../interop/live-block-operations.rst:112
msgid ""
"however, unlike in the case of ``block-stream``, the intermediate images "
"will be rendered invalid -- i.e. no more further overlays can be created "
"based on them.  Refer the ``block-commit`` section further below for more "
"details."
msgstr ""

#: ../../../interop/live-block-operations.rst:118
msgid ""
"``drive-mirror`` (and ``blockdev-mirror``): Synchronize a running disk to "
"another image."
msgstr ""

#: ../../../interop/live-block-operations.rst:121
msgid ""
"``blockdev-backup`` (and the deprecated ``drive-backup``): Point-in-time "
"(live) copy of a block device to a destination."
msgstr ""

#: ../../../interop/live-block-operations.rst:128
msgid "Interacting with a QEMU instance"
msgstr ""

#: ../../../interop/live-block-operations.rst:130
msgid ""
"To show some example invocations of command-line, we will use the following "
"invocation of QEMU, with a QMP server running over UNIX socket:"
msgstr ""

#: ../../../interop/live-block-operations.rst:136
msgid ""
"$ |qemu_system| -display none -no-user-config -nodefaults \\\\\n"
"  -m 512 -blockdev \\\\\n"
"  node-name=node-A,driver=qcow2,file.driver=file,file.node-name=file,file."
"filename=./a.qcow2 \\\\\n"
"  -device virtio-blk,drive=node-A,id=virtio0 \\\\\n"
"  -monitor stdio -qmp unix:/tmp/qmp-sock,server=on,wait=off"
msgstr ""

#: ../../../interop/live-block-operations.rst:142
msgid ""
"The ``-blockdev`` command-line option, used above, is available from QEMU "
"2.9 onwards.  In the above invocation, notice the ``node-name`` parameter "
"that is used to refer to the disk image a.qcow2 ('node-A') -- this is a "
"cleaner way to refer to a disk image (as opposed to referring to it by "
"spelling out file paths).  So, we will continue to designate a ``node-name`` "
"to each further disk image created (either via ``blockdev-snapshot-sync``, "
"or ``blockdev-add``) as part of the disk image chain, and continue to refer "
"to the disks using their ``node-name`` (where possible, because ``block-"
"commit`` does not yet, as of QEMU 2.9, accept ``node-name`` parameter) when "
"performing various block operations."
msgstr ""

#: ../../../interop/live-block-operations.rst:154
msgid ""
"To interact with the QEMU instance launched above, we will use the ``qmp-"
"shell`` utility (located at: ``qemu/scripts/qmp``, as part of the QEMU "
"source directory), which takes key-value pairs for QMP commands. Invoke it "
"as below (which will also print out the complete raw JSON syntax for "
"reference -- examples in the following sections)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:160
msgid ""
"$ ./qmp-shell -v -p /tmp/qmp-sock\n"
"(QEMU)"
msgstr ""

#: ../../../interop/live-block-operations.rst:164
msgid ""
"In the event we have to repeat a certain QMP command, we will: for the first "
"occurrence of it, show the ``qmp-shell`` invocation, *and* the corresponding "
"raw JSON QMP syntax; but for subsequent invocations, present just the ``qmp-"
"shell`` syntax, and omit the equivalent JSON output."
msgstr ""

#: ../../../interop/live-block-operations.rst:172
msgid "Example disk image chain"
msgstr ""

#: ../../../interop/live-block-operations.rst:174
msgid ""
"We will use the below disk image chain (and occasionally spelling it out "
"where appropriate) when discussing various primitives::"
msgstr ""

#: ../../../interop/live-block-operations.rst:177
#: ../../../interop/live-block-operations.rst:216
#: ../../../interop/live-block-operations.rst:243
#: ../../../interop/live-block-operations.rst:340
#: ../../../interop/live-block-operations.rst:430
#: ../../../interop/live-block-operations.rst:511
#: ../../../interop/live-block-operations.rst:666
#: ../../../interop/live-block-operations.rst:713
#: ../../../interop/live-block-operations.rst:845
#: ../../../interop/live-block-operations.rst:952
msgid "[A] <-- [B] <-- [C] <-- [D]"
msgstr ""

#: ../../../interop/live-block-operations.rst:179
msgid ""
"Where [A] is the original base image; [B] and [C] are intermediate overlay "
"images; image [D] is the active layer -- i.e. live QEMU is writing to it.  "
"(The rule of thumb is: live QEMU will always be pointing to the rightmost "
"image in a disk image chain.)"
msgstr ""

#: ../../../interop/live-block-operations.rst:184
msgid ""
"The above image chain can be created by invoking ``blockdev-snapshot-sync`` "
"commands as following (which shows the creation of overlay image [B]) using "
"the ``qmp-shell`` (our invocation also prints the raw JSON invocation of "
"it)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:189
#: ../../../interop/live-block-operations.rst:1032
msgid ""
"(QEMU) blockdev-snapshot-sync node-name=node-A snapshot-file=b.qcow2 "
"snapshot-node-name=node-B format=qcow2\n"
"{\n"
"    \"execute\": \"blockdev-snapshot-sync\",\n"
"    \"arguments\": {\n"
"        \"node-name\": \"node-A\",\n"
"        \"snapshot-file\": \"b.qcow2\",\n"
"        \"format\": \"qcow2\",\n"
"        \"snapshot-node-name\": \"node-B\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:200
msgid ""
"Here, \"node-A\" is the name QEMU internally uses to refer to the base image "
"[A] -- it is the backing file, based on which the overlay image, [B], is "
"created."
msgstr ""

#: ../../../interop/live-block-operations.rst:204
msgid ""
"To create the rest of the overlay images, [C], and [D] (omitting the raw "
"JSON output for brevity)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:207
msgid ""
"(QEMU) blockdev-snapshot-sync node-name=node-B snapshot-file=c.qcow2 "
"snapshot-node-name=node-C format=qcow2\n"
"(QEMU) blockdev-snapshot-sync node-name=node-C snapshot-file=d.qcow2 "
"snapshot-node-name=node-D format=qcow2"
msgstr ""

#: ../../../interop/live-block-operations.rst:212
msgid "A note on points-in-time vs file names"
msgstr ""

#: ../../../interop/live-block-operations.rst:214
msgid "In our disk image chain::"
msgstr ""

#: ../../../interop/live-block-operations.rst:218
msgid "We have *three* points in time and an active layer:"
msgstr ""

#: ../../../interop/live-block-operations.rst:220
msgid "Point 1: Guest state when [B] was created is contained in file [A]"
msgstr ""

#: ../../../interop/live-block-operations.rst:221
msgid "Point 2: Guest state when [C] was created is contained in [A] + [B]"
msgstr ""

#: ../../../interop/live-block-operations.rst:222
msgid ""
"Point 3: Guest state when [D] was created is contained in [A] + [B] + [C]"
msgstr ""

#: ../../../interop/live-block-operations.rst:224
msgid "Active layer: Current guest state is contained in [A] + [B] + [C] + [D]"
msgstr ""

#: ../../../interop/live-block-operations.rst:227
msgid "Therefore, be aware with naming choices:"
msgstr ""

#: ../../../interop/live-block-operations.rst:229
msgid ""
"Naming a file after the time it is created is misleading -- the guest data "
"for that point in time is *not* contained in that file (as explained earlier)"
msgstr ""

#: ../../../interop/live-block-operations.rst:232
msgid "Rather, think of files as a *delta* from the backing file"
msgstr ""

#: ../../../interop/live-block-operations.rst:236
msgid "Live block streaming --- ``block-stream``"
msgstr ""

#: ../../../interop/live-block-operations.rst:238
msgid ""
"The ``block-stream`` command allows you to do live copy data from backing "
"files into overlay images."
msgstr ""

#: ../../../interop/live-block-operations.rst:241
msgid "Given our original example disk image chain from earlier::"
msgstr ""

#: ../../../interop/live-block-operations.rst:245
msgid ""
"The disk image chain can be shortened in one of the following different ways "
"(not an exhaustive list)."
msgstr ""

#: ../../../interop/live-block-operations.rst:250
msgid ""
"Merge everything into the active layer: I.e. copy all contents from the base "
"image, [A], and overlay images, [B] and [C], into [D], *while* the guest is "
"running.  The resulting chain will be a standalone image, [D] -- with "
"contents from [A], [B] and [C] merged into it (where live QEMU writes go "
"to)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:256
msgid "[D]"
msgstr ""

#: ../../../interop/live-block-operations.rst:260
msgid ""
"Taking the same example disk image chain mentioned earlier, merge only "
"images [B] and [C] into [D], the active layer.  The result will be contents "
"of images [B] and [C] will be copied into [D], and the backing file pointer "
"of image [D] will be adjusted to point to image [A].  The resulting chain "
"will be::"
msgstr ""

#: ../../../interop/live-block-operations.rst:266
#: ../../../interop/live-block-operations.rst:356
msgid "[A] <-- [D]"
msgstr ""

#: ../../../interop/live-block-operations.rst:270
msgid ""
"Intermediate streaming (available since QEMU 2.8): Starting afresh with the "
"original example disk image chain, with a total of four images, it is "
"possible to copy contents from image [B] into image [C].  Once the copy is "
"finished, image [B] can now be (optionally) discarded; and the backing file "
"pointer of image [C] will be adjusted to point to [A].  I.e. after "
"performing \"intermediate streaming\" of [B] into [C], the resulting image "
"chain will be (where live QEMU is writing to [D])::"
msgstr ""

#: ../../../interop/live-block-operations.rst:279
#: ../../../interop/live-block-operations.rst:350
#: ../../../interop/live-block-operations.rst:400
msgid "[A] <-- [C] <-- [D]"
msgstr ""

#: ../../../interop/live-block-operations.rst:283
msgid "QMP invocation for ``block-stream``"
msgstr ""

#: ../../../interop/live-block-operations.rst:285
msgid ""
"For `Case-1`_, to merge contents of all the backing files into the active "
"layer, where 'node-D' is the current active image (by default ``block-"
"stream`` will flatten the entire chain); ``qmp-shell`` (and its "
"corresponding JSON output)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:290
msgid ""
"(QEMU) block-stream device=node-D job-id=job0\n"
"{\n"
"    \"execute\": \"block-stream\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"job-id\": \"job0\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:299
msgid ""
"For `Case-2`_, merge contents of the images [B] and [C] into [D], where "
"image [D] ends up referring to image [A] as its backing file::"
msgstr ""

#: ../../../interop/live-block-operations.rst:302
msgid "(QEMU) block-stream device=node-D base-node=node-A job-id=job0"
msgstr ""

#: ../../../interop/live-block-operations.rst:304
msgid ""
"And for `Case-3`_, of \"intermediate\" streaming\", merge contents of images "
"[B] into [C], where [C] ends up referring to [A] as its backing image::"
msgstr ""

#: ../../../interop/live-block-operations.rst:308
msgid "(QEMU) block-stream device=node-C base-node=node-A job-id=job0"
msgstr ""

#: ../../../interop/live-block-operations.rst:310
msgid ""
"Progress of a ``block-stream`` operation can be monitored via the QMP "
"command::"
msgstr ""

#: ../../../interop/live-block-operations.rst:313
#: ../../../interop/live-block-operations.rst:1084
msgid ""
"(QEMU) query-block-jobs\n"
"{\n"
"    \"execute\": \"query-block-jobs\",\n"
"    \"arguments\": {}\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:320
msgid ""
"Once the ``block-stream`` operation has completed, QEMU will emit an event, "
"``BLOCK_JOB_COMPLETED``.  The intermediate overlays remain valid, and can "
"now be (optionally) discarded, or retained to create further overlays based "
"on them.  Finally, the ``block-stream`` jobs can be restarted at anytime."
msgstr ""

#: ../../../interop/live-block-operations.rst:328
msgid "Live block commit --- ``block-commit``"
msgstr ""

#: ../../../interop/live-block-operations.rst:330
msgid ""
"The ``block-commit`` command lets you merge live data from overlay images "
"into backing file(s).  Since QEMU 2.0, this includes \"live active "
"commit\" (i.e. it is possible to merge the \"active layer\", the right-most "
"image in a disk image chain where live QEMU will be writing to, into the "
"base image).  This is analogous to ``block-stream``, but in the opposite "
"direction."
msgstr ""

#: ../../../interop/live-block-operations.rst:337
msgid ""
"Again, starting afresh with our example disk image chain, where live QEMU is "
"writing to the right-most image in the chain, [D]::"
msgstr ""

#: ../../../interop/live-block-operations.rst:342
msgid "The disk image chain can be shortened in one of the following ways:"
msgstr ""

#: ../../../interop/live-block-operations.rst:346
msgid ""
"Commit content from only image [B] into image [A].  The resulting chain is "
"the following, where image [C] is adjusted to point at [A] as its new "
"backing file::"
msgstr ""

#: ../../../interop/live-block-operations.rst:352
msgid ""
"Commit content from images [B] and [C] into image [A].  The resulting chain, "
"where image [D] is adjusted to point to image [A] as its new backing file::"
msgstr ""

#: ../../../interop/live-block-operations.rst:360
msgid ""
"Commit content from images [B], [C], and the active layer [D] into image "
"[A].  The resulting chain (in this case, a consolidated single image)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:364
#: ../../../interop/live-block-operations.rst:434
msgid "[A]"
msgstr ""

#: ../../../interop/live-block-operations.rst:366
msgid ""
"Commit content from image only image [C] into image [B].  The resulting "
"chain::"
msgstr ""

#: ../../../interop/live-block-operations.rst:369
msgid "[A] <-- [B] <-- [D]"
msgstr ""

#: ../../../interop/live-block-operations.rst:371
msgid ""
"Commit content from image [C] and the active layer [D] into image [B].  The "
"resulting chain::"
msgstr ""

#: ../../../interop/live-block-operations.rst:374
#: ../../../interop/live-block-operations.rst:1024
msgid "[A] <-- [B]"
msgstr ""

#: ../../../interop/live-block-operations.rst:378
msgid "QMP invocation for ``block-commit``"
msgstr ""

#: ../../../interop/live-block-operations.rst:380
msgid ""
"For :ref:`Case-1 <block-commit_Case-1>`, to merge contents only from image "
"[B] into image [A], the invocation is as follows::"
msgstr ""

#: ../../../interop/live-block-operations.rst:383
msgid ""
"(QEMU) block-commit device=node-D base=a.qcow2 top=b.qcow2 job-id=job0\n"
"{\n"
"    \"execute\": \"block-commit\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"job-id\": \"job0\",\n"
"        \"top\": \"b.qcow2\",\n"
"        \"base\": \"a.qcow2\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:394
msgid ""
"Once the above ``block-commit`` operation has completed, a "
"``BLOCK_JOB_COMPLETED`` event will be issued, and no further action is "
"required.  As the end result, the backing file of image [C] is adjusted to "
"point to image [A], and the original 4-image chain will end up being "
"transformed to::"
msgstr ""

#: ../../../interop/live-block-operations.rst:403
msgid ""
"The intermediate image [B] is invalid (as in: no more further overlays based "
"on it can be created)."
msgstr ""

#: ../../../interop/live-block-operations.rst:406
msgid ""
"Reasoning: An intermediate image after a 'stream' operation still represents "
"that old point-in-time, and may be valid in that context. However, an "
"intermediate image after a 'commit' operation no longer represents any point-"
"in-time, and is invalid in any context."
msgstr ""

#: ../../../interop/live-block-operations.rst:412
msgid ""
"However, :ref:`Case-3 <block-commit_Case-3>` (also called: \"active ``block-"
"commit``\") is a *two-phase* operation: In the first phase, the content from "
"the active overlay, along with the intermediate overlays, is copied into the "
"backing file (also called the base image).  In the second phase, adjust the "
"said backing file as the current active image -- possible via issuing the "
"command ``block-job-complete``.  Optionally, the ``block-commit`` operation "
"can be cancelled by issuing the command ``block-job-cancel``, but be careful "
"when doing this."
msgstr ""

#: ../../../interop/live-block-operations.rst:421
msgid ""
"Once the ``block-commit`` operation has completed, the event "
"``BLOCK_JOB_READY`` will be emitted, signalling that the synchronization has "
"finished.  Now the job can be gracefully completed by issuing the command "
"``block-job-complete`` -- until such a command is issued, the 'commit' "
"operation remains active."
msgstr ""

#: ../../../interop/live-block-operations.rst:427
msgid ""
"The following is the flow for :ref:`Case-3 <block-commit_Case-3>` to convert "
"a disk image chain such as this::"
msgstr ""

#: ../../../interop/live-block-operations.rst:432
msgid "Into::"
msgstr ""

#: ../../../interop/live-block-operations.rst:436
msgid ""
"Where content from all the subsequent overlays, [B], and [C], including the "
"active layer, [D], is committed back to [A] -- which is where live QEMU is "
"performing all its current writes)."
msgstr ""

#: ../../../interop/live-block-operations.rst:440
msgid "Start the \"active ``block-commit``\" operation::"
msgstr ""

#: ../../../interop/live-block-operations.rst:442
msgid ""
"(QEMU) block-commit device=node-D base=a.qcow2 top=d.qcow2 job-id=job0\n"
"{\n"
"    \"execute\": \"block-commit\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"job-id\": \"job0\",\n"
"        \"top\": \"d.qcow2\",\n"
"        \"base\": \"a.qcow2\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:454
msgid ""
"Once the synchronization has completed, the event ``BLOCK_JOB_READY`` will "
"be emitted."
msgstr ""

#: ../../../interop/live-block-operations.rst:457
msgid ""
"Then, optionally query for the status of the active block operations. We can "
"see the 'commit' job is now ready to be completed, as indicated by the line "
"*\"ready\": true*::"
msgstr ""

#: ../../../interop/live-block-operations.rst:461
msgid ""
"(QEMU) query-block-jobs\n"
"{\n"
"    \"execute\": \"query-block-jobs\",\n"
"    \"arguments\": {}\n"
"}\n"
"{\n"
"    \"return\": [\n"
"        {\n"
"            \"busy\": false,\n"
"            \"type\": \"commit\",\n"
"            \"len\": 1376256,\n"
"            \"paused\": false,\n"
"            \"ready\": true,\n"
"            \"io-status\": \"ok\",\n"
"            \"offset\": 1376256,\n"
"            \"device\": \"job0\",\n"
"            \"speed\": 0\n"
"        }\n"
"    ]\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:482
msgid "Gracefully complete the 'commit' block device job::"
msgstr ""

#: ../../../interop/live-block-operations.rst:484
#: ../../../interop/live-block-operations.rst:914
msgid ""
"(QEMU) block-job-complete device=job0\n"
"{\n"
"    \"execute\": \"block-job-complete\",\n"
"    \"arguments\": {\n"
"        \"device\": \"job0\"\n"
"    }\n"
"}\n"
"{\n"
"    \"return\": {}\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:495
msgid ""
"Finally, once the above job is completed, an event ``BLOCK_JOB_COMPLETED`` "
"will be emitted."
msgstr ""

#: ../../../interop/live-block-operations.rst:499
msgid ""
"The invocation for rest of the cases (2, 4, and 5), discussed in the "
"previous section, is omitted for brevity."
msgstr ""

#: ../../../interop/live-block-operations.rst:504
msgid "Live disk synchronization --- ``drive-mirror`` and ``blockdev-mirror``"
msgstr ""

#: ../../../interop/live-block-operations.rst:506
msgid ""
"Synchronize a running disk image chain (all or part of it) to a target image."
msgstr ""

#: ../../../interop/live-block-operations.rst:509
msgid "Again, given our familiar disk image chain::"
msgstr ""

#: ../../../interop/live-block-operations.rst:513
msgid ""
"The ``drive-mirror`` (and its newer equivalent ``blockdev-mirror``) allows "
"you to copy data from the entire chain into a single target image (which can "
"be located on a different host), [E]."
msgstr ""

#: ../../../interop/live-block-operations.rst:519
msgid ""
"When you cancel an in-progress 'mirror' job *before* the source and target "
"are synchronized, ``block-job-cancel`` will emit the event "
"``BLOCK_JOB_CANCELLED``.  However, note that if you cancel a 'mirror' job "
"*after* it has indicated (via the event ``BLOCK_JOB_READY``) that the source "
"and target have reached synchronization, then the event emitted by ``block-"
"job-cancel`` changes to ``BLOCK_JOB_COMPLETED``."
msgstr ""

#: ../../../interop/live-block-operations.rst:527
msgid ""
"Besides the 'mirror' job, the \"active ``block-commit``\" is the only other "
"block device job that emits the event ``BLOCK_JOB_READY``. The rest of the "
"block device jobs ('stream', \"non-active ``block-commit``\", and 'backup') "
"end automatically."
msgstr ""

#: ../../../interop/live-block-operations.rst:532
msgid ""
"So there are two possible actions to take, after a 'mirror' job has emitted "
"the event ``BLOCK_JOB_READY``, indicating that the source and target have "
"reached synchronization:"
msgstr ""

#: ../../../interop/live-block-operations.rst:536
msgid ""
"Issuing the command ``block-job-cancel`` (after it emits the event "
"``BLOCK_JOB_COMPLETED``) will create a point-in-time (which is at the time "
"of *triggering* the cancel command) copy of the entire disk image chain (or "
"only the top-most image, depending on the ``sync`` mode), contained in the "
"target image [E]. One use case for this is live VM migration with non-shared "
"storage."
msgstr ""

#: ../../../interop/live-block-operations.rst:543
msgid ""
"Issuing the command ``block-job-complete`` (after it emits the event "
"``BLOCK_JOB_COMPLETED``) will adjust the guest device (i.e. live QEMU) to "
"point to the target image, [E], causing all the new writes from this point "
"on to happen there."
msgstr ""

#: ../../../interop/live-block-operations.rst:548
msgid ""
"About synchronization modes: The synchronization mode determines *which* "
"part of the disk image chain will be copied to the target. Currently, there "
"are four different kinds:"
msgstr ""

#: ../../../interop/live-block-operations.rst:552
msgid ""
"``full`` -- Synchronize the content of entire disk image chain to the target"
msgstr ""

#: ../../../interop/live-block-operations.rst:555
msgid ""
"``top`` -- Synchronize only the contents of the top-most disk image in the "
"chain to the target"
msgstr ""

#: ../../../interop/live-block-operations.rst:558
msgid "``none`` -- Synchronize only the new writes from this point on."
msgstr ""

#: ../../../interop/live-block-operations.rst:560
msgid ""
"In the case of ``blockdev-backup`` (or deprecated ``drive-backup``), the "
"behavior of ``none`` synchronization mode is different.  Normally, a "
"``backup`` job consists of two parts: Anything that is overwritten by the "
"guest is first copied out to the backup, and in the background the whole "
"image is copied from start to end. With ``sync=none``, it's only the first "
"part."
msgstr ""

#: ../../../interop/live-block-operations.rst:569
msgid ""
"``incremental`` -- Synchronize content that is described by the dirty bitmap"
msgstr ""

#: ../../../interop/live-block-operations.rst:573
msgid ""
"Refer to the :doc:`bitmaps` document in the QEMU source tree to learn about "
"the detailed workings of the ``incremental`` synchronization mode."
msgstr ""

#: ../../../interop/live-block-operations.rst:579
msgid "QMP invocation for ``drive-mirror``"
msgstr ""

#: ../../../interop/live-block-operations.rst:581
msgid ""
"To copy the contents of the entire disk image chain, from [A] all the way to "
"[D], to a new target (``drive-mirror`` will create the destination file, if "
"it doesn't already exist), call it [E]::"
msgstr ""

#: ../../../interop/live-block-operations.rst:585
msgid ""
"(QEMU) drive-mirror device=node-D target=e.qcow2 sync=full job-id=job0\n"
"{\n"
"    \"execute\": \"drive-mirror\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"job-id\": \"job0\",\n"
"        \"target\": \"e.qcow2\",\n"
"        \"sync\": \"full\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:596
msgid ""
"The ``\"sync\": \"full\"``, from the above, means: copy the *entire* chain "
"to the destination."
msgstr ""

#: ../../../interop/live-block-operations.rst:599
msgid ""
"Following the above, querying for active block jobs will show that a "
"'mirror' job is \"ready\" to be completed (and QEMU will also emit an event, "
"``BLOCK_JOB_READY``)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:603
msgid ""
"(QEMU) query-block-jobs\n"
"{\n"
"    \"execute\": \"query-block-jobs\",\n"
"    \"arguments\": {}\n"
"}\n"
"{\n"
"    \"return\": [\n"
"        {\n"
"            \"busy\": false,\n"
"            \"type\": \"mirror\",\n"
"            \"len\": 21757952,\n"
"            \"paused\": false,\n"
"            \"ready\": true,\n"
"            \"io-status\": \"ok\",\n"
"            \"offset\": 21757952,\n"
"            \"device\": \"job0\",\n"
"            \"speed\": 0\n"
"        }\n"
"    ]\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:624
msgid ""
"And, as noted in the previous section, there are two possible actions at "
"this point:"
msgstr ""

#: ../../../interop/live-block-operations.rst:627
msgid ""
"Create a point-in-time snapshot by ending the synchronization.  The point-in-"
"time is at the time of *ending* the sync.  (The result of the following "
"being: the target image, [E], will be populated with content from the entire "
"chain, [A] to [D])::"
msgstr ""

#: ../../../interop/live-block-operations.rst:632
#: ../../../interop/live-block-operations.rst:770
msgid ""
"(QEMU) block-job-cancel device=job0\n"
"{\n"
"    \"execute\": \"block-job-cancel\",\n"
"    \"arguments\": {\n"
"        \"device\": \"job0\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:640
msgid "Or, complete the operation and pivot the live QEMU to the target copy::"
msgstr ""

#: ../../../interop/live-block-operations.rst:643
msgid "(QEMU) block-job-complete device=job0"
msgstr ""

#: ../../../interop/live-block-operations.rst:645
msgid ""
"In either of the above cases, if you once again run the ``query-block-jobs`` "
"command, there should not be any active block operation."
msgstr ""

#: ../../../interop/live-block-operations.rst:649
msgid ""
"Comparing 'commit' and 'mirror': In both then cases, the overlay images can "
"be discarded.  However, with 'commit', the *existing* base image will be "
"modified (by updating it with contents from overlays); while in the case of "
"'mirror', a *new* target image is populated with the data from the disk "
"image chain."
msgstr ""

#: ../../../interop/live-block-operations.rst:657
msgid "QMP invocation for live storage migration with ``drive-mirror`` + NBD"
msgstr ""

#: ../../../interop/live-block-operations.rst:659
msgid ""
"Live storage migration (without shared storage setup) is one of the most "
"common use-cases that takes advantage of the ``drive-mirror`` primitive and "
"QEMU's built-in Network Block Device (NBD) server.  Here's a quick walk-"
"through of this setup."
msgstr ""

#: ../../../interop/live-block-operations.rst:664
#: ../../../interop/live-block-operations.rst:843
msgid "Given the disk image chain::"
msgstr ""

#: ../../../interop/live-block-operations.rst:668
msgid ""
"Instead of copying content from the entire chain, synchronize *only* the "
"contents of the *top*-most disk image (i.e. the active layer), [D], to a "
"target, say, [TargetDisk]."
msgstr ""

#: ../../../interop/live-block-operations.rst:673
msgid ""
"The destination host must already have the contents of the backing chain, "
"involving images [A], [B], and [C], visible via other means -- whether by "
"``cp``, ``rsync``, or by some storage array-specific command.)"
msgstr ""

#: ../../../interop/live-block-operations.rst:678
msgid ""
"Sometimes, this is also referred to as \"shallow copy\" -- because only the "
"\"active layer\", and not the rest of the image chain, is copied to the "
"destination."
msgstr ""

#: ../../../interop/live-block-operations.rst:683
msgid ""
"In this example, for the sake of simplicity, we'll be using the same "
"``localhost`` as both source and destination."
msgstr ""

#: ../../../interop/live-block-operations.rst:686
msgid ""
"As noted earlier, on the destination host the contents of the backing chain "
"-- from images [A] to [C] -- are already expected to exist in some form (e."
"g. in a file called, ``Contents-of-A-B-C.qcow2``).  Now, on the destination "
"host, let's create a target overlay image (with the image ``Contents-of-A-B-"
"C.qcow2`` as its backing file), to which the contents of image [D] (from the "
"source QEMU) will be mirrored to::"
msgstr ""

#: ../../../interop/live-block-operations.rst:693
msgid ""
"$ qemu-img create -f qcow2 -b ./Contents-of-A-B-C.qcow2 \\\n"
"    -F qcow2 ./target-disk.qcow2"
msgstr ""

#: ../../../interop/live-block-operations.rst:696
msgid ""
"And start the destination QEMU (we already have the source QEMU running -- "
"discussed in the section: `Interacting with a QEMU instance`_) instance, "
"with the following invocation.  (As noted earlier, for simplicity's sake, "
"the destination QEMU is started on the same host, but it could be located "
"elsewhere):"
msgstr ""

#: ../../../interop/live-block-operations.rst:704
msgid ""
"$ |qemu_system| -display none -no-user-config -nodefaults \\\\\n"
"  -m 512 -blockdev \\\\\n"
"  node-name=node-TargetDisk,driver=qcow2,file.driver=file,file.node-"
"name=file,file.filename=./target-disk.qcow2 \\\\\n"
"  -device virtio-blk,drive=node-TargetDisk,id=virtio0 \\\\\n"
"  -S -monitor stdio -qmp unix:./qmp-sock2,server=on,wait=off \\\\\n"
"  -incoming tcp:localhost:6666"
msgstr ""

#: ../../../interop/live-block-operations.rst:711
msgid "Given the disk image chain on source QEMU::"
msgstr ""

#: ../../../interop/live-block-operations.rst:715
msgid ""
"On the destination host, it is expected that the contents of the chain ``[A] "
"<-- [B] <-- [C]`` are *already* present, and therefore copy *only* the "
"content of image [D]."
msgstr ""

#: ../../../interop/live-block-operations.rst:719
msgid ""
"[On *destination* QEMU] As part of the first step, start the built-in NBD "
"server on a given host (local host, represented by ``::``)and port::"
msgstr ""

#: ../../../interop/live-block-operations.rst:723
msgid ""
"(QEMU) nbd-server-start addr={\"type\":\"inet\",\"data\":{\"host\":\"::\","
"\"port\":\"49153\"}}\n"
"{\n"
"    \"execute\": \"nbd-server-start\",\n"
"    \"arguments\": {\n"
"        \"addr\": {\n"
"            \"data\": {\n"
"                \"host\": \"::\",\n"
"                \"port\": \"49153\"\n"
"            },\n"
"            \"type\": \"inet\"\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:737
msgid ""
"[On *destination* QEMU] And export the destination disk image using QEMU's "
"built-in NBD server::"
msgstr ""

#: ../../../interop/live-block-operations.rst:740
msgid ""
"(QEMU) nbd-server-add device=node-TargetDisk writable=true\n"
"{\n"
"    \"execute\": \"nbd-server-add\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-TargetDisk\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:748
msgid ""
"[On *source* QEMU] Then, invoke ``drive-mirror`` (NB: since we're running "
"``drive-mirror`` with ``mode=existing`` (meaning: synchronize to a pre-"
"created file, therefore 'existing', file on the target host), with the "
"synchronization mode as 'top' (``\"sync: \"top\"``)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:754
msgid ""
"(QEMU) drive-mirror device=node-D target=nbd:localhost:49153:exportname=node-"
"TargetDisk sync=top mode=existing job-id=job0\n"
"{\n"
"    \"execute\": \"drive-mirror\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"mode\": \"existing\",\n"
"        \"job-id\": \"job0\",\n"
"        \"target\": \"nbd:localhost:49153:exportname=node-TargetDisk\",\n"
"        \"sync\": \"top\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:766
msgid ""
"[On *source* QEMU] Once ``drive-mirror`` copies the entire data, and the "
"event ``BLOCK_JOB_READY`` is emitted, issue ``block-job-cancel`` to "
"gracefully end the synchronization, from source QEMU::"
msgstr ""

#: ../../../interop/live-block-operations.rst:778
msgid "[On *destination* QEMU] Then, stop the NBD server::"
msgstr ""

#: ../../../interop/live-block-operations.rst:780
msgid ""
"(QEMU) nbd-server-stop\n"
"{\n"
"    \"execute\": \"nbd-server-stop\",\n"
"    \"arguments\": {}\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:786
msgid ""
"[On *destination* QEMU] Finally, resume the guest vCPUs by issuing the QMP "
"command ``cont``::"
msgstr ""

#: ../../../interop/live-block-operations.rst:789
msgid ""
"(QEMU) cont\n"
"{\n"
"    \"execute\": \"cont\",\n"
"    \"arguments\": {}\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:796
msgid ""
"Higher-level libraries (e.g. libvirt) automate the entire above process "
"(although note that libvirt does not allow same-host migrations to localhost "
"for other reasons)."
msgstr ""

#: ../../../interop/live-block-operations.rst:802
msgid "Notes on ``blockdev-mirror``"
msgstr ""

#: ../../../interop/live-block-operations.rst:804
msgid ""
"The ``blockdev-mirror`` command is equivalent in core functionality to "
"``drive-mirror``, except that it operates at node-level in a BDS graph."
msgstr ""

#: ../../../interop/live-block-operations.rst:807
msgid ""
"Also: for ``blockdev-mirror``, the 'target' image needs to be explicitly "
"created (using ``qemu-img``) and attach it to live QEMU via ``blockdev-"
"add``, which assigns a name to the to-be created target node."
msgstr ""

#: ../../../interop/live-block-operations.rst:811
msgid ""
"E.g. the sequence of actions to create a point-in-time backup of an entire "
"disk image chain, to a target, using ``blockdev-mirror`` would be:"
msgstr ""

#: ../../../interop/live-block-operations.rst:814
#: ../../../interop/live-block-operations.rst:996
msgid ""
"Create the QCOW2 overlays, to arrive at a backing chain of desired depth"
msgstr ""

#: ../../../interop/live-block-operations.rst:817
#: ../../../interop/live-block-operations.rst:999
msgid "Create the target image (using ``qemu-img``), say, ``e.qcow2``"
msgstr ""

#: ../../../interop/live-block-operations.rst:819
#: ../../../interop/live-block-operations.rst:1001
msgid ""
"Attach the above created file (``e.qcow2``), run-time, using ``blockdev-"
"add`` to QEMU"
msgstr ""

#: ../../../interop/live-block-operations.rst:822
msgid ""
"Perform ``blockdev-mirror`` (use ``\"sync\": \"full\"`` to copy the entire "
"chain to the target).  And notice the event ``BLOCK_JOB_READY``"
msgstr ""

#: ../../../interop/live-block-operations.rst:826
msgid ""
"Optionally, query for active block jobs, there should be a 'mirror' job "
"ready to be completed"
msgstr ""

#: ../../../interop/live-block-operations.rst:829
msgid ""
"Gracefully complete the 'mirror' block device job, and notice the event "
"``BLOCK_JOB_COMPLETED``"
msgstr ""

#: ../../../interop/live-block-operations.rst:832
msgid ""
"Shutdown the guest by issuing the QMP ``quit`` command so that caches are "
"flushed"
msgstr ""

#: ../../../interop/live-block-operations.rst:835
#: ../../../interop/live-block-operations.rst:1011
msgid ""
"Then, finally, compare the contents of the disk image chain, and the target "
"copy with ``qemu-img compare``.  You should notice: \"Images are identical\""
msgstr ""

#: ../../../interop/live-block-operations.rst:841
msgid "QMP invocation for ``blockdev-mirror``"
msgstr ""

#: ../../../interop/live-block-operations.rst:847
msgid ""
"To copy the contents of the entire disk image chain, from [A] all the way to "
"[D], to a new target, call it [E].  The following is the flow."
msgstr ""

#: ../../../interop/live-block-operations.rst:850
msgid "Create the overlay images, [B], [C], and [D]::"
msgstr ""

#: ../../../interop/live-block-operations.rst:852
msgid ""
"(QEMU) blockdev-snapshot-sync node-name=node-A snapshot-file=b.qcow2 "
"snapshot-node-name=node-B format=qcow2\n"
"(QEMU) blockdev-snapshot-sync node-name=node-B snapshot-file=c.qcow2 "
"snapshot-node-name=node-C format=qcow2\n"
"(QEMU) blockdev-snapshot-sync node-name=node-C snapshot-file=d.qcow2 "
"snapshot-node-name=node-D format=qcow2"
msgstr ""

#: ../../../interop/live-block-operations.rst:856
msgid "Create the target image, [E]::"
msgstr ""

#: ../../../interop/live-block-operations.rst:858
#: ../../../interop/live-block-operations.rst:1046
msgid "$ qemu-img create -f qcow2 e.qcow2 39M"
msgstr ""

#: ../../../interop/live-block-operations.rst:860
msgid "Add the above created target image to QEMU, via ``blockdev-add``::"
msgstr ""

#: ../../../interop/live-block-operations.rst:862
#: ../../../interop/live-block-operations.rst:1050
msgid ""
"(QEMU) blockdev-add driver=qcow2 node-name=node-E file={\"driver\":\"file\","
"\"filename\":\"e.qcow2\"}\n"
"{\n"
"    \"execute\": \"blockdev-add\",\n"
"    \"arguments\": {\n"
"        \"node-name\": \"node-E\",\n"
"        \"driver\": \"qcow2\",\n"
"        \"file\": {\n"
"            \"driver\": \"file\",\n"
"            \"filename\": \"e.qcow2\"\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:875
msgid "Perform ``blockdev-mirror``, and notice the event ``BLOCK_JOB_READY``::"
msgstr ""

#: ../../../interop/live-block-operations.rst:877
msgid ""
"(QEMU) blockdev-mirror device=node-B target=node-E sync=full job-id=job0\n"
"{\n"
"    \"execute\": \"blockdev-mirror\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"job-id\": \"job0\",\n"
"        \"target\": \"node-E\",\n"
"        \"sync\": \"full\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:888
msgid "Query for active block jobs, there should be a 'mirror' job ready::"
msgstr ""

#: ../../../interop/live-block-operations.rst:890
msgid ""
"(QEMU) query-block-jobs\n"
"{\n"
"    \"execute\": \"query-block-jobs\",\n"
"    \"arguments\": {}\n"
"}\n"
"{\n"
"    \"return\": [\n"
"        {\n"
"            \"busy\": false,\n"
"            \"type\": \"mirror\",\n"
"            \"len\": 21561344,\n"
"            \"paused\": false,\n"
"            \"ready\": true,\n"
"            \"io-status\": \"ok\",\n"
"            \"offset\": 21561344,\n"
"            \"device\": \"job0\",\n"
"            \"speed\": 0\n"
"        }\n"
"    ]\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:911
msgid ""
"Gracefully complete the block device job operation, and notice the event "
"``BLOCK_JOB_COMPLETED``::"
msgstr ""

#: ../../../interop/live-block-operations.rst:925
msgid "Shutdown the guest, by issuing the ``quit`` QMP command::"
msgstr ""

#: ../../../interop/live-block-operations.rst:927
msgid ""
"(QEMU) quit\n"
"{\n"
"    \"execute\": \"quit\",\n"
"    \"arguments\": {}\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:935
msgid ""
"Live disk backup --- ``blockdev-backup`` and the deprecated``drive-backup``"
msgstr ""

#: ../../../interop/live-block-operations.rst:937
msgid ""
"The ``blockdev-backup`` (and the deprecated ``drive-backup``) allows you to "
"create a point-in-time snapshot."
msgstr ""

#: ../../../interop/live-block-operations.rst:940
msgid ""
"In this case, the point-in-time is when you *start* the ``blockdev-backup`` "
"(or deprecated ``drive-backup``) command."
msgstr ""

#: ../../../interop/live-block-operations.rst:945
msgid "QMP invocation for ``drive-backup``"
msgstr ""

#: ../../../interop/live-block-operations.rst:947
msgid ""
"Note that ``drive-backup`` command is deprecated since QEMU 6.2 and will be "
"removed in future."
msgstr ""

#: ../../../interop/live-block-operations.rst:950
msgid "Yet again, starting afresh with our example disk image chain::"
msgstr ""

#: ../../../interop/live-block-operations.rst:954
msgid ""
"To create a target image [E], with content populated from image [A] to [D], "
"from the above chain, the following is the syntax.  (If the target image "
"does not exist, ``drive-backup`` will create it)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:958
msgid ""
"(QEMU) drive-backup device=node-D sync=full target=e.qcow2 job-id=job0\n"
"{\n"
"    \"execute\": \"drive-backup\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-D\",\n"
"        \"job-id\": \"job0\",\n"
"        \"sync\": \"full\",\n"
"        \"target\": \"e.qcow2\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:969
msgid ""
"Once the above ``drive-backup`` has completed, a ``BLOCK_JOB_COMPLETED`` "
"event will be issued, indicating the live block device job operation has "
"completed, and no further action is required."
msgstr ""

#: ../../../interop/live-block-operations.rst:975
msgid ""
"Moving from the deprecated ``drive-backup`` to newer ``blockdev-backup``"
msgstr ""

#: ../../../interop/live-block-operations.rst:977
msgid ""
"``blockdev-backup`` differs from ``drive-backup`` in how you specify the "
"backup target. With ``blockdev-backup`` you can't specify filename as a "
"target.  Instead you use ``node-name`` of existing block node, which you may "
"add by ``blockdev-add`` or ``blockdev-create`` commands. Correspondingly, "
"``blockdev-backup`` doesn't have ``mode`` and ``format`` arguments which "
"don't apply to an existing block node. See following sections for details "
"and examples."
msgstr ""

#: ../../../interop/live-block-operations.rst:987
msgid "Notes on ``blockdev-backup``"
msgstr ""

#: ../../../interop/live-block-operations.rst:989
msgid ""
"The ``blockdev-backup`` command operates at node-level in a Block Driver "
"State (BDS) graph."
msgstr ""

#: ../../../interop/live-block-operations.rst:992
msgid ""
"E.g. the sequence of actions to create a point-in-time backup of an entire "
"disk image chain, to a target, using ``blockdev-backup`` would be:"
msgstr ""

#: ../../../interop/live-block-operations.rst:1004
msgid ""
"Perform ``blockdev-backup`` (use ``\"sync\": \"full\"`` to copy the entire "
"chain to the target).  And notice the event ``BLOCK_JOB_COMPLETED``"
msgstr ""

#: ../../../interop/live-block-operations.rst:1008
msgid ""
"Shutdown the guest, by issuing the QMP ``quit`` command, so that caches are "
"flushed"
msgstr ""

#: ../../../interop/live-block-operations.rst:1015
msgid ""
"The following section shows an example QMP invocation for ``blockdev-"
"backup``."
msgstr ""

#: ../../../interop/live-block-operations.rst:1019
msgid "QMP invocation for ``blockdev-backup``"
msgstr ""

#: ../../../interop/live-block-operations.rst:1021
msgid ""
"Given a disk image chain of depth 1 where image [B] is the active overlay "
"(live QEMU is writing to it)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1026
msgid ""
"The following is the procedure to copy the content from the entire chain to "
"a target image (say, [E]), which has the full content from [A] and [B]."
msgstr ""

#: ../../../interop/live-block-operations.rst:1030
msgid "Create the overlay [B]::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1044
msgid "Create a target image that will contain the copy::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1048
msgid "Then add it to QEMU via ``blockdev-add``::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1063
msgid ""
"Then invoke ``blockdev-backup`` to copy the contents from the entire image "
"chain, consisting of images [A] and [B] to the target image 'e.qcow2'::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1067
msgid ""
"(QEMU) blockdev-backup device=node-B target=node-E sync=full job-id=job0\n"
"{\n"
"    \"execute\": \"blockdev-backup\",\n"
"    \"arguments\": {\n"
"        \"device\": \"node-B\",\n"
"        \"job-id\": \"job0\",\n"
"        \"target\": \"node-E\",\n"
"        \"sync\": \"full\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:1078
msgid ""
"Once the above 'backup' operation has completed, the event, "
"``BLOCK_JOB_COMPLETED`` will be emitted, signalling successful completion."
msgstr ""

#: ../../../interop/live-block-operations.rst:1082
msgid "Next, query for any active block device jobs (there should be none)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1090
msgid "Shutdown the guest::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1092
msgid ""
"(QEMU) quit\n"
"{\n"
"        \"execute\": \"quit\",\n"
"            \"arguments\": {}\n"
"}\n"
"        \"return\": {}\n"
"}"
msgstr ""

#: ../../../interop/live-block-operations.rst:1101
msgid ""
"The above step is really important; if forgotten, an error, \"Failed to get "
"shared \"write\" lock on e.qcow2\", will be thrown when you do ``qemu-img "
"compare`` to verify the integrity of the disk image with the backup content."
msgstr ""

#: ../../../interop/live-block-operations.rst:1107
msgid ""
"The end result will be the image 'e.qcow2' containing a point-in-time backup "
"of the disk image chain -- i.e. contents from images [A] and [B] at the time "
"the ``blockdev-backup`` command was initiated."
msgstr ""

#: ../../../interop/live-block-operations.rst:1112
msgid ""
"One way to confirm the backup disk image contains the identical content with "
"the disk image chain is to compare the backup and the contents of the chain, "
"you should see \"Images are identical\".  (NB: this is assuming QEMU was "
"launched with ``-S`` option, which will not start the CPUs at guest boot "
"up)::"
msgstr ""

#: ../../../interop/live-block-operations.rst:1118
msgid ""
"$ qemu-img compare b.qcow2 e.qcow2\n"
"Warning: Image size mismatch!\n"
"Images are identical."
msgstr ""

#: ../../../interop/live-block-operations.rst:1122
msgid ""
"NOTE: The \"Warning: Image size mismatch!\" is expected, as we created the "
"target image (e.qcow2) with 39M size."
msgstr ""
