# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 10.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-23 10:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../interop/qcow2.rst:3
msgid "Qcow2 Image File Format"
msgstr ""

#: ../../../interop/qcow2.rst:5
msgid ""
"A ``qcow2`` image file is organized in units of constant size, which are "
"called (host) clusters. A cluster is the unit in which all allocations are "
"done, both for actual guest data and for image metadata."
msgstr ""

#: ../../../interop/qcow2.rst:9
msgid ""
"Likewise, the virtual disk as seen by the guest is divided into (guest) "
"clusters of the same size."
msgstr ""

#: ../../../interop/qcow2.rst:12
msgid "All numbers in qcow2 are stored in Big Endian byte order."
msgstr ""

#: ../../../interop/qcow2.rst:15
msgid "Header"
msgstr ""

#: ../../../interop/qcow2.rst:17
msgid "The first cluster of a qcow2 image contains the file header::"
msgstr ""

#: ../../../interop/qcow2.rst:19
msgid ""
"Byte  0 -  3:   magic\n"
"                QCOW magic string (\"QFI\\xfb\")\n"
"\n"
"      4 -  7:   version\n"
"                Version number (valid values are 2 and 3)\n"
"\n"
"      8 - 15:   backing_file_offset\n"
"                Offset into the image file at which the backing file name\n"
"                is stored (NB: The string is not null terminated). 0 if the\n"
"                image doesn't have a backing file.\n"
"\n"
"                Note: backing files are incompatible with raw external data\n"
"                files (auto-clear feature bit 1).\n"
"\n"
"     16 - 19:   backing_file_size\n"
"                Length of the backing file name in bytes. Must not be\n"
"                longer than 1023 bytes. Undefined if the image doesn't have\n"
"                a backing file.\n"
"\n"
"     20 - 23:   cluster_bits\n"
"                Number of bits that are used for addressing an offset\n"
"                within a cluster (1 << cluster_bits is the cluster size).\n"
"                Must not be less than 9 (i.e. 512 byte clusters).\n"
"\n"
"                Note: QEMU as of today has an implementation limit of 2 MB\n"
"                as the maximum cluster size and won't be able to open "
"images\n"
"                with larger cluster sizes.\n"
"\n"
"                Note: if the image has Extended L2 Entries then "
"cluster_bits\n"
"                must be at least 14 (i.e. 16384 byte clusters).\n"
"\n"
"     24 - 31:   size\n"
"                Virtual disk size in bytes.\n"
"\n"
"                Note: QEMU has an implementation limit of 32 MB as\n"
"                the maximum L1 table size.  With a 2 MB cluster\n"
"                size, it is unable to populate a virtual cluster\n"
"                beyond 2 EB (61 bits); with a 512 byte cluster\n"
"                size, it is unable to populate a virtual size\n"
"                larger than 128 GB (37 bits).  Meanwhile, L1/L2\n"
"                table layouts limit an image to no more than 64 PB\n"
"                (56 bits) of populated clusters, and an image may\n"
"                hit other limits first (such as a file system's\n"
"                maximum size).\n"
"\n"
"     32 - 35:   crypt_method\n"
"                0 for no encryption\n"
"                1 for AES encryption\n"
"                2 for LUKS encryption\n"
"\n"
"     36 - 39:   l1_size\n"
"                Number of entries in the active L1 table\n"
"\n"
"     40 - 47:   l1_table_offset\n"
"                Offset into the image file at which the active L1 table\n"
"                starts. Must be aligned to a cluster boundary.\n"
"\n"
"     48 - 55:   refcount_table_offset\n"
"                Offset into the image file at which the refcount table\n"
"                starts. Must be aligned to a cluster boundary.\n"
"\n"
"     56 - 59:   refcount_table_clusters\n"
"                Number of clusters that the refcount table occupies\n"
"\n"
"     60 - 63:   nb_snapshots\n"
"                Number of snapshots contained in the image\n"
"\n"
"     64 - 71:   snapshots_offset\n"
"                Offset into the image file at which the snapshot table\n"
"                starts. Must be aligned to a cluster boundary."
msgstr ""

#: ../../../interop/qcow2.rst:90
msgid ""
"For version 2, the header is exactly 72 bytes in length, and finishes here. "
"For version 3 or higher, the header length is at least 104 bytes, including "
"the next fields through ``header_length``. ::"
msgstr ""

#: ../../../interop/qcow2.rst:95
msgid ""
" 72 -  79:  incompatible_features\n"
"            Bitmask of incompatible features. An implementation must\n"
"            fail to open an image if an unknown bit is set.\n"
"\n"
"            Bit 0:      Dirty bit.  If this bit is set then refcounts\n"
"                        may be inconsistent, make sure to scan L1/L2\n"
"                        tables to repair refcounts before accessing the\n"
"                        image.\n"
"\n"
"            Bit 1:      Corrupt bit.  If this bit is set then any data\n"
"                        structure may be corrupt and the image must not\n"
"                        be written to (unless for regaining\n"
"                        consistency).\n"
"\n"
"            Bit 2:      External data file bit.  If this bit is set, an\n"
"                        external data file is used. Guest clusters are\n"
"                        then stored in the external data file. For such\n"
"                        images, clusters in the external data file are\n"
"                        not refcounted. The offset field in the\n"
"                        Standard Cluster Descriptor must match the\n"
"                        guest offset and neither compressed clusters\n"
"                        nor internal snapshots are supported.\n"
"\n"
"                        An External Data File Name header extension may\n"
"                        be present if this bit is set.\n"
"\n"
"            Bit 3:      Compression type bit.  If this bit is set,\n"
"                        a non-default compression is used for compressed\n"
"                        clusters. The compression_type field must be\n"
"                        present and not zero.\n"
"\n"
"            Bit 4:      Extended L2 Entries.  If this bit is set then\n"
"                        L2 table entries use an extended format that\n"
"                        allows subcluster-based allocation. See the\n"
"                        Extended L2 Entries section for more details.\n"
"\n"
"            Bits 5-63:  Reserved (set to 0)\n"
"\n"
" 80 -  87:  compatible_features\n"
"            Bitmask of compatible features. An implementation can\n"
"            safely ignore any unknown bits that are set.\n"
"\n"
"            Bit 0:      Lazy refcounts bit.  If this bit is set then\n"
"                        lazy refcount updates can be used.  This means\n"
"                        marking the image file dirty and postponing\n"
"                        refcount metadata updates.\n"
"\n"
"            Bits 1-63:  Reserved (set to 0)\n"
"\n"
" 88 -  95:  autoclear_features\n"
"            Bitmask of auto-clear features. An implementation may only\n"
"            write to an image with unknown auto-clear features if it\n"
"            clears the respective bits from this field first.\n"
"\n"
"            Bit 0:      Bitmaps extension bit\n"
"                        This bit indicates consistency for the bitmaps\n"
"                        extension data.\n"
"\n"
"                        It is an error if this bit is set without the\n"
"                        bitmaps extension present.\n"
"\n"
"                        If the bitmaps extension is present but this\n"
"                        bit is unset, the bitmaps extension data must be\n"
"                        considered inconsistent.\n"
"\n"
"            Bit 1:      Raw external data bit\n"
"                        If this bit is set, the external data file can\n"
"                        be read as a consistent standalone raw image\n"
"                        without looking at the qcow2 metadata.\n"
"\n"
"                        Setting this bit has a performance impact for\n"
"                        some operations on the image (e.g. writing\n"
"                        zeros requires writing to the data file instead\n"
"                        of only setting the zero flag in the L2 table\n"
"                        entry) and conflicts with backing files.\n"
"\n"
"                        This bit may only be set if the External Data\n"
"                        File bit (incompatible feature bit 1) is also\n"
"                        set.\n"
"\n"
"            Bits 2-63:  Reserved (set to 0)\n"
"\n"
" 96 -  99:  refcount_order\n"
"            Describes the width of a reference count block entry (width\n"
"            in bits: refcount_bits = 1 << refcount_order). For version 2\n"
"            images, the order is always assumed to be 4\n"
"            (i.e. refcount_bits = 16).\n"
"            This value may not exceed 6 (i.e. refcount_bits = 64).\n"
"\n"
"100 - 103:  header_length\n"
"            Length of the header structure in bytes. For version 2\n"
"            images, the length is always assumed to be 72 bytes.\n"
"            For version 3 it's at least 104 bytes and must be a multiple\n"
"            of 8."
msgstr ""

#: ../../../interop/qcow2.rst:192
msgid "Additional fields (version 3 and higher)"
msgstr ""

#: ../../../interop/qcow2.rst:194
msgid ""
"In general, these fields are optional and may be safely ignored by the "
"software, as well as filled by zeros (which is equal to field absence), if "
"software needs to set field B, but does not care about field A which "
"precedes B. More formally, additional fields have the following "
"compatibility rules:"
msgstr ""

#: ../../../interop/qcow2.rst:199
msgid ""
"If the value of the additional field must not be ignored for correct "
"handling of the file, it will be accompanied by a corresponding incompatible "
"feature bit."
msgstr ""

#: ../../../interop/qcow2.rst:203
msgid ""
"If there are no unrecognized incompatible feature bits set, an unknown "
"additional field may be safely ignored other than preserving its value when "
"rewriting the image header."
msgstr ""

#: ../../../interop/qcow2.rst:209
msgid ""
"An explicit value of 0 will have the same behavior as when the field is not "
"present*, if not altered by a specific incompatible bit."
msgstr ""

#: ../../../interop/qcow2.rst:212
msgid ""
"(*) A field is considered not present when ``header_length`` is less than or "
"equal to the field's offset. Also, all additional fields are not present for "
"version 2."
msgstr ""

#: ../../../interop/qcow2.rst:218
msgid ""
"104:        compression_type\n"
"\n"
"            Defines the compression method used for compressed clusters.\n"
"            All compressed clusters in an image use the same compression\n"
"            type.\n"
"\n"
"            If the incompatible bit \"Compression type\" is set: the field\n"
"            must be present and non-zero (which means non-deflate\n"
"            compression type). Otherwise, this field must not be present\n"
"            or must be zero (which means deflate).\n"
"\n"
"            Available compression type values:\n"
"               - 0: deflate <https://www.ietf.org/rfc/rfc1951.txt>\n"
"               - 1: zstd <http://github.com/facebook/zstd>\n"
"\n"
"            The deflate compression type is called \"zlib\"\n"
"            <https://www.zlib.net/> in QEMU. However, clusters with the\n"
"            deflate compression type do not have zlib headers.\n"
"\n"
"105 - 111:  Padding, contents defined below."
msgstr ""

#: ../../../interop/qcow2.rst:240
msgid "Header padding"
msgstr ""

#: ../../../interop/qcow2.rst:242
msgid ""
"``header_length`` must be a multiple of 8, which means that if the end of "
"the last additional field is not aligned, some padding is needed. This "
"padding must be zeroed, so that if some existing (or future) additional "
"field will fall into the padding, it will be interpreted accordingly to "
"point `[3.] <#ref_rules_3>`_ of the previous paragraph, i.e.  in the same "
"manner as when this field is not present."
msgstr ""

#: ../../../interop/qcow2.rst:250
msgid "Header extensions"
msgstr ""

#: ../../../interop/qcow2.rst:252
msgid ""
"Directly after the image header, optional sections called header extensions "
"can be stored. Each extension has a structure like the following::"
msgstr ""

#: ../../../interop/qcow2.rst:255
msgid ""
"Byte  0 -  3:   Header extension type:\n"
"                    0x00000000 - End of the header extension area\n"
"                    0xe2792aca - Backing file format name string\n"
"                    0x6803f857 - Feature name table\n"
"                    0x23852875 - Bitmaps extension\n"
"                    0x0537be77 - Full disk encryption header pointer\n"
"                    0x44415441 - External data file name string\n"
"                    other      - Unknown header extension, can be safely\n"
"                                 ignored\n"
"\n"
"      4 -  7:   Length of the header extension data\n"
"\n"
"      8 -  n:   Header extension data\n"
"\n"
"      n -  m:   Padding to round up the header extension size to the next\n"
"                multiple of 8."
msgstr ""

#: ../../../interop/qcow2.rst:272
msgid ""
"Unless stated otherwise, each header extension type shall appear at most "
"once in the same image."
msgstr ""

#: ../../../interop/qcow2.rst:275
msgid ""
"If the image has a backing file then the backing file name should be stored "
"in the remaining space between the end of the header extension area and the "
"end of the first cluster. It is not allowed to store other data here, so "
"that an implementation can safely modify the header and add extensions "
"without harming data of compatible features that it doesn't support. "
"Compatible features that need space for additional data can use a header "
"extension."
msgstr ""

#: ../../../interop/qcow2.rst:284
msgid "String header extensions"
msgstr ""

#: ../../../interop/qcow2.rst:286
msgid ""
"Some header extensions (such as the backing file format name and the "
"external data file name) are just a single string. In this case, the header "
"extension length is the string length and the string is not ``\\0`` "
"terminated. (The header extension padding can make it look like a string is "
"``\\0`` terminated, but neither is padding always necessary nor is there a "
"guarantee that zero bytes are used for padding.)"
msgstr ""

#: ../../../interop/qcow2.rst:295
msgid "Feature name table"
msgstr ""

#: ../../../interop/qcow2.rst:297
msgid ""
"The feature name table is an optional header extension that contains the "
"name for features used by the image. It can be used by applications that "
"don't know the respective feature (e.g. because the feature was introduced "
"only later) to display a useful error message."
msgstr ""

#: ../../../interop/qcow2.rst:302
msgid ""
"The number of entries in the feature name table is determined by the length "
"of the header extension data. Each entry looks like this::"
msgstr ""

#: ../../../interop/qcow2.rst:305
msgid ""
"Byte       0:   Type of feature (select feature bitmap)\n"
"                    0: Incompatible feature\n"
"                    1: Compatible feature\n"
"                    2: Autoclear feature\n"
"\n"
"           1:   Bit number within the selected feature bitmap (valid\n"
"                values: 0-63)\n"
"\n"
"      2 - 47:   Feature name (padded with zeros, but not necessarily null\n"
"                terminated if it has full length)"
msgstr ""

#: ../../../interop/qcow2.rst:318
msgid "Bitmaps extension"
msgstr ""

#: ../../../interop/qcow2.rst:320
msgid ""
"The bitmaps extension is an optional header extension. It provides the "
"ability to store bitmaps related to a virtual disk. For now, there is only "
"one bitmap type: the dirty tracking bitmap, which tracks virtual disk "
"changes from some point in time."
msgstr ""

#: ../../../interop/qcow2.rst:325
msgid ""
"The data of the extension should be considered consistent only if the "
"corresponding auto-clear feature bit is set, see ``autoclear_features`` "
"above."
msgstr ""

#: ../../../interop/qcow2.rst:328
msgid "The fields of the bitmaps extension are::"
msgstr ""

#: ../../../interop/qcow2.rst:330
msgid ""
"Byte  0 -  3:  nb_bitmaps\n"
"               The number of bitmaps contained in the image. Must be\n"
"               greater than or equal to 1.\n"
"\n"
"               Note: QEMU currently only supports up to 65535 bitmaps per\n"
"               image.\n"
"\n"
"      4 -  7:  Reserved, must be zero.\n"
"\n"
"      8 - 15:  bitmap_directory_size\n"
"               Size of the bitmap directory in bytes. It is the cumulative\n"
"               size of all (nb_bitmaps) bitmap directory entries.\n"
"\n"
"     16 - 23:  bitmap_directory_offset\n"
"               Offset into the image file at which the bitmap directory\n"
"               starts. Must be aligned to a cluster boundary."
msgstr ""

#: ../../../interop/qcow2.rst:348
msgid "Full disk encryption header pointer"
msgstr ""

#: ../../../interop/qcow2.rst:350
msgid ""
"The full disk encryption header must be present if, and only if, the "
"``crypt_method`` header requires metadata. Currently this is only true of "
"the ``LUKS`` crypt method. The header extension must be absent for other "
"methods."
msgstr ""

#: ../../../interop/qcow2.rst:355
msgid ""
"This header provides the offset at which the crypt method can store its "
"additional data, as well as the length of such data. ::"
msgstr ""

#: ../../../interop/qcow2.rst:359
msgid ""
"Byte  0 -  7:   Offset into the image file at which the encryption\n"
"                header starts in bytes. Must be aligned to a cluster\n"
"                boundary.\n"
"Byte  8 - 15:   Length of the written encryption header in bytes.\n"
"                Note actual space allocated in the qcow2 file may\n"
"                be larger than this value, since it will be rounded\n"
"                to the nearest multiple of the cluster size. Any\n"
"                unused bytes in the allocated space will be initialized\n"
"                to 0."
msgstr ""

#: ../../../interop/qcow2.rst:369
msgid "For the LUKS crypt method, the encryption header works as follows."
msgstr ""

#: ../../../interop/qcow2.rst:371
msgid ""
"The first 592 bytes of the header clusters will contain the LUKS partition "
"header. This is then followed by the key material data areas. The size of "
"the key material data areas is determined by the number of stripes in the "
"key slot and key size. Refer to the LUKS format specification (``docs/on-"
"disk-format.pdf`` in the cryptsetup source package) for details of the LUKS "
"partition header format."
msgstr ""

#: ../../../interop/qcow2.rst:378
msgid ""
"In the LUKS partition header, the ``payload-offset`` field will be "
"calculated as normal for the LUKS spec. ie the size of the LUKS header, plus "
"key material regions, plus padding, relative to the start of the LUKS "
"header. This offset value is not required to be qcow2 cluster aligned. Its "
"value is currently never used in the context of qcow2, since the qcow2 file "
"format itself defines where the real payload offset is, but none the less a "
"valid payload offset should always be present."
msgstr ""

#: ../../../interop/qcow2.rst:387
msgid ""
"In the LUKS key slots header, the ``key-material-offset`` is relative to the "
"start of the LUKS header clusters in the qcow2 container, not the start of "
"the qcow2 file."
msgstr ""

#: ../../../interop/qcow2.rst:391
msgid "Logically the layout looks like ::"
msgstr ""

#: ../../../interop/qcow2.rst:394
msgid ""
"+-----------------------------+\n"
"| QCow2 header                |\n"
"| QCow2 header extension X    |\n"
"| QCow2 header extension FDE  |\n"
"| QCow2 header extension ...  |\n"
"| QCow2 header extension Z    |\n"
"+-----------------------------+\n"
"| ....other QCow2 tables....  |\n"
".                             .\n"
".                             .\n"
"+-----------------------------+\n"
"| +-------------------------+ |\n"
"| | LUKS partition header   | |\n"
"| +-------------------------+ |\n"
"| | LUKS key material 1     | |\n"
"| +-------------------------+ |\n"
"| | LUKS key material 2     | |\n"
"| +-------------------------+ |\n"
"| | LUKS key material ...   | |\n"
"| +-------------------------+ |\n"
"| | LUKS key material 8     | |\n"
"| +-------------------------+ |\n"
"+-----------------------------+\n"
"| QCow2 cluster payload       |\n"
".                             .\n"
".                             .\n"
".                             .\n"
"|                             |\n"
"+-----------------------------+"
msgstr ""

#: ../../../interop/qcow2.rst:425
msgid "Data encryption"
msgstr ""

#: ../../../interop/qcow2.rst:427
msgid ""
"When an encryption method is requested in the header, the image payload data "
"must be encrypted/decrypted on every write/read. The image headers and "
"metadata are never encrypted."
msgstr ""

#: ../../../interop/qcow2.rst:431
msgid "The algorithms used for encryption vary depending on the method"
msgstr ""

#: ../../../interop/qcow2.rst:433
msgid "``AES``:"
msgstr ""

#: ../../../interop/qcow2.rst:435
msgid "The AES cipher, in CBC mode, with 256 bit keys."
msgstr ""

#: ../../../interop/qcow2.rst:437
msgid ""
"Initialization vectors generated using plain64 method, with the virtual disk "
"sector as the input tweak."
msgstr ""

#: ../../../interop/qcow2.rst:440
msgid ""
"This format is no longer supported in QEMU system emulators, due to a number "
"of design flaws affecting its security. It is only supported in the command "
"line tools for the sake of back compatibility and data liberation."
msgstr ""

#: ../../../interop/qcow2.rst:445
msgid "``LUKS``:"
msgstr ""

#: ../../../interop/qcow2.rst:447
msgid "The algorithms are specified in the LUKS header."
msgstr ""

#: ../../../interop/qcow2.rst:449
msgid ""
"Initialization vectors generated using the method specified in the LUKS "
"header, with the physical disk sector as the input tweak."
msgstr ""

#: ../../../interop/qcow2.rst:454
msgid "Host cluster management"
msgstr ""

#: ../../../interop/qcow2.rst:456
msgid ""
"qcow2 manages the allocation of host clusters by maintaining a reference "
"count for each host cluster. A refcount of 0 means that the cluster is free, "
"1 means that it is used, and >= 2 means that it is used and any write access "
"must perform a COW (copy on write) operation."
msgstr ""

#: ../../../interop/qcow2.rst:461
msgid ""
"The refcounts are managed in a two-level table. The first level is called "
"refcount table and has a variable size (which is stored in the header). The "
"refcount table can cover multiple clusters, however it needs to be "
"contiguous in the image file."
msgstr ""

#: ../../../interop/qcow2.rst:466
msgid ""
"It contains pointers to the second level structures which are called "
"refcount blocks and are exactly one cluster in size."
msgstr ""

#: ../../../interop/qcow2.rst:469
msgid ""
"Although a large enough refcount table can reserve clusters past 64 PB (56 "
"bits) (assuming the underlying protocol can even be sized that large), note "
"that some qcow2 metadata such as L1/L2 tables must point to clusters prior "
"to that point."
msgstr ""

#: ../../../interop/qcow2.rst:475
msgid ""
"QEMU has an implementation limit of 8 MB as the maximum refcount table "
"size.  With a 2 MB cluster size and a default refcount_order of 4, it is "
"unable to reference host resources beyond 2 EB (61 bits); in the worst case, "
"with a 512 cluster size and refcount_order of 6, it is unable to access "
"beyond 32 GB (35 bits)."
msgstr ""

#: ../../../interop/qcow2.rst:481
msgid ""
"Given an offset into the image file, the refcount of its cluster can be "
"obtained as follows::"
msgstr ""

#: ../../../interop/qcow2.rst:484
msgid ""
"refcount_block_entries = (cluster_size * 8 / refcount_bits)\n"
"\n"
"refcount_block_index = (offset / cluster_size) % refcount_block_entries\n"
"refcount_table_index = (offset / cluster_size) / refcount_block_entries\n"
"\n"
"refcount_block = load_cluster(refcount_table[refcount_table_index]);\n"
"return refcount_block[refcount_block_index];"
msgstr ""

#: ../../../interop/qcow2.rst:492
msgid "Refcount table entry::"
msgstr ""

#: ../../../interop/qcow2.rst:494
msgid ""
"Bit  0 -  8:    Reserved (set to 0)\n"
"\n"
"     9 - 63:    Bits 9-63 of the offset into the image file at which the\n"
"                refcount block starts. Must be aligned to a cluster\n"
"                boundary.\n"
"\n"
"                If this is 0, the corresponding refcount block has not yet\n"
"                been allocated. All refcounts managed by this refcount "
"block\n"
"                are 0."
msgstr ""

#: ../../../interop/qcow2.rst:504
msgid "Refcount block entry ``(x = refcount_bits - 1)``::"
msgstr ""

#: ../../../interop/qcow2.rst:506
msgid ""
"Bit  0 -  x:    Reference count of the cluster. If refcount_bits implies a\n"
"                sub-byte width, note that bit 0 means the least significant\n"
"                bit in this context."
msgstr ""

#: ../../../interop/qcow2.rst:512
msgid "Cluster mapping"
msgstr ""

#: ../../../interop/qcow2.rst:514
msgid ""
"Just as for refcounts, qcow2 uses a two-level structure for the mapping of "
"guest clusters to host clusters. They are called L1 and L2 table."
msgstr ""

#: ../../../interop/qcow2.rst:517
msgid ""
"The L1 table has a variable size (stored in the header) and may use multiple "
"clusters, however it must be contiguous in the image file. L2 tables are "
"exactly one cluster in size."
msgstr ""

#: ../../../interop/qcow2.rst:521
msgid ""
"The L1 and L2 tables have implications on the maximum virtual file size; for "
"a given L1 table size, a larger cluster size is required for the guest to "
"have access to more space.  Furthermore, a virtual cluster must currently "
"map to a host offset below 64 PB (56 bits) (although this limit could be "
"relaxed by putting reserved bits into use).  Additionally, as cluster size "
"increases, the maximum host offset for a compressed cluster is reduced (a 2M "
"cluster size requires compressed clusters to reside below 512 TB (49 bits), "
"and this limit cannot be relaxed without an incompatible layout change)."
msgstr ""

#: ../../../interop/qcow2.rst:531
msgid ""
"Given an offset into the virtual disk, the offset into the image file can be "
"obtained as follows::"
msgstr ""

#: ../../../interop/qcow2.rst:534
msgid ""
"l2_entries = (cluster_size / sizeof(uint64_t))        [*]\n"
"\n"
"l2_index = (offset / cluster_size) % l2_entries\n"
"l1_index = (offset / cluster_size) / l2_entries\n"
"\n"
"l2_table = load_cluster(l1_table[l1_index]);\n"
"cluster_offset = l2_table[l2_index];\n"
"\n"
"return cluster_offset + (offset % cluster_size)\n"
"\n"
"[*] this changes if Extended L2 Entries are enabled, see next section"
msgstr ""

#: ../../../interop/qcow2.rst:546
msgid "L1 table entry::"
msgstr ""

#: ../../../interop/qcow2.rst:548
msgid ""
"Bit  0 -  8:    Reserved (set to 0)\n"
"\n"
"     9 - 55:    Bits 9-55 of the offset into the image file at which the L2\n"
"                table starts. Must be aligned to a cluster boundary. If the\n"
"                offset is 0, the L2 table and all clusters described by "
"this\n"
"                L2 table are unallocated.\n"
"\n"
"    56 - 62:    Reserved (set to 0)\n"
"\n"
"         63:    0 for an L2 table that is unused or requires COW, 1 if its\n"
"                refcount is exactly one. This information is only accurate\n"
"                in the active L1 table."
msgstr ""

#: ../../../interop/qcow2.rst:561
msgid "L2 table entry::"
msgstr ""

#: ../../../interop/qcow2.rst:563
msgid ""
"Bit  0 -  61:   Cluster descriptor\n"
"\n"
"          62:   0 for standard clusters\n"
"                1 for compressed clusters\n"
"\n"
"          63:   0 for clusters that are unused, compressed or require COW.\n"
"                1 for standard clusters whose refcount is exactly one.\n"
"                This information is only accurate in L2 tables\n"
"                that are reachable from the active L1 table.\n"
"\n"
"                With external data files, all guest clusters have an\n"
"                implicit refcount of 1 (because of the fixed host = guest\n"
"                mapping for guest cluster offsets), so this bit should be 1\n"
"                for all allocated clusters."
msgstr ""

#: ../../../interop/qcow2.rst:578
msgid "Standard Cluster Descriptor::"
msgstr ""

#: ../../../interop/qcow2.rst:580
msgid ""
"Bit       0:    If set to 1, the cluster reads as all zeros. The host\n"
"                cluster offset can be used to describe a preallocation,\n"
"                but it won't be used for reading data from this cluster,\n"
"                nor is data read from the backing file if the cluster is\n"
"                unallocated.\n"
"\n"
"                With version 2 or with extended L2 entries (see the next\n"
"                section), this is always 0.\n"
"\n"
"     1 -  8:    Reserved (set to 0)\n"
"\n"
"     9 - 55:    Bits 9-55 of host cluster offset. Must be aligned to a\n"
"                cluster boundary. If the offset is 0 and bit 63 is clear,\n"
"                the cluster is unallocated. The offset may only be 0 with\n"
"                bit 63 set (indicating a host cluster offset of 0) when an\n"
"                external data file is used.\n"
"\n"
"    56 - 61:    Reserved (set to 0)"
msgstr ""

#: ../../../interop/qcow2.rst:600
msgid "Compressed Clusters Descriptor ``(x = 62 - (cluster_bits - 8))``::"
msgstr ""

#: ../../../interop/qcow2.rst:602
msgid ""
"Bit  0 - x-1:   Host cluster offset. This is usually _not_ aligned to a\n"
"                cluster or sector boundary!  If cluster_bits is\n"
"                small enough that this field includes bits beyond\n"
"                55, those upper bits must be set to 0.\n"
"\n"
"     x - 61:    Number of additional 512-byte sectors used for the\n"
"                compressed data, beyond the sector containing the offset\n"
"                in the previous field. Some of these sectors may reside\n"
"                in the next contiguous host cluster.\n"
"\n"
"                Note that the compressed data does not necessarily occupy\n"
"                all of the bytes in the final sector; rather, decompression\n"
"                stops when it has produced a cluster of data.\n"
"\n"
"                Another compressed cluster may map to the tail of the final\n"
"                sector used by this compressed cluster."
msgstr ""

#: ../../../interop/qcow2.rst:619
msgid ""
"If a cluster is unallocated, read requests shall read the data from the "
"backing file (except if bit 0 in the Standard Cluster Descriptor is set). If "
"there is no backing file or the backing file is smaller than the image, they "
"shall read zeros for all parts that are not covered by the backing file."
msgstr ""

#: ../../../interop/qcow2.rst:625
msgid "Extended L2 Entries"
msgstr ""

#: ../../../interop/qcow2.rst:627
msgid ""
"An image uses Extended L2 Entries if bit 4 is set on the "
"incompatible_features field of the header."
msgstr ""

#: ../../../interop/qcow2.rst:630
msgid ""
"In these images standard data clusters are divided into 32 subclusters of "
"the same size. They are contiguous and start from the beginning of the "
"cluster. Subclusters can be allocated independently and the L2 entry "
"contains information indicating the status of each one of them. Compressed "
"data clusters don't have subclusters so they are treated the same as in "
"images without this feature."
msgstr ""

#: ../../../interop/qcow2.rst:636
msgid ""
"The size of an extended L2 entry is 128 bits so the number of entries per "
"table is calculated using this formula:"
msgstr ""

#: ../../../interop/qcow2.rst:639
msgid "l2_entries = (cluster_size / (2 * sizeof(uint64_t)))"
msgstr ""

#: ../../../interop/qcow2.rst:643
msgid ""
"The first 64 bits have the same format as the standard L2 table entry "
"described in the previous section, with the exception of bit 0 of the "
"standard cluster descriptor."
msgstr ""

#: ../../../interop/qcow2.rst:647
msgid ""
"The last 64 bits contain a subcluster allocation bitmap with this format:"
msgstr ""

#: ../../../interop/qcow2.rst:649
msgid "Subcluster Allocation Bitmap (for standard clusters)::"
msgstr ""

#: ../../../interop/qcow2.rst:651
msgid ""
"Bit  0 - 31:    Allocation status (one bit per subcluster)\n"
"\n"
"                1: the subcluster is allocated. In this case the\n"
"                   host cluster offset field must contain a valid\n"
"                   offset.\n"
"                0: the subcluster is not allocated. In this case\n"
"                   read requests shall go to the backing file or\n"
"                   return zeros if there is no backing file data.\n"
"\n"
"                Bits are assigned starting from the least significant\n"
"                one (i.e. bit x is used for subcluster x).\n"
"\n"
"    32 - 63     Subcluster reads as zeros (one bit per subcluster)\n"
"\n"
"                1: the subcluster reads as zeros. In this case the\n"
"                   allocation status bit must be unset. The host\n"
"                   cluster offset field may or may not be set.\n"
"                0: no effect.\n"
"\n"
"                Bits are assigned starting from the least significant\n"
"                one (i.e. bit x is used for subcluster x - 32)."
msgstr ""

#: ../../../interop/qcow2.rst:673
msgid "Subcluster Allocation Bitmap (for compressed clusters)::"
msgstr ""

#: ../../../interop/qcow2.rst:675
msgid ""
"Bit  0 - 63:    Reserved (set to 0)\n"
"                Compressed clusters don't have subclusters,\n"
"                so this field is not used."
msgstr ""

#: ../../../interop/qcow2.rst:680
msgid "Snapshots"
msgstr ""

#: ../../../interop/qcow2.rst:682
msgid ""
"qcow2 supports internal snapshots. Their basic principle of operation is to "
"switch the active L1 table, so that a different set of host clusters are "
"exposed to the guest."
msgstr ""

#: ../../../interop/qcow2.rst:686
msgid ""
"When creating a snapshot, the L1 table should be copied and the refcount of "
"all L2 tables and clusters reachable from this L1 table must be increased, "
"so that a write causes a COW and isn't visible in other snapshots."
msgstr ""

#: ../../../interop/qcow2.rst:690
msgid ""
"When loading a snapshot, bit 63 of all entries in the new active L1 table "
"and all L2 tables referenced by it must be reconstructed from the refcount "
"table as it doesn't need to be accurate in inactive L1 tables."
msgstr ""

#: ../../../interop/qcow2.rst:694
msgid ""
"A directory of all snapshots is stored in the snapshot table, a contiguous "
"area in the image file, whose starting offset and length are given by the "
"header fields snapshots_offset and nb_snapshots. The entries of the snapshot "
"table have variable length, depending on the length of ID, name and extra "
"data."
msgstr ""

#: ../../../interop/qcow2.rst:699
msgid "Snapshot table entry::"
msgstr ""

#: ../../../interop/qcow2.rst:701
msgid ""
"Byte 0 -  7:    Offset into the image file at which the L1 table for the\n"
"                snapshot starts. Must be aligned to a cluster boundary.\n"
"\n"
"     8 - 11:    Number of entries in the L1 table of the snapshots\n"
"\n"
"    12 - 13:    Length of the unique ID string describing the snapshot\n"
"\n"
"    14 - 15:    Length of the name of the snapshot\n"
"\n"
"    16 - 19:    Time at which the snapshot was taken in seconds since the\n"
"                Epoch\n"
"\n"
"    20 - 23:    Subsecond part of the time at which the snapshot was taken\n"
"                in nanoseconds\n"
"\n"
"    24 - 31:    Time that the guest was running until the snapshot was\n"
"                taken in nanoseconds\n"
"\n"
"    32 - 35:    Size of the VM state in bytes. 0 if no VM state is saved.\n"
"                If there is VM state, it starts at the first cluster\n"
"                described by first L1 table entry that doesn't describe a\n"
"                regular guest cluster (i.e. VM state is stored like guest\n"
"                disk content, except that it is stored at offsets that are\n"
"                larger than the virtual disk presented to the guest)\n"
"\n"
"    36 - 39:    Size of extra data in the table entry (used for future\n"
"                extensions of the format)\n"
"\n"
"    variable:   Extra data for future extensions. Unknown fields must be\n"
"                ignored. Currently defined are (offset relative to snapshot\n"
"                table entry):\n"
"\n"
"                Byte 40 - 47:   Size of the VM state in bytes. 0 if no VM\n"
"                                state is saved. If this field is present,\n"
"                                the 32-bit value in bytes 32-35 is ignored.\n"
"\n"
"                Byte 48 - 55:   Virtual disk size of the snapshot in bytes\n"
"\n"
"                Byte 56 - 63:   icount value which corresponds to\n"
"                                the record/replay instruction count\n"
"                                when the snapshot was taken. Set to -1\n"
"                                if icount was disabled\n"
"\n"
"                Version 3 images must include extra data at least up to\n"
"                byte 55.\n"
"\n"
"    variable:   Unique ID string for the snapshot (not null terminated)\n"
"\n"
"    variable:   Name of the snapshot (not null terminated)\n"
"\n"
"    variable:   Padding to round up the snapshot table entry size to the\n"
"                next multiple of 8."
msgstr ""

#: ../../../interop/qcow2.rst:756
msgid "Bitmaps"
msgstr ""

#: ../../../interop/qcow2.rst:758
msgid ""
"As mentioned above, the bitmaps extension provides the ability to store "
"bitmaps related to a virtual disk. This section describes how these bitmaps "
"are stored."
msgstr ""

#: ../../../interop/qcow2.rst:761
msgid ""
"All stored bitmaps are related to the virtual disk stored in the same image, "
"so each bitmap size is equal to the virtual disk size."
msgstr ""

#: ../../../interop/qcow2.rst:764
msgid ""
"Each bit of the bitmap is responsible for strictly defined range of the "
"virtual disk. For bit number bit_nr the corresponding range (in bytes) will "
"be:"
msgstr ""

#: ../../../interop/qcow2.rst:767
msgid "[bit_nr * bitmap_granularity .. (bit_nr + 1) * bitmap_granularity - 1]"
msgstr ""

#: ../../../interop/qcow2.rst:771
msgid "Granularity is a property of the concrete bitmap, see below."
msgstr ""

#: ../../../interop/qcow2.rst:775
msgid "Bitmap directory"
msgstr ""

#: ../../../interop/qcow2.rst:777
msgid ""
"Each bitmap saved in the image is described in a bitmap directory entry. The "
"bitmap directory is a contiguous area in the image file, whose starting "
"offset and length are given by the header extension fields "
"``bitmap_directory_offset`` and ``bitmap_directory_size``. The entries of "
"the bitmap directory have variable length, depending on the lengths of the "
"bitmap name and extra data."
msgstr ""

#: ../../../interop/qcow2.rst:783
msgid "Structure of a bitmap directory entry::"
msgstr ""

#: ../../../interop/qcow2.rst:785
msgid ""
"Byte 0 -  7:    bitmap_table_offset\n"
"                Offset into the image file at which the bitmap table\n"
"                (described below) for the bitmap starts. Must be aligned to\n"
"                a cluster boundary.\n"
"\n"
"     8 - 11:    bitmap_table_size\n"
"                Number of entries in the bitmap table of the bitmap.\n"
"\n"
"    12 - 15:    flags\n"
"                Bit\n"
"                  0: in_use\n"
"                     The bitmap was not saved correctly and may be\n"
"                     inconsistent. Although the bitmap metadata is still\n"
"                     well-formed from a qcow2 perspective, the metadata\n"
"                     (such as the auto flag or bitmap size) or data\n"
"                     contents may be outdated.\n"
"\n"
"                  1: auto\n"
"                     The bitmap must reflect all changes of the virtual\n"
"                     disk by any application that would write to this qcow2\n"
"                     file (including writes, snapshot switching, etc.). The\n"
"                     type of this bitmap must be 'dirty tracking bitmap'.\n"
"\n"
"                  2: extra_data_compatible\n"
"                     This flags is meaningful when the extra data is\n"
"                     unknown to the software (currently any extra data is\n"
"                     unknown to QEMU).\n"
"                     If it is set, the bitmap may be used as expected, "
"extra\n"
"                     data must be left as is.\n"
"                     If it is not set, the bitmap must not be used, but\n"
"                     both it and its extra data be left as is.\n"
"\n"
"                Bits 3 - 31 are reserved and must be 0.\n"
"\n"
"         16:    type\n"
"                This field describes the sort of the bitmap.\n"
"                Values:\n"
"                  1: Dirty tracking bitmap\n"
"\n"
"                Values 0, 2 - 255 are reserved.\n"
"\n"
"         17:    granularity_bits\n"
"                Granularity bits. Valid values: 0 - 63.\n"
"\n"
"                Note: QEMU currently supports only values 9 - 31.\n"
"\n"
"                Granularity is calculated as\n"
"                    granularity = 1 << granularity_bits\n"
"\n"
"                A bitmap's granularity is how many bytes of the image\n"
"                accounts for one bit of the bitmap.\n"
"\n"
"    18 - 19:    name_size\n"
"                Size of the bitmap name. Must be non-zero.\n"
"\n"
"                Note: QEMU currently doesn't support values greater than\n"
"                1023.\n"
"\n"
"    20 - 23:    extra_data_size\n"
"                Size of type-specific extra data.\n"
"\n"
"                For now, as no extra data is defined, extra_data_size is\n"
"                reserved and should be zero. If it is non-zero the\n"
"                behavior is defined by extra_data_compatible flag.\n"
"\n"
"    variable:   extra_data\n"
"                Extra data for the bitmap, occupying extra_data_size bytes.\n"
"                Extra data must never contain references to clusters or in\n"
"                some other way allocate additional clusters.\n"
"\n"
"    variable:   name\n"
"                The name of the bitmap (not null terminated), occupying\n"
"                name_size bytes. Must be unique among all bitmap names\n"
"                within the bitmaps extension.\n"
"\n"
"    variable:   Padding to round up the bitmap directory entry size to the\n"
"                next multiple of 8. All bytes of the padding must be zero."
msgstr ""

#: ../../../interop/qcow2.rst:865
msgid "Bitmap table"
msgstr ""

#: ../../../interop/qcow2.rst:867
msgid ""
"Each bitmap is stored using a one-level structure (as opposed to two-level "
"structures like for refcounts and guest clusters mapping) for the mapping of "
"bitmap data to host clusters. This structure is called the bitmap table."
msgstr ""

#: ../../../interop/qcow2.rst:871
msgid ""
"Each bitmap table has a variable size (stored in the bitmap directory entry) "
"and may use multiple clusters, however, it must be contiguous in the image "
"file."
msgstr ""

#: ../../../interop/qcow2.rst:875
msgid "Structure of a bitmap table entry::"
msgstr ""

#: ../../../interop/qcow2.rst:877
msgid ""
"Bit       0:    Reserved and must be zero if bits 9 - 55 are non-zero.\n"
"                If bits 9 - 55 are zero:\n"
"                  0: Cluster should be read as all zeros.\n"
"                  1: Cluster should be read as all ones.\n"
"\n"
"     1 -  8:    Reserved and must be zero.\n"
"\n"
"     9 - 55:    Bits 9 - 55 of the host cluster offset. Must be aligned to\n"
"                a cluster boundary. If the offset is 0, the cluster is\n"
"                unallocated; in that case, bit 0 determines how this\n"
"                cluster should be treated during reads.\n"
"\n"
"    56 - 63:    Reserved and must be zero."
msgstr ""

#: ../../../interop/qcow2.rst:893
msgid "Bitmap data"
msgstr ""

#: ../../../interop/qcow2.rst:895
msgid ""
"As noted above, bitmap data is stored in separate clusters, described by the "
"bitmap table. Given an offset (in bytes) into the bitmap data, the offset "
"into the image file can be obtained as follows::"
msgstr ""

#: ../../../interop/qcow2.rst:899
msgid ""
"image_offset(bitmap_data_offset) =\n"
"    bitmap_table[bitmap_data_offset / cluster_size] +\n"
"        (bitmap_data_offset % cluster_size)"
msgstr ""

#: ../../../interop/qcow2.rst:903
msgid ""
"This offset is not defined if bits 9 - 55 of bitmap table entry are zero "
"(see above)."
msgstr ""

#: ../../../interop/qcow2.rst:906
msgid ""
"Given an offset byte_nr into the virtual disk and the bitmap's granularity, "
"the bit offset into the image file to the corresponding bit of the bitmap "
"can be calculated like this::"
msgstr ""

#: ../../../interop/qcow2.rst:910
msgid ""
"bit_offset(byte_nr) =\n"
"    image_offset(byte_nr / granularity / 8) * 8 +\n"
"        (byte_nr / granularity) % 8"
msgstr ""

#: ../../../interop/qcow2.rst:914
msgid ""
"If the size of the bitmap data is not a multiple of the cluster size then "
"the last cluster of the bitmap data contains some unused tail bits. These "
"bits must be zero."
msgstr ""

#: ../../../interop/qcow2.rst:920
msgid "Dirty tracking bitmaps"
msgstr ""

#: ../../../interop/qcow2.rst:922
msgid "Bitmaps with ``type`` field equal to one are dirty tracking bitmaps."
msgstr ""

#: ../../../interop/qcow2.rst:924
msgid ""
"When the virtual disk is in use dirty tracking bitmap may be ``enabled`` or "
"``disabled``. While the bitmap is ``enabled``, all writes to the virtual "
"disk should be reflected in the bitmap. A set bit in the bitmap means that "
"the corresponding range of the virtual disk (see above) was written to while "
"the bitmap was ``enabled``. An unset bit means that this range was not "
"written to."
msgstr ""

#: ../../../interop/qcow2.rst:930
msgid ""
"The software doesn't have to sync the bitmap in the image file with its "
"representation in RAM after each write or metadata change. Flag ``in_use`` "
"should be set while the bitmap is not synced."
msgstr ""

#: ../../../interop/qcow2.rst:934
msgid ""
"In the image file the ``enabled`` state is reflected by the ``auto`` flag. "
"If this flag is set, the software must consider the bitmap as ``enabled`` "
"and start tracking virtual disk changes to this bitmap from the first write "
"to the virtual disk. If this flag is not set then the bitmap is disabled."
msgstr ""
