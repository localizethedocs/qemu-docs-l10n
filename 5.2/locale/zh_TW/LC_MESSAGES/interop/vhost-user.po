# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../interop/vhost-user.rst:3
msgid "Vhost-user Protocol"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "Copyright"
msgstr ""

#: ../../../interop/vhost-user.rst:4
msgid "2014 Virtual Open Systems Sarl."
msgstr ""

#: ../../../interop/vhost-user.rst:5
msgid "2019 Intel Corporation"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "Licence"
msgstr ""

#: ../../../interop/vhost-user.rst:6
msgid ""
"This work is licensed under the terms of the GNU GPL, version 2 or later. "
"See the COPYING file in the top-level directory."
msgstr ""

#: ../../../interop/vhost-user.rst:10
msgid "Table of Contents"
msgstr ""

#: ../../../interop/vhost-user.rst:13
msgid "Introduction"
msgstr ""

#: ../../../interop/vhost-user.rst:15
msgid ""
"This protocol is aiming to complement the ``ioctl`` interface used to "
"control the vhost implementation in the Linux kernel. It implements the "
"control plane needed to establish virtqueue sharing with a user space "
"process on the same host. It uses communication over a Unix domain socket to "
"share file descriptors in the ancillary data of the message."
msgstr ""

#: ../../../interop/vhost-user.rst:22
msgid ""
"The protocol defines 2 sides of the communication, *master* and *slave*. "
"*Master* is the application that shares its virtqueues, in our case QEMU. "
"*Slave* is the consumer of the virtqueues."
msgstr ""

#: ../../../interop/vhost-user.rst:26
msgid ""
"In the current implementation QEMU is the *master*, and the *slave* is the "
"external process consuming the virtio queues, for example a software "
"Ethernet switch running in user space, such as Snabbswitch, or a block "
"device backend processing read & write to a virtual disk. In order to "
"facilitate interoperability between various backend implementations, it is "
"recommended to follow the :ref:`Backend program conventions "
"<backend_conventions>`."
msgstr ""

#: ../../../interop/vhost-user.rst:34
msgid ""
"*Master* and *slave* can be either a client (i.e. connecting) or server "
"(listening) in the socket communication."
msgstr ""

#: ../../../interop/vhost-user.rst:38
msgid "Message Specification"
msgstr ""

#: ../../../interop/vhost-user.rst:40
msgid "All numbers are in the machine native byte order."
msgstr ""

#: ../../../interop/vhost-user.rst:42
msgid "A vhost-user message consists of 3 header fields and a payload."
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:45
msgid "request"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:45
#: ../../../interop/vhost-user.rst:91 ../../../interop/vhost-user.rst:193
msgid "flags"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:45
#: ../../../interop/vhost-user.rst:91 ../../../interop/vhost-user.rst:123
#: ../../../interop/vhost-user.rst:138 ../../../interop/vhost-user.rst:168
#: ../../../interop/vhost-user.rst:193 ../../../interop/vhost-user.rst:211
msgid "size"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:45
#: ../../../interop/vhost-user.rst:193
msgid "payload"
msgstr ""

#: ../../../interop/vhost-user.rst:49
msgid "Header"
msgstr ""

#: ../../../interop/vhost-user.rst:51
msgid "32-bit type of the request"
msgstr ""

#: ../../../interop/vhost-user.rst:53
msgid "32-bit bit field"
msgstr ""

#: ../../../interop/vhost-user.rst:55
msgid "Lower 2 bits are the version (currently 0x01)"
msgstr ""

#: ../../../interop/vhost-user.rst:56
msgid "Bit 2 is the reply flag - needs to be sent on each reply from the slave"
msgstr ""

#: ../../../interop/vhost-user.rst:57
msgid ""
"Bit 3 is the need_reply flag - see :ref:`REPLY_ACK <reply_ack>` for details."
msgstr ""

#: ../../../interop/vhost-user.rst:60
msgid "32-bit size of the payload"
msgstr ""

#: ../../../interop/vhost-user.rst:63
msgid "Payload"
msgstr ""

#: ../../../interop/vhost-user.rst:65
msgid "Depending on the request type, **payload** can be:"
msgstr ""

#: ../../../interop/vhost-user.rst:68
msgid "A single 64-bit integer"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:71
#: ../../../interop/vhost-user.rst:211 ../../../interop/vhost-user.rst:940
#: ../../../interop/vhost-user.rst:1044 ../../../interop/vhost-user.rst:1288
msgid "u64"
msgstr ""

#: ../../../interop/vhost-user.rst:74
msgid "a 64-bit unsigned integer"
msgstr ""

#: ../../../interop/vhost-user.rst:77
msgid "A vring state description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:80
#: ../../../interop/vhost-user.rst:91
msgid "index"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:80
msgid "num"
msgstr ""

#: ../../../interop/vhost-user.rst:83
msgid "a 32-bit index"
msgstr ""

#: ../../../interop/vhost-user.rst:85
msgid "a 32-bit number"
msgstr ""

#: ../../../interop/vhost-user.rst:88
msgid "A vring address description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:91
msgid "descriptor"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:91
msgid "used"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:91
msgid "available"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:91
msgid "log"
msgstr ""

#: ../../../interop/vhost-user.rst:94
msgid "a 32-bit vring index"
msgstr ""

#: ../../../interop/vhost-user.rst:96
msgid "a 32-bit vring flags"
msgstr ""

#: ../../../interop/vhost-user.rst:98
msgid "a 64-bit ring address of the vring descriptor table"
msgstr ""

#: ../../../interop/vhost-user.rst:100
msgid "a 64-bit ring address of the vring used ring"
msgstr ""

#: ../../../interop/vhost-user.rst:102
msgid "a 64-bit ring address of the vring available ring"
msgstr ""

#: ../../../interop/vhost-user.rst:104
msgid "a 64-bit guest address for logging"
msgstr ""

#: ../../../interop/vhost-user.rst:106
msgid ""
"Note that a ring address is an IOVA if ``VIRTIO_F_IOMMU_PLATFORM`` has been "
"negotiated. Otherwise it is a user address."
msgstr ""

#: ../../../interop/vhost-user.rst:110
msgid "Memory regions description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:113
msgid "num regions"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:113
#: ../../../interop/vhost-user.rst:138
msgid "padding"
msgstr ""

#: ../../../interop/vhost-user.rst:113
msgid "region0"
msgstr ""

#: ../../../interop/vhost-user.rst:113 ../../../interop/vhost-user.rst:542
msgid "..."
msgstr ""

#: ../../../interop/vhost-user.rst:113
msgid "region7"
msgstr ""

#: ../../../interop/vhost-user.rst:116
msgid "a 32-bit number of regions"
msgstr ""

#: ../../../interop/vhost-user.rst:118
msgid "32-bit"
msgstr ""

#: ../../../interop/vhost-user.rst:120
msgid "A region is:"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:123
#: ../../../interop/vhost-user.rst:138
msgid "guest address"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:123
#: ../../../interop/vhost-user.rst:138 ../../../interop/vhost-user.rst:168
msgid "user address"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:123
#: ../../../interop/vhost-user.rst:138 ../../../interop/vhost-user.rst:225
msgid "mmap offset"
msgstr ""

#: ../../../interop/vhost-user.rst:126 ../../../interop/vhost-user.rst:143
msgid "a 64-bit guest address of the region"
msgstr ""

#: ../../../interop/vhost-user.rst:128 ../../../interop/vhost-user.rst:145
#: ../../../interop/vhost-user.rst:173
msgid "a 64-bit size"
msgstr ""

#: ../../../interop/vhost-user.rst:130 ../../../interop/vhost-user.rst:147
#: ../../../interop/vhost-user.rst:175
msgid "a 64-bit user address"
msgstr ""

#: ../../../interop/vhost-user.rst:132 ../../../interop/vhost-user.rst:149
msgid "64-bit offset where region starts in the mapped memory"
msgstr ""

#: ../../../interop/vhost-user.rst:135
msgid "Single memory region description"
msgstr ""

#: ../../../interop/vhost-user.rst:141
msgid "64-bit"
msgstr ""

#: ../../../interop/vhost-user.rst:152
msgid "Log description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:155
msgid "log size"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:155
msgid "log offset"
msgstr ""

#: ../../../interop/vhost-user.rst:158
msgid "size of area used for logging"
msgstr ""

#: ../../../interop/vhost-user.rst:160
msgid ""
"offset from start of supplied file descriptor where logging starts (i.e. "
"where guest address 0 would be logged)"
msgstr ""

#: ../../../interop/vhost-user.rst:165
msgid "An IOTLB message"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:168
msgid "iova"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:168
msgid "permissions flags"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:168
msgid "type"
msgstr ""

#: ../../../interop/vhost-user.rst:171
msgid "a 64-bit I/O virtual address programmed by the guest"
msgstr ""

#: ../../../interop/vhost-user.rst:177
msgid ""
"an 8-bit value: - 0: No access - 1: Read access - 2: Write access - 3: Read/"
"Write access"
msgstr ""

#: ../../../interop/vhost-user.rst:183
msgid ""
"an 8-bit IOTLB message type: - 1: IOTLB miss - 2: IOTLB update - 3: IOTLB "
"invalidate - 4: IOTLB access fail"
msgstr ""

#: ../../../interop/vhost-user.rst:190
msgid "Virtio device config space"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:193
#: ../../../interop/vhost-user.rst:211
msgid "offset"
msgstr ""

#: ../../../interop/vhost-user.rst:196
msgid "a 32-bit offset of virtio device's configuration space"
msgstr ""

#: ../../../interop/vhost-user.rst:198
msgid "a 32-bit configuration space access size in bytes"
msgstr ""

#: ../../../interop/vhost-user.rst:200
msgid ""
"a 32-bit value: - 0: Vhost master messages used for writeable fields - 1: "
"Vhost master messages used for live migration"
msgstr ""

#: ../../../interop/vhost-user.rst:204
msgid ""
"Size bytes array holding the contents of the virtio device's configuration "
"space"
msgstr ""

#: ../../../interop/vhost-user.rst:208
msgid "Vring area description"
msgstr ""

#: ../../../interop/vhost-user.rst:214
msgid "a 64-bit integer contains vring index and flags"
msgstr ""

#: ../../../interop/vhost-user.rst:216
msgid "a 64-bit size of this area"
msgstr ""

#: ../../../interop/vhost-user.rst:218 ../../../interop/vhost-user.rst:230
msgid ""
"a 64-bit offset of this area from the start of the supplied file descriptor"
msgstr ""

#: ../../../interop/vhost-user.rst:222
msgid "Inflight description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:225
msgid "mmap size"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:225
msgid "num queues"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:225
msgid "queue size"
msgstr ""

#: ../../../interop/vhost-user.rst:228
msgid "a 64-bit size of area to track inflight I/O"
msgstr ""

#: ../../../interop/vhost-user.rst:233
msgid "a 16-bit number of virtqueues"
msgstr ""

#: ../../../interop/vhost-user.rst:235
msgid "a 16-bit size of virtqueues"
msgstr ""

#: ../../../interop/vhost-user.rst:238
msgid "C structure"
msgstr ""

#: ../../../interop/vhost-user.rst:240
msgid ""
"In QEMU the vhost-user message is implemented with the following struct:"
msgstr ""

#: ../../../interop/vhost-user.rst:242
msgid ""
"typedef struct VhostUserMsg {\n"
"    VhostUserRequest request;\n"
"    uint32_t flags;\n"
"    uint32_t size;\n"
"    union {\n"
"        uint64_t u64;\n"
"        struct vhost_vring_state state;\n"
"        struct vhost_vring_addr addr;\n"
"        VhostUserMemory memory;\n"
"        VhostUserLog log;\n"
"        struct vhost_iotlb_msg iotlb;\n"
"        VhostUserConfig config;\n"
"        VhostUserVringArea area;\n"
"        VhostUserInflight inflight;\n"
"    };\n"
"} QEMU_PACKED VhostUserMsg;"
msgstr ""

#: ../../../interop/vhost-user.rst:262
msgid "Communication"
msgstr ""

#: ../../../interop/vhost-user.rst:264
msgid ""
"The protocol for vhost-user is based on the existing implementation of vhost "
"for the Linux Kernel. Most messages that can be sent via the Unix domain "
"socket implementing vhost-user have an equivalent ioctl to the kernel "
"implementation."
msgstr ""

#: ../../../interop/vhost-user.rst:269
msgid ""
"The communication consists of *master* sending message requests and *slave* "
"sending message replies. Most of the requests don't require replies. Here is "
"a list of the ones that do:"
msgstr ""

#: ../../../interop/vhost-user.rst:273 ../../../interop/vhost-user.rst:841
msgid "``VHOST_USER_GET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:274 ../../../interop/vhost-user.rst:862
msgid "``VHOST_USER_GET_PROTOCOL_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:275 ../../../interop/vhost-user.rst:979
#: ../../../interop/vhost-user.rst:981
msgid "``VHOST_USER_GET_VRING_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:276 ../../../interop/vhost-user.rst:288
msgid "``VHOST_USER_SET_LOG_BASE`` (if ``VHOST_USER_PROTOCOL_F_LOG_SHMFD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:277
msgid ""
"``VHOST_USER_GET_INFLIGHT_FD`` (if ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:281
msgid ":ref:`REPLY_ACK <reply_ack>`"
msgstr ""

#: ../../../interop/vhost-user.rst:282
msgid "The section on ``REPLY_ACK`` protocol extension."
msgstr ""

#: ../../../interop/vhost-user.rst:284
msgid ""
"There are several messages that the master sends with file descriptors "
"passed in the ancillary data:"
msgstr ""

#: ../../../interop/vhost-user.rst:287 ../../../interop/vhost-user.rst:913
msgid "``VHOST_USER_SET_MEM_TABLE``"
msgstr ""

#: ../../../interop/vhost-user.rst:289 ../../../interop/vhost-user.rst:950
msgid "``VHOST_USER_SET_LOG_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:290 ../../../interop/vhost-user.rst:987
msgid "``VHOST_USER_SET_VRING_KICK``"
msgstr ""

#: ../../../interop/vhost-user.rst:291 ../../../interop/vhost-user.rst:1005
msgid "``VHOST_USER_SET_VRING_CALL``"
msgstr ""

#: ../../../interop/vhost-user.rst:292 ../../../interop/vhost-user.rst:1023
msgid "``VHOST_USER_SET_VRING_ERR``"
msgstr ""

#: ../../../interop/vhost-user.rst:293 ../../../interop/vhost-user.rst:1094
msgid "``VHOST_USER_SET_SLAVE_REQ_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:294
msgid ""
"``VHOST_USER_SET_INFLIGHT_FD`` (if ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:296
msgid ""
"If *master* is unable to send the full message or receives a wrong reply it "
"will close the connection. An optional reconnection mechanism can be "
"implemented."
msgstr ""

#: ../../../interop/vhost-user.rst:300
msgid ""
"If *slave* detects some error such as incompatible features, it may also "
"close the connection. This should only happen in exceptional circumstances."
msgstr ""

#: ../../../interop/vhost-user.rst:303
msgid ""
"Any protocol extensions are gated by protocol feature bits, which allows "
"full backwards compatibility on both master and slave.  As older slaves "
"don't support negotiating protocol features, a feature bit was dedicated for "
"this purpose::"
msgstr ""

#: ../../../interop/vhost-user.rst:308
msgid "#define VHOST_USER_F_PROTOCOL_FEATURES 30"
msgstr ""

#: ../../../interop/vhost-user.rst:311
msgid "Starting and stopping rings"
msgstr ""

#: ../../../interop/vhost-user.rst:313
msgid "Client must only process each ring when it is started."
msgstr ""

#: ../../../interop/vhost-user.rst:315
msgid ""
"Client must only pass data between the ring and the backend, when the ring "
"is enabled."
msgstr ""

#: ../../../interop/vhost-user.rst:318
msgid ""
"If ring is started but disabled, client must process the ring without "
"talking to the backend."
msgstr ""

#: ../../../interop/vhost-user.rst:321
msgid ""
"For example, for a networking device, in the disabled state client must not "
"supply any new RX packets, but must process and discard any TX packets."
msgstr ""

#: ../../../interop/vhost-user.rst:325
msgid ""
"If ``VHOST_USER_F_PROTOCOL_FEATURES`` has not been negotiated, the ring is "
"initialized in an enabled state."
msgstr ""

#: ../../../interop/vhost-user.rst:328
msgid ""
"If ``VHOST_USER_F_PROTOCOL_FEATURES`` has been negotiated, the ring is "
"initialized in a disabled state. Client must not pass data to/from the "
"backend until ring is enabled by ``VHOST_USER_SET_VRING_ENABLE`` with "
"parameter 1, or after it has been disabled by "
"``VHOST_USER_SET_VRING_ENABLE`` with parameter 0."
msgstr ""

#: ../../../interop/vhost-user.rst:334
msgid ""
"Each ring is initialized in a stopped state, client must not process it "
"until ring is started, or after it has been stopped."
msgstr ""

#: ../../../interop/vhost-user.rst:337
msgid ""
"Client must start ring upon receiving a kick (that is, detecting that file "
"descriptor is readable) on the descriptor specified by "
"``VHOST_USER_SET_VRING_KICK`` or receiving the in-band message "
"``VHOST_USER_VRING_KICK`` if negotiated, and stop ring upon receiving "
"``VHOST_USER_GET_VRING_BASE``."
msgstr ""

#: ../../../interop/vhost-user.rst:343
msgid ""
"While processing the rings (whether they are enabled or not), client must "
"support changing some configuration aspects on the fly."
msgstr ""

#: ../../../interop/vhost-user.rst:347
msgid "Multiple queue support"
msgstr ""

#: ../../../interop/vhost-user.rst:349
msgid ""
"Many devices have a fixed number of virtqueues.  In this case the master "
"already knows the number of available virtqueues without communicating with "
"the slave."
msgstr ""

#: ../../../interop/vhost-user.rst:353
msgid ""
"Some devices do not have a fixed number of virtqueues.  Instead the maximum "
"number of virtqueues is chosen by the slave.  The number can depend on host "
"resource availability or slave implementation details.  Such devices are "
"called multiple queue devices."
msgstr ""

#: ../../../interop/vhost-user.rst:358
msgid ""
"Multiple queue support allows the slave to advertise the maximum number of "
"queues.  This is treated as a protocol extension, hence the slave has to "
"implement protocol features first. The multiple queues feature is supported "
"only when the protocol feature ``VHOST_USER_PROTOCOL_F_MQ`` (bit 0) is set."
msgstr ""

#: ../../../interop/vhost-user.rst:363
msgid ""
"The max number of queues the slave supports can be queried with message "
"``VHOST_USER_GET_QUEUE_NUM``. Master should stop when the number of "
"requested queues is bigger than that."
msgstr ""

#: ../../../interop/vhost-user.rst:367
msgid ""
"As all queues share one connection, the master uses a unique index for each "
"queue in the sent message to identify a specified queue."
msgstr ""

#: ../../../interop/vhost-user.rst:370
msgid ""
"The master enables queues by sending message "
"``VHOST_USER_SET_VRING_ENABLE``. vhost-user-net has historically "
"automatically enabled the first queue pair."
msgstr ""

#: ../../../interop/vhost-user.rst:373
msgid ""
"Slaves should always implement the ``VHOST_USER_PROTOCOL_F_MQ`` protocol "
"feature, even for devices with a fixed number of virtqueues, since it is "
"simple to implement and offers a degree of introspection."
msgstr ""

#: ../../../interop/vhost-user.rst:377
msgid ""
"Masters must not rely on the ``VHOST_USER_PROTOCOL_F_MQ`` protocol feature "
"for devices with a fixed number of virtqueues.  Only true multiqueue devices "
"require this protocol feature."
msgstr ""

#: ../../../interop/vhost-user.rst:382
msgid "Migration"
msgstr ""

#: ../../../interop/vhost-user.rst:384
msgid ""
"During live migration, the master may need to track the modifications the "
"slave makes to the memory mapped regions. The client should mark the dirty "
"pages in a log. Once it complies to this logging, it may declare the "
"``VHOST_F_LOG_ALL`` vhost feature."
msgstr ""

#: ../../../interop/vhost-user.rst:389
msgid ""
"To start/stop logging of data/used ring writes, server may send messages "
"``VHOST_USER_SET_FEATURES`` with ``VHOST_F_LOG_ALL`` and "
"``VHOST_USER_SET_VRING_ADDR`` with ``VHOST_VRING_F_LOG`` in ring's flags set "
"to 1/0, respectively."
msgstr ""

#: ../../../interop/vhost-user.rst:394
msgid ""
"All the modifications to memory pointed by vring \"descriptor\" should be "
"marked. Modifications to \"used\" vring should be marked if "
"``VHOST_VRING_F_LOG`` is part of ring's flags."
msgstr ""

#: ../../../interop/vhost-user.rst:398
msgid "Dirty pages are of size::"
msgstr ""

#: ../../../interop/vhost-user.rst:400
msgid "#define VHOST_LOG_PAGE 0x1000"
msgstr ""

#: ../../../interop/vhost-user.rst:402
msgid ""
"The log memory fd is provided in the ancillary data of "
"``VHOST_USER_SET_LOG_BASE`` message when the slave has "
"``VHOST_USER_PROTOCOL_F_LOG_SHMFD`` protocol feature."
msgstr ""

#: ../../../interop/vhost-user.rst:406
msgid ""
"The size of the log is supplied as part of ``VhostUserMsg`` which should be "
"large enough to cover all known guest addresses. Log starts at the supplied "
"offset in the supplied file descriptor.  The log covers from address 0 to "
"the maximum of guest regions. In pseudo-code, to mark page at ``addr`` as "
"dirty::"
msgstr ""

#: ../../../interop/vhost-user.rst:412
msgid ""
"page = addr / VHOST_LOG_PAGE\n"
"log[page / 8] |= 1 << page % 8"
msgstr ""

#: ../../../interop/vhost-user.rst:415
msgid "Where ``addr`` is the guest physical address."
msgstr ""

#: ../../../interop/vhost-user.rst:417
msgid "Use atomic operations, as the log may be concurrently manipulated."
msgstr ""

#: ../../../interop/vhost-user.rst:419
msgid ""
"Note that when logging modifications to the used ring (when "
"``VHOST_VRING_F_LOG`` is set for this ring), ``log_guest_addr`` should be "
"used to calculate the log offset: the write to first byte of the used ring "
"is logged at this offset from log start. Also note that this value might be "
"outside the legal guest physical address range (i.e. does not have to be "
"covered by the ``VhostUserMemory`` table), but the bit offset of the last "
"byte of the ring must fall within the size supplied by ``VhostUserLog``."
msgstr ""

#: ../../../interop/vhost-user.rst:428
msgid ""
"``VHOST_USER_SET_LOG_FD`` is an optional message with an eventfd in "
"ancillary data, it may be used to inform the master that the log has been "
"modified."
msgstr ""

#: ../../../interop/vhost-user.rst:432
msgid ""
"Once the source has finished migration, rings will be stopped by the source. "
"No further update must be done before rings are restarted."
msgstr ""

#: ../../../interop/vhost-user.rst:435
msgid ""
"In postcopy migration the slave is started before all the memory has been "
"received from the source host, and care must be taken to avoid accessing "
"pages that have yet to be received.  The slave opens a 'userfault'-fd and "
"registers the memory with it; this fd is then passed back over to the "
"master.  The master services requests on the userfaultfd for pages that are "
"accessed and when the page is available it performs WAKE ioctl's on the "
"userfaultfd to wake the stalled slave.  The client indicates support for "
"this via the ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` feature."
msgstr ""

#: ../../../interop/vhost-user.rst:446
msgid "Memory access"
msgstr ""

#: ../../../interop/vhost-user.rst:448
msgid ""
"The master sends a list of vhost memory regions to the slave using the "
"``VHOST_USER_SET_MEM_TABLE`` message.  Each region has two base addresses: a "
"guest address and a user address."
msgstr ""

#: ../../../interop/vhost-user.rst:452
msgid ""
"Messages contain guest addresses and/or user addresses to reference "
"locations within the shared memory.  The mapping of these addresses works as "
"follows."
msgstr ""

#: ../../../interop/vhost-user.rst:455
msgid ""
"User addresses map to the vhost memory region containing that user address."
msgstr ""

#: ../../../interop/vhost-user.rst:457
msgid "When the ``VIRTIO_F_IOMMU_PLATFORM`` feature has not been negotiated:"
msgstr ""

#: ../../../interop/vhost-user.rst:459
msgid ""
"Guest addresses map to the vhost memory region containing that guest address."
msgstr ""

#: ../../../interop/vhost-user.rst:462
msgid "When the ``VIRTIO_F_IOMMU_PLATFORM`` feature has been negotiated:"
msgstr ""

#: ../../../interop/vhost-user.rst:464
msgid ""
"Guest addresses are also called I/O virtual addresses (IOVAs).  They are "
"translated to user addresses via the IOTLB."
msgstr ""

#: ../../../interop/vhost-user.rst:467
msgid "The vhost memory region guest address is not used."
msgstr ""

#: ../../../interop/vhost-user.rst:470
msgid "IOMMU support"
msgstr ""

#: ../../../interop/vhost-user.rst:472
msgid ""
"When the ``VIRTIO_F_IOMMU_PLATFORM`` feature has been negotiated, the master "
"sends IOTLB entries update & invalidation by sending "
"``VHOST_USER_IOTLB_MSG`` requests to the slave with a ``struct "
"vhost_iotlb_msg`` as payload. For update events, the ``iotlb`` payload has "
"to be filled with the update message type (2), the I/O virtual address, the "
"size, the user virtual address, and the permissions flags. Addresses and "
"size must be within vhost memory regions set via the "
"``VHOST_USER_SET_MEM_TABLE`` request. For invalidation events, the ``iotlb`` "
"payload has to be filled with the invalidation message type (3), the I/O "
"virtual address and the size. On success, the slave is expected to reply "
"with a zero payload, non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:484
msgid ""
"The slave relies on the slave communication channel (see :ref:`Slave "
"communication <slave_communication>` section below) to send IOTLB miss and "
"access failure events, by sending ``VHOST_USER_SLAVE_IOTLB_MSG`` requests to "
"the master with a ``struct vhost_iotlb_msg`` as payload. For miss events, "
"the iotlb payload has to be filled with the miss message type (1), the I/O "
"virtual address and the permissions flags. For access failure event, the "
"iotlb payload has to be filled with the access failure message type (4), the "
"I/O virtual address and the permissions flags.  For synchronization purpose, "
"the slave may rely on the reply-ack feature, so the master may send a reply "
"when operation is completed if the reply-ack feature is negotiated and "
"slaves requests a reply. For miss events, completed operation means either "
"master sent an update message containing the IOTLB entry containing "
"requested address and permission, or master sent nothing if the IOTLB miss "
"message is invalid (invalid IOVA or permission)."
msgstr ""

#: ../../../interop/vhost-user.rst:500
msgid ""
"The master isn't expected to take the initiative to send IOTLB update "
"messages, as the slave sends IOTLB miss messages for the guest virtual "
"memory areas it needs to access."
msgstr ""

#: ../../../interop/vhost-user.rst:507
msgid "Slave communication"
msgstr ""

#: ../../../interop/vhost-user.rst:509
msgid ""
"An optional communication channel is provided if the slave declares "
"``VHOST_USER_PROTOCOL_F_SLAVE_REQ`` protocol feature, to allow the slave to "
"make requests to the master."
msgstr ""

#: ../../../interop/vhost-user.rst:513
msgid "The fd is provided via ``VHOST_USER_SET_SLAVE_REQ_FD`` ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:515
msgid ""
"A slave may then send ``VHOST_USER_SLAVE_*`` messages to the master using "
"this fd communication channel."
msgstr ""

#: ../../../interop/vhost-user.rst:518
msgid ""
"If ``VHOST_USER_PROTOCOL_F_SLAVE_SEND_FD`` protocol feature is negotiated, "
"slave can send file descriptors (at most 8 descriptors in each message) to "
"master via ancillary data using this fd communication channel."
msgstr ""

#: ../../../interop/vhost-user.rst:524
msgid "Inflight I/O tracking"
msgstr ""

#: ../../../interop/vhost-user.rst:526
msgid ""
"To support reconnecting after restart or crash, slave may need to resubmit "
"inflight I/Os. If virtqueue is processed in order, we can easily achieve "
"that by getting the inflight descriptors from descriptor table (split "
"virtqueue) or descriptor ring (packed virtqueue). However, it can't work "
"when we process descriptors out-of-order because some entries which store "
"the information of inflight descriptors in available ring (split virtqueue) "
"or descriptor ring (packed virtqueue) might be overridden by new entries. To "
"solve this problem, slave need to allocate an extra buffer to store this "
"information of inflight descriptors and share it with master for persistent. "
"``VHOST_USER_GET_INFLIGHT_FD`` and ``VHOST_USER_SET_INFLIGHT_FD`` are used "
"to transfer this buffer between master and slave. And the format of this "
"buffer is described below:"
msgstr ""

#: ../../../interop/vhost-user.rst:542
msgid "queue0 region"
msgstr ""

#: ../../../interop/vhost-user.rst:542
msgid "queue1 region"
msgstr ""

#: ../../../interop/vhost-user.rst:542
msgid "queueN region"
msgstr ""

#: ../../../interop/vhost-user.rst:545
msgid ""
"N is the number of available virtqueues. Slave could get it from num queues "
"field of ``VhostUserInflight``."
msgstr ""

#: ../../../interop/vhost-user.rst:548
msgid "For split virtqueue, queue region can be implemented as:"
msgstr ""

#: ../../../interop/vhost-user.rst:550
msgid ""
"typedef struct DescStateSplit {\n"
"    /* Indicate whether this descriptor is inflight or not.\n"
"     * Only available for head-descriptor. */\n"
"    uint8_t inflight;\n"
"\n"
"    /* Padding */\n"
"    uint8_t padding[5];\n"
"\n"
"    /* Maintain a list for the last batch of used descriptors.\n"
"     * Only available when batching is used for submitting */\n"
"    uint16_t next;\n"
"\n"
"    /* Used to preserve the order of fetching available descriptors.\n"
"     * Only available for head-descriptor. */\n"
"    uint64_t counter;\n"
"} DescStateSplit;\n"
"\n"
"typedef struct QueueRegionSplit {\n"
"    /* The feature flags of this region. Now it's initialized to 0. */\n"
"    uint64_t features;\n"
"\n"
"    /* The version of this region. It's 1 currently.\n"
"     * Zero value indicates an uninitialized buffer */\n"
"    uint16_t version;\n"
"\n"
"    /* The size of DescStateSplit array. It's equal to the virtqueue\n"
"     * size. Slave could get it from queue size field of VhostUserInflight. "
"*/\n"
"    uint16_t desc_num;\n"
"\n"
"    /* The head of list that track the last batch of used descriptors. */\n"
"    uint16_t last_batch_head;\n"
"\n"
"    /* Store the idx value of used ring */\n"
"    uint16_t used_idx;\n"
"\n"
"    /* Used to track the state of each descriptor in descriptor table */\n"
"    DescStateSplit desc[];\n"
"} QueueRegionSplit;"
msgstr ""

#: ../../../interop/vhost-user.rst:591 ../../../interop/vhost-user.rst:713
msgid "To track inflight I/O, the queue region should be processed as follows:"
msgstr ""

#: ../../../interop/vhost-user.rst:593 ../../../interop/vhost-user.rst:715
msgid "When receiving available buffers from the driver:"
msgstr ""

#: ../../../interop/vhost-user.rst:595
msgid "Get the next available head-descriptor index from available ring, ``i``"
msgstr ""

#: ../../../interop/vhost-user.rst:597
msgid "Set ``desc[i].counter`` to the value of global counter"
msgstr ""

#: ../../../interop/vhost-user.rst:599 ../../../interop/vhost-user.rst:725
msgid "Increase global counter by 1"
msgstr ""

#: ../../../interop/vhost-user.rst:601
msgid "Set ``desc[i].inflight`` to 1"
msgstr ""

#: ../../../interop/vhost-user.rst:603 ../../../interop/vhost-user.rst:742
msgid "When supplying used buffers to the driver:"
msgstr ""

#: ../../../interop/vhost-user.rst:605
msgid "Get corresponding used head-descriptor index, i"
msgstr ""

#: ../../../interop/vhost-user.rst:607
msgid "Set ``desc[i].next`` to ``last_batch_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:609
msgid "Set ``last_batch_head`` to ``i``"
msgstr ""

#: ../../../interop/vhost-user.rst:611
msgid "Steps 1,2,3 may be performed repeatedly if batching is possible"
msgstr ""

#: ../../../interop/vhost-user.rst:613
msgid "Increase the ``idx`` value of used ring by the size of the batch"
msgstr ""

#: ../../../interop/vhost-user.rst:615
msgid ""
"Set the ``inflight`` field of each ``DescStateSplit`` entry in the batch to 0"
msgstr ""

#: ../../../interop/vhost-user.rst:617 ../../../interop/vhost-user.rst:631
msgid "Set ``used_idx`` to the ``idx`` value of used ring"
msgstr ""

#: ../../../interop/vhost-user.rst:619 ../../../interop/vhost-user.rst:766
msgid "When reconnecting:"
msgstr ""

#: ../../../interop/vhost-user.rst:621
msgid ""
"If the value of ``used_idx`` does not match the ``idx`` value of used ring "
"(means the inflight field of ``DescStateSplit`` entries in last batch may be "
"incorrect),"
msgstr ""

#: ../../../interop/vhost-user.rst:625
msgid ""
"Subtract the value of ``used_idx`` from the ``idx`` value of used ring to "
"get last batch size of ``DescStateSplit`` entries"
msgstr ""

#: ../../../interop/vhost-user.rst:628
msgid ""
"Set the ``inflight`` field of each ``DescStateSplit`` entry to 0 in last "
"batch list which starts from ``last_batch_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:633
msgid ""
"Resubmit inflight ``DescStateSplit`` entries in order of their counter value"
msgstr ""

#: ../../../interop/vhost-user.rst:636
msgid "For packed virtqueue, queue region can be implemented as:"
msgstr ""

#: ../../../interop/vhost-user.rst:638
msgid ""
"typedef struct DescStatePacked {\n"
"    /* Indicate whether this descriptor is inflight or not.\n"
"     * Only available for head-descriptor. */\n"
"    uint8_t inflight;\n"
"\n"
"    /* Padding */\n"
"    uint8_t padding;\n"
"\n"
"    /* Link to the next free entry */\n"
"    uint16_t next;\n"
"\n"
"    /* Link to the last entry of descriptor list.\n"
"     * Only available for head-descriptor. */\n"
"    uint16_t last;\n"
"\n"
"    /* The length of descriptor list.\n"
"     * Only available for head-descriptor. */\n"
"    uint16_t num;\n"
"\n"
"    /* Used to preserve the order of fetching available descriptors.\n"
"     * Only available for head-descriptor. */\n"
"    uint64_t counter;\n"
"\n"
"    /* The buffer id */\n"
"    uint16_t id;\n"
"\n"
"    /* The descriptor flags */\n"
"    uint16_t flags;\n"
"\n"
"    /* The buffer length */\n"
"    uint32_t len;\n"
"\n"
"    /* The buffer address */\n"
"    uint64_t addr;\n"
"} DescStatePacked;\n"
"\n"
"typedef struct QueueRegionPacked {\n"
"    /* The feature flags of this region. Now it's initialized to 0. */\n"
"    uint64_t features;\n"
"\n"
"    /* The version of this region. It's 1 currently.\n"
"     * Zero value indicates an uninitialized buffer */\n"
"    uint16_t version;\n"
"\n"
"    /* The size of DescStatePacked array. It's equal to the virtqueue\n"
"     * size. Slave could get it from queue size field of VhostUserInflight. "
"*/\n"
"    uint16_t desc_num;\n"
"\n"
"    /* The head of free DescStatePacked entry list */\n"
"    uint16_t free_head;\n"
"\n"
"    /* The old head of free DescStatePacked entry list */\n"
"    uint16_t old_free_head;\n"
"\n"
"    /* The used index of descriptor ring */\n"
"    uint16_t used_idx;\n"
"\n"
"    /* The old used index of descriptor ring */\n"
"    uint16_t old_used_idx;\n"
"\n"
"    /* Device ring wrap counter */\n"
"    uint8_t used_wrap_counter;\n"
"\n"
"    /* The old device ring wrap counter */\n"
"    uint8_t old_used_wrap_counter;\n"
"\n"
"    /* Padding */\n"
"    uint8_t padding[7];\n"
"\n"
"    /* Used to track the state of each descriptor fetched from descriptor "
"ring */\n"
"    DescStatePacked desc[];\n"
"} QueueRegionPacked;"
msgstr ""

#: ../../../interop/vhost-user.rst:717
msgid "Get the next available descriptor entry from descriptor ring, ``d``"
msgstr ""

#: ../../../interop/vhost-user.rst:719
msgid "If ``d`` is head descriptor,"
msgstr ""

#: ../../../interop/vhost-user.rst:721
msgid "Set ``desc[old_free_head].num`` to 0"
msgstr ""

#: ../../../interop/vhost-user.rst:723
msgid "Set ``desc[old_free_head].counter`` to the value of global counter"
msgstr ""

#: ../../../interop/vhost-user.rst:727
msgid "Set ``desc[old_free_head].inflight`` to 1"
msgstr ""

#: ../../../interop/vhost-user.rst:729
msgid ""
"If ``d`` is last descriptor, set ``desc[old_free_head].last`` to "
"``free_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:732
msgid "Increase ``desc[old_free_head].num`` by 1"
msgstr ""

#: ../../../interop/vhost-user.rst:734
msgid ""
"Set ``desc[free_head].addr``, ``desc[free_head].len``, ``desc[free_head]."
"flags``, ``desc[free_head].id`` to ``d.addr``, ``d.len``, ``d.flags``, ``d."
"id``"
msgstr ""

#: ../../../interop/vhost-user.rst:738
msgid "Set ``free_head`` to ``desc[free_head].next``"
msgstr ""

#: ../../../interop/vhost-user.rst:740
msgid "If ``d`` is last descriptor, set ``old_free_head`` to ``free_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:744
msgid ""
"Get corresponding used head-descriptor entry from descriptor ring, ``d``"
msgstr ""

#: ../../../interop/vhost-user.rst:747
msgid "Get corresponding ``DescStatePacked`` entry, ``e``"
msgstr ""

#: ../../../interop/vhost-user.rst:749
msgid "Set ``desc[e.last].next`` to ``free_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:751
msgid "Set ``free_head`` to the index of ``e``"
msgstr ""

#: ../../../interop/vhost-user.rst:753
msgid "Steps 1,2,3,4 may be performed repeatedly if batching is possible"
msgstr ""

#: ../../../interop/vhost-user.rst:755
msgid ""
"Increase ``used_idx`` by the size of the batch and update "
"``used_wrap_counter`` if needed"
msgstr ""

#: ../../../interop/vhost-user.rst:758
msgid "Update ``d.flags``"
msgstr ""

#: ../../../interop/vhost-user.rst:760
msgid ""
"Set the ``inflight`` field of each head ``DescStatePacked`` entry in the "
"batch to 0"
msgstr ""

#: ../../../interop/vhost-user.rst:763
msgid ""
"Set ``old_free_head``,  ``old_used_idx``, ``old_used_wrap_counter`` to "
"``free_head``, ``used_idx``, ``used_wrap_counter``"
msgstr ""

#: ../../../interop/vhost-user.rst:768
msgid ""
"If ``used_idx`` does not match ``old_used_idx`` (means the ``inflight`` "
"field of ``DescStatePacked`` entries in last batch may be incorrect),"
msgstr ""

#: ../../../interop/vhost-user.rst:772
msgid "Get the next descriptor ring entry through ``old_used_idx``, ``d``"
msgstr ""

#: ../../../interop/vhost-user.rst:774
msgid "Use ``old_used_wrap_counter`` to calculate the available flags"
msgstr ""

#: ../../../interop/vhost-user.rst:776
msgid ""
"If ``d.flags`` is not equal to the calculated flags value (means slave has "
"submitted the buffer to guest driver before crash, so it has to commit the "
"in-progres update), set ``old_free_head``, ``old_used_idx``, "
"``old_used_wrap_counter`` to ``free_head``, ``used_idx``, "
"``used_wrap_counter``"
msgstr ""

#: ../../../interop/vhost-user.rst:782
msgid ""
"Set ``free_head``, ``used_idx``, ``used_wrap_counter`` to ``old_free_head``, "
"``old_used_idx``, ``old_used_wrap_counter`` (roll back any in-progress "
"update)"
msgstr ""

#: ../../../interop/vhost-user.rst:786
msgid ""
"Set the ``inflight`` field of each ``DescStatePacked`` entry in free list to "
"0"
msgstr ""

#: ../../../interop/vhost-user.rst:789
msgid ""
"Resubmit inflight ``DescStatePacked`` entries in order of their counter value"
msgstr ""

#: ../../../interop/vhost-user.rst:793
msgid "In-band notifications"
msgstr ""

#: ../../../interop/vhost-user.rst:795
msgid ""
"In some limited situations (e.g. for simulation) it is desirable to have the "
"kick, call and error (if used) signals done via in-band messages instead of "
"asynchronous eventfd notifications. This can be done by negotiating the "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature."
msgstr ""

#: ../../../interop/vhost-user.rst:801
msgid ""
"Note that due to the fact that too many messages on the sockets can cause "
"the sending application(s) to block, it is not advised to use this feature "
"unless absolutely necessary. It is also considered an error to negotiate "
"this feature without also negotiating ``VHOST_USER_PROTOCOL_F_SLAVE_REQ`` "
"and ``VHOST_USER_PROTOCOL_F_REPLY_ACK``, the former is necessary for getting "
"a message channel from the slave to the master, while the latter needs to be "
"used with the in-band notification messages to block until they are "
"processed, both to avoid blocking later and for proper processing (at least "
"in the simulation use case.) As it has no other way of signalling this "
"error, the slave should close the connection as a response to a "
"``VHOST_USER_SET_PROTOCOL_FEATURES`` message that sets the in-band "
"notifications feature flag without the other two."
msgstr ""

#: ../../../interop/vhost-user.rst:816
msgid "Protocol features"
msgstr ""

#: ../../../interop/vhost-user.rst:818
msgid ""
"#define VHOST_USER_PROTOCOL_F_MQ                    0\n"
"#define VHOST_USER_PROTOCOL_F_LOG_SHMFD             1\n"
"#define VHOST_USER_PROTOCOL_F_RARP                  2\n"
"#define VHOST_USER_PROTOCOL_F_REPLY_ACK             3\n"
"#define VHOST_USER_PROTOCOL_F_MTU                   4\n"
"#define VHOST_USER_PROTOCOL_F_SLAVE_REQ             5\n"
"#define VHOST_USER_PROTOCOL_F_CROSS_ENDIAN          6\n"
"#define VHOST_USER_PROTOCOL_F_CRYPTO_SESSION        7\n"
"#define VHOST_USER_PROTOCOL_F_PAGEFAULT             8\n"
"#define VHOST_USER_PROTOCOL_F_CONFIG                9\n"
"#define VHOST_USER_PROTOCOL_F_SLAVE_SEND_FD        10\n"
"#define VHOST_USER_PROTOCOL_F_HOST_NOTIFIER        11\n"
"#define VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD       12\n"
"#define VHOST_USER_PROTOCOL_F_RESET_DEVICE         13\n"
"#define VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS 14\n"
"#define VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS  15\n"
"#define VHOST_USER_PROTOCOL_F_STATUS               16"
msgstr ""

#: ../../../interop/vhost-user.rst:839
msgid "Master message types"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "id"
msgstr ""

#: ../../../interop/vhost-user.rst:842 ../../../interop/vhost-user.rst:1355
msgid "1"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "equivalent ioctl"
msgstr ""

#: ../../../interop/vhost-user.rst:843 ../../../interop/vhost-user.rst:864
msgid "``VHOST_GET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "master payload"
msgstr ""

#: ../../../interop/vhost-user.rst:844 ../../../interop/vhost-user.rst:865
#: ../../../interop/vhost-user.rst:895 ../../../interop/vhost-user.rst:903
#: ../../../interop/vhost-user.rst:941 ../../../interop/vhost-user.rst:953
#: ../../../interop/vhost-user.rst:968 ../../../interop/vhost-user.rst:1042
#: ../../../interop/vhost-user.rst:1043 ../../../interop/vhost-user.rst:1054
#: ../../../interop/vhost-user.rst:1064 ../../../interop/vhost-user.rst:1079
#: ../../../interop/vhost-user.rst:1096 ../../../interop/vhost-user.rst:1097
#: ../../../interop/vhost-user.rst:1141 ../../../interop/vhost-user.rst:1155
#: ../../../interop/vhost-user.rst:1157 ../../../interop/vhost-user.rst:1168
#: ../../../interop/vhost-user.rst:1181 ../../../interop/vhost-user.rst:1194
#: ../../../interop/vhost-user.rst:1204 ../../../interop/vhost-user.rst:1229
#: ../../../interop/vhost-user.rst:1240 ../../../interop/vhost-user.rst:1250
#: ../../../interop/vhost-user.rst:1251 ../../../interop/vhost-user.rst:1259
#: ../../../interop/vhost-user.rst:1260 ../../../interop/vhost-user.rst:1261
#: ../../../interop/vhost-user.rst:1273 ../../../interop/vhost-user.rst:1275
#: ../../../interop/vhost-user.rst:1287 ../../../interop/vhost-user.rst:1300
#: ../../../interop/vhost-user.rst:1315 ../../../interop/vhost-user.rst:1331
#: ../../../interop/vhost-user.rst:1343 ../../../interop/vhost-user.rst:1358
#: ../../../interop/vhost-user.rst:1371 ../../../interop/vhost-user.rst:1372
#: ../../../interop/vhost-user.rst:1373 ../../../interop/vhost-user.rst:1386
#: ../../../interop/vhost-user.rst:1388 ../../../interop/vhost-user.rst:1409
#: ../../../interop/vhost-user.rst:1411 ../../../interop/vhost-user.rst:1423
#: ../../../interop/vhost-user.rst:1425
msgid "N/A"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "slave payload"
msgstr ""

#: ../../../interop/vhost-user.rst:845 ../../../interop/vhost-user.rst:855
#: ../../../interop/vhost-user.rst:866 ../../../interop/vhost-user.rst:881
#: ../../../interop/vhost-user.rst:990 ../../../interop/vhost-user.rst:1008
#: ../../../interop/vhost-user.rst:1026 ../../../interop/vhost-user.rst:1065
#: ../../../interop/vhost-user.rst:1080 ../../../interop/vhost-user.rst:1113
#: ../../../interop/vhost-user.rst:1182 ../../../interop/vhost-user.rst:1215
#: ../../../interop/vhost-user.rst:1332 ../../../interop/vhost-user.rst:1342
msgid "``u64``"
msgstr ""

#: ../../../interop/vhost-user.rst:847
msgid ""
"Get from the underlying vhost implementation the features bitmask. Feature "
"bit ``VHOST_USER_F_PROTOCOL_FEATURES`` signals slave support for "
"``VHOST_USER_GET_PROTOCOL_FEATURES`` and "
"``VHOST_USER_SET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:852
msgid "``VHOST_USER_SET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:853 ../../../interop/vhost-user.rst:1370
msgid "2"
msgstr ""

#: ../../../interop/vhost-user.rst:854 ../../../interop/vhost-user.rst:880
msgid "``VHOST_SET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:857
msgid ""
"Enable features in the underlying vhost implementation using a bitmask.  "
"Feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` signals slave support for "
"``VHOST_USER_GET_PROTOCOL_FEATURES`` and "
"``VHOST_USER_SET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:863
msgid "15"
msgstr ""

#: ../../../interop/vhost-user.rst:868
msgid ""
"Get the protocol feature bitmask from the underlying vhost implementation.  "
"Only legal if feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:874 ../../../interop/vhost-user.rst:889
msgid ""
"Slave that reported ``VHOST_USER_F_PROTOCOL_FEATURES`` must support this "
"message even before ``VHOST_USER_SET_FEATURES`` was called."
msgstr ""

#: ../../../interop/vhost-user.rst:878
msgid "``VHOST_USER_SET_PROTOCOL_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:879
msgid "16"
msgstr ""

#: ../../../interop/vhost-user.rst:883
msgid "Enable protocol features in the underlying vhost implementation."
msgstr ""

#: ../../../interop/vhost-user.rst:885
msgid ""
"Only legal if feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:892
msgid "``VHOST_USER_SET_OWNER``"
msgstr ""

#: ../../../interop/vhost-user.rst:893 ../../../interop/vhost-user.rst:1385
msgid "3"
msgstr ""

#: ../../../interop/vhost-user.rst:894
msgid "``VHOST_SET_OWNER``"
msgstr ""

#: ../../../interop/vhost-user.rst:897
msgid ""
"Issued when a new connection is established. It sets the current *master* as "
"an owner of the session. This can be used on the *slave* as a \"session "
"start\" flag."
msgstr ""

#: ../../../interop/vhost-user.rst:901
msgid "``VHOST_USER_RESET_OWNER``"
msgstr ""

#: ../../../interop/vhost-user.rst:902 ../../../interop/vhost-user.rst:1408
msgid "4"
msgstr ""

#: ../../../interop/vhost-user.rst:905
msgid "Deprecated"
msgstr ""

#: ../../../interop/vhost-user.rst:907
msgid ""
"This is no longer used. Used to be sent to request disabling all rings, but "
"some clients interpreted it to also discard connection state (this "
"interpretation would lead to bugs).  It is recommended that clients either "
"ignore this message, or use it to disable all rings."
msgstr ""

#: ../../../interop/vhost-user.rst:914 ../../../interop/vhost-user.rst:1422
msgid "5"
msgstr ""

#: ../../../interop/vhost-user.rst:915
msgid "``VHOST_SET_MEM_TABLE``"
msgstr ""

#: ../../../interop/vhost-user.rst:916
msgid "memory regions description"
msgstr ""

#: ../../../interop/vhost-user.rst:917
msgid "(postcopy only) memory regions description"
msgstr ""

#: ../../../interop/vhost-user.rst:919
msgid ""
"Sets the memory map regions on the slave so it can translate the vring "
"addresses. In the ancillary data there is an array of file descriptors for "
"each memory mapped region. The size and ordering of the fds matches the "
"number and ordering of memory regions."
msgstr ""

#: ../../../interop/vhost-user.rst:924
msgid ""
"When ``VHOST_USER_POSTCOPY_LISTEN`` has been received, ``SET_MEM_TABLE`` "
"replies with the bases of the memory mapped regions to the master.  The "
"slave must have mmap'd the regions but not yet accessed them and should not "
"yet generate a userfault event."
msgstr ""

#: ../../../interop/vhost-user.rst:931
msgid ""
"``NEED_REPLY_MASK`` is not set in this case.  QEMU will then reply back to "
"the list of mappings with an empty ``VHOST_USER_SET_MEM_TABLE`` as an "
"acknowledgement; only upon reception of this message may the guest start "
"accessing the memory and generating faults."
msgstr ""

#: ../../../interop/vhost-user.rst:937
msgid "``VHOST_USER_SET_LOG_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:938
msgid "6"
msgstr ""

#: ../../../interop/vhost-user.rst:939
msgid "``VHOST_SET_LOG_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:943
msgid "Sets logging shared memory space."
msgstr ""

#: ../../../interop/vhost-user.rst:945
msgid ""
"When slave has ``VHOST_USER_PROTOCOL_F_LOG_SHMFD`` protocol feature, the log "
"memory fd is provided in the ancillary data of ``VHOST_USER_SET_LOG_BASE`` "
"message, the size and offset of shared memory area provided in the message."
msgstr ""

#: ../../../interop/vhost-user.rst:951
msgid "7"
msgstr ""

#: ../../../interop/vhost-user.rst:952
msgid "``VHOST_SET_LOG_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:955
msgid "Sets the logging file descriptor, which is passed as ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:957
msgid "``VHOST_USER_SET_VRING_NUM``"
msgstr ""

#: ../../../interop/vhost-user.rst:958
msgid "8"
msgstr ""

#: ../../../interop/vhost-user.rst:959
msgid "``VHOST_SET_VRING_NUM``"
msgstr ""

#: ../../../interop/vhost-user.rst:960 ../../../interop/vhost-user.rst:975
#: ../../../interop/vhost-user.rst:982 ../../../interop/vhost-user.rst:983
#: ../../../interop/vhost-user.rst:1055 ../../../interop/vhost-user.rst:1127
#: ../../../interop/vhost-user.rst:1274 ../../../interop/vhost-user.rst:1410
#: ../../../interop/vhost-user.rst:1424
msgid "vring state description"
msgstr ""

#: ../../../interop/vhost-user.rst:962
msgid "Set the size of the queue."
msgstr ""

#: ../../../interop/vhost-user.rst:964
msgid "``VHOST_USER_SET_VRING_ADDR``"
msgstr ""

#: ../../../interop/vhost-user.rst:965
msgid "9"
msgstr ""

#: ../../../interop/vhost-user.rst:966
msgid "``VHOST_SET_VRING_ADDR``"
msgstr ""

#: ../../../interop/vhost-user.rst:967
msgid "vring address description"
msgstr ""

#: ../../../interop/vhost-user.rst:970
msgid "Sets the addresses of the different aspects of the vring."
msgstr ""

#: ../../../interop/vhost-user.rst:972
msgid "``VHOST_USER_SET_VRING_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:973
msgid "10"
msgstr ""

#: ../../../interop/vhost-user.rst:974
msgid "``VHOST_SET_VRING_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:977
msgid "Sets the base offset in the available vring."
msgstr ""

#: ../../../interop/vhost-user.rst:980
msgid "11"
msgstr ""

#: ../../../interop/vhost-user.rst:985
msgid "Get the available vring base offset."
msgstr ""

#: ../../../interop/vhost-user.rst:988
msgid "12"
msgstr ""

#: ../../../interop/vhost-user.rst:989
msgid "``VHOST_SET_VRING_KICK``"
msgstr ""

#: ../../../interop/vhost-user.rst:992
msgid ""
"Set the event file descriptor for adding buffers to the vring. It is passed "
"in the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:995
msgid ""
"Bits (0-7) of the payload contain the vring index. Bit 8 is the invalid FD "
"flag. This flag is set when there is no file descriptor in the ancillary "
"data. This signals that polling should be used instead of waiting for the "
"kick. Note that if the protocol feature "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` has been negotiated this "
"message isn't necessary as the ring is also started on the "
"``VHOST_USER_VRING_KICK`` message, it may however still be used to set an "
"event file descriptor (which will be preferred over the message) or to "
"enable polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1006
msgid "13"
msgstr ""

#: ../../../interop/vhost-user.rst:1007
msgid "``VHOST_SET_VRING_CALL``"
msgstr ""

#: ../../../interop/vhost-user.rst:1010
msgid ""
"Set the event file descriptor to signal when buffers are used. It is passed "
"in the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1013
msgid ""
"Bits (0-7) of the payload contain the vring index. Bit 8 is the invalid FD "
"flag. This flag is set when there is no file descriptor in the ancillary "
"data. This signals that polling will be used instead of waiting for the "
"call. Note that if the protocol features "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` and "
"``VHOST_USER_PROTOCOL_F_SLAVE_REQ`` have been negotiated this message isn't "
"necessary as the ``VHOST_USER_SLAVE_VRING_CALL`` message can be used, it may "
"however still be used to set an event file descriptor or to enable polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1024
msgid "14"
msgstr ""

#: ../../../interop/vhost-user.rst:1025
msgid "``VHOST_SET_VRING_ERR``"
msgstr ""

#: ../../../interop/vhost-user.rst:1028
msgid ""
"Set the event file descriptor to signal when error occurs. It is passed in "
"the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1031
msgid ""
"Bits (0-7) of the payload contain the vring index. Bit 8 is the invalid FD "
"flag. This flag is set when there is no file descriptor in the ancillary "
"data. Note that if the protocol features "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` and "
"``VHOST_USER_PROTOCOL_F_SLAVE_REQ`` have been negotiated this message isn't "
"necessary as the ``VHOST_USER_SLAVE_VRING_ERR`` message can be used, it may "
"however still be used to set an event file descriptor (which will be "
"preferred over the message)."
msgstr ""

#: ../../../interop/vhost-user.rst:1040
msgid "``VHOST_USER_GET_QUEUE_NUM``"
msgstr ""

#: ../../../interop/vhost-user.rst:1041
msgid "17"
msgstr ""

#: ../../../interop/vhost-user.rst:1046
msgid "Query how many queues the backend supports."
msgstr ""

#: ../../../interop/vhost-user.rst:1048
msgid ""
"This request should be sent only when ``VHOST_USER_PROTOCOL_F_MQ`` is set in "
"queried protocol features by ``VHOST_USER_GET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:1052
msgid "``VHOST_USER_SET_VRING_ENABLE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1053
msgid "18"
msgstr ""

#: ../../../interop/vhost-user.rst:1057
msgid "Signal slave to enable or disable corresponding vring."
msgstr ""

#: ../../../interop/vhost-user.rst:1059
msgid ""
"This request should be sent only when ``VHOST_USER_F_PROTOCOL_FEATURES`` has "
"been negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1062
msgid "``VHOST_USER_SEND_RARP``"
msgstr ""

#: ../../../interop/vhost-user.rst:1063
msgid "19"
msgstr ""

#: ../../../interop/vhost-user.rst:1067
msgid ""
"Ask vhost user backend to broadcast a fake RARP to notify the migration is "
"terminated for guest that does not support GUEST_ANNOUNCE."
msgstr ""

#: ../../../interop/vhost-user.rst:1070
msgid ""
"Only legal if feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES`` and protocol feature bit "
"``VHOST_USER_PROTOCOL_F_RARP`` is present in "
"``VHOST_USER_GET_PROTOCOL_FEATURES``.  The first 6 bytes of the payload "
"contain the mac address of the guest to allow the vhost user backend to "
"construct and broadcast the fake RARP."
msgstr ""

#: ../../../interop/vhost-user.rst:1077
msgid "``VHOST_USER_NET_SET_MTU``"
msgstr ""

#: ../../../interop/vhost-user.rst:1078
msgid "20"
msgstr ""

#: ../../../interop/vhost-user.rst:1082
msgid "Set host MTU value exposed to the guest."
msgstr ""

#: ../../../interop/vhost-user.rst:1084
msgid ""
"This request should be sent only when ``VIRTIO_NET_F_MTU`` feature has been "
"successfully negotiated, ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES`` and protocol feature bit "
"``VHOST_USER_PROTOCOL_F_NET_MTU`` is present in "
"``VHOST_USER_GET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:1090
msgid ""
"If ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, slave must respond "
"with zero in case the specified MTU is valid, or non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1095
msgid "21"
msgstr ""

#: ../../../interop/vhost-user.rst:1099
msgid ""
"Set the socket file descriptor for slave initiated requests. It is passed in "
"the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1102
msgid ""
"This request should be sent only when ``VHOST_USER_F_PROTOCOL_FEATURES`` has "
"been negotiated, and protocol feature bit "
"``VHOST_USER_PROTOCOL_F_SLAVE_REQ`` bit is present in "
"``VHOST_USER_GET_PROTOCOL_FEATURES``.  If "
"``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, slave must respond with "
"zero for success, non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1109
msgid "``VHOST_USER_IOTLB_MSG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1110
msgid "22"
msgstr ""

#: ../../../interop/vhost-user.rst:1111 ../../../interop/vhost-user.rst:1356
msgid "N/A (equivalent to ``VHOST_IOTLB_MSG`` message type)"
msgstr ""

#: ../../../interop/vhost-user.rst:1112 ../../../interop/vhost-user.rst:1357
msgid "``struct vhost_iotlb_msg``"
msgstr ""

#: ../../../interop/vhost-user.rst:1115
msgid "Send IOTLB messages with ``struct vhost_iotlb_msg`` as payload."
msgstr ""

#: ../../../interop/vhost-user.rst:1117
msgid ""
"Master sends such requests to update and invalidate entries in the device "
"IOTLB. The slave has to acknowledge the request with sending zero as ``u64`` "
"payload for success, non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1121
msgid ""
"This request should be send only when ``VIRTIO_F_IOMMU_PLATFORM`` feature "
"has been successfully negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1124
msgid "``VHOST_USER_SET_VRING_ENDIAN``"
msgstr ""

#: ../../../interop/vhost-user.rst:1125
msgid "23"
msgstr ""

#: ../../../interop/vhost-user.rst:1126
msgid "``VHOST_SET_VRING_ENDIAN``"
msgstr ""

#: ../../../interop/vhost-user.rst:1129
msgid ""
"Set the endianness of a VQ for legacy devices. Little-endian is indicated "
"with state.num set to 0 and big-endian is indicated with state.num set to 1. "
"Other values are invalid."
msgstr ""

#: ../../../interop/vhost-user.rst:1133
msgid ""
"This request should be sent only when ``VHOST_USER_PROTOCOL_F_CROSS_ENDIAN`` "
"has been negotiated. Backends that negotiated this feature should handle "
"both endiannesses and expect this message once (per VQ) during device "
"configuration (ie. before the master starts the VQ)."
msgstr ""

#: ../../../interop/vhost-user.rst:1139
msgid "``VHOST_USER_GET_CONFIG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1140
msgid "24"
msgstr ""

#: ../../../interop/vhost-user.rst:1142 ../../../interop/vhost-user.rst:1143
#: ../../../interop/vhost-user.rst:1156
msgid "virtio device config space"
msgstr ""

#: ../../../interop/vhost-user.rst:1145
msgid ""
"When ``VHOST_USER_PROTOCOL_F_CONFIG`` is negotiated, this message is "
"submitted by the vhost-user master to fetch the contents of the virtio "
"device configuration space, vhost-user slave's payload size MUST match "
"master's request, vhost-user slave uses zero length of payload to indicate "
"an error to vhost-user master. The vhost-user master may cache the contents "
"to avoid repeated ``VHOST_USER_GET_CONFIG`` calls."
msgstr ""

#: ../../../interop/vhost-user.rst:1153
msgid "``VHOST_USER_SET_CONFIG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1154
msgid "25"
msgstr ""

#: ../../../interop/vhost-user.rst:1159
msgid ""
"When ``VHOST_USER_PROTOCOL_F_CONFIG`` is negotiated, this message is "
"submitted by the vhost-user master when the Guest changes the virtio device "
"configuration space and also can be used for live migration on the "
"destination host. The vhost-user slave must check the flags field, and "
"slaves MUST NOT accept SET_CONFIG for read-only configuration space fields "
"unless the live migration bit is set."
msgstr ""

#: ../../../interop/vhost-user.rst:1166
msgid "``VHOST_USER_CREATE_CRYPTO_SESSION``"
msgstr ""

#: ../../../interop/vhost-user.rst:1167
msgid "26"
msgstr ""

#: ../../../interop/vhost-user.rst:1169 ../../../interop/vhost-user.rst:1170
msgid "crypto session description"
msgstr ""

#: ../../../interop/vhost-user.rst:1172
msgid ""
"Create a session for crypto operation. The server side must return the "
"session id, 0 or positive for success, negative for failure. This request "
"should be sent only when ``VHOST_USER_PROTOCOL_F_CRYPTO_SESSION`` feature "
"has been successfully negotiated.  It's a required feature for crypto "
"devices."
msgstr ""

#: ../../../interop/vhost-user.rst:1179
msgid "``VHOST_USER_CLOSE_CRYPTO_SESSION``"
msgstr ""

#: ../../../interop/vhost-user.rst:1180
msgid "27"
msgstr ""

#: ../../../interop/vhost-user.rst:1184
msgid ""
"Close a session for crypto operation which was previously created by "
"``VHOST_USER_CREATE_CRYPTO_SESSION``."
msgstr ""

#: ../../../interop/vhost-user.rst:1187
msgid ""
"This request should be sent only when "
"``VHOST_USER_PROTOCOL_F_CRYPTO_SESSION`` feature has been successfully "
"negotiated.  It's a required feature for crypto devices."
msgstr ""

#: ../../../interop/vhost-user.rst:1192
msgid "``VHOST_USER_POSTCOPY_ADVISE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1193
msgid "28"
msgstr ""

#: ../../../interop/vhost-user.rst:1195
msgid "userfault fd"
msgstr ""

#: ../../../interop/vhost-user.rst:1197
msgid ""
"When ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` is supported, the master advises "
"slave that a migration with postcopy enabled is underway, the slave must "
"open a userfaultfd for later use.  Note that at this stage the migration is "
"still in precopy mode."
msgstr ""

#: ../../../interop/vhost-user.rst:1202
msgid "``VHOST_USER_POSTCOPY_LISTEN``"
msgstr ""

#: ../../../interop/vhost-user.rst:1203
msgid "29"
msgstr ""

#: ../../../interop/vhost-user.rst:1206
msgid ""
"Master advises slave that a transition to postcopy mode has happened.  The "
"slave must ensure that shared memory is registered with userfaultfd to cause "
"faulting of non-present pages."
msgstr ""

#: ../../../interop/vhost-user.rst:1210
msgid ""
"This is always sent sometime after a ``VHOST_USER_POSTCOPY_ADVISE``, and "
"thus only when ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` is supported."
msgstr ""

#: ../../../interop/vhost-user.rst:1213
msgid "``VHOST_USER_POSTCOPY_END``"
msgstr ""

#: ../../../interop/vhost-user.rst:1214
msgid "30"
msgstr ""

#: ../../../interop/vhost-user.rst:1217
msgid ""
"Master advises that postcopy migration has now completed.  The slave must "
"disable the userfaultfd. The response is an acknowledgement only."
msgstr ""

#: ../../../interop/vhost-user.rst:1221
msgid ""
"When ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` is supported, this message is sent "
"at the end of the migration, after ``VHOST_USER_POSTCOPY_LISTEN`` was "
"previously sent."
msgstr ""

#: ../../../interop/vhost-user.rst:1225
msgid "The value returned is an error indication; 0 is success."
msgstr ""

#: ../../../interop/vhost-user.rst:1227
msgid "``VHOST_USER_GET_INFLIGHT_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:1228
msgid "31"
msgstr ""

#: ../../../interop/vhost-user.rst:1230 ../../../interop/vhost-user.rst:1241
msgid "inflight description"
msgstr ""

#: ../../../interop/vhost-user.rst:1232
msgid ""
"When ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD`` protocol feature has been "
"successfully negotiated, this message is submitted by master to get a shared "
"buffer from slave. The shared buffer will be used to track inflight I/O by "
"slave. QEMU should retrieve a new one when vm reset."
msgstr ""

#: ../../../interop/vhost-user.rst:1238
msgid "``VHOST_USER_SET_INFLIGHT_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:1239
msgid "32"
msgstr ""

#: ../../../interop/vhost-user.rst:1243
msgid ""
"When ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD`` protocol feature has been "
"successfully negotiated, this message is submitted by master to send the "
"shared inflight buffer back to slave so that slave could get inflight I/O "
"after a crash or restart."
msgstr ""

#: ../../../interop/vhost-user.rst:1248
msgid "``VHOST_USER_GPU_SET_SOCKET``"
msgstr ""

#: ../../../interop/vhost-user.rst:1249
msgid "33"
msgstr ""

#: ../../../interop/vhost-user.rst:1253
msgid ""
"Sets the GPU protocol socket file descriptor, which is passed as ancillary "
"data. The GPU protocol is used to inform the master of rendering state and "
"updates. See vhost-user-gpu.rst for details."
msgstr ""

#: ../../../interop/vhost-user.rst:1257
msgid "``VHOST_USER_RESET_DEVICE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1258
msgid "34"
msgstr ""

#: ../../../interop/vhost-user.rst:1263
msgid ""
"Ask the vhost user backend to disable all rings and reset all internal "
"device state to the initial state, ready to be reinitialized. The backend "
"retains ownership of the device throughout the reset operation."
msgstr ""

#: ../../../interop/vhost-user.rst:1268
msgid ""
"Only valid if the ``VHOST_USER_PROTOCOL_F_RESET_DEVICE`` protocol feature is "
"set by the backend."
msgstr ""

#: ../../../interop/vhost-user.rst:1271
msgid "``VHOST_USER_VRING_KICK``"
msgstr ""

#: ../../../interop/vhost-user.rst:1272
msgid "35"
msgstr ""

#: ../../../interop/vhost-user.rst:1277
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature has "
"been successfully negotiated, this message may be submitted by the master to "
"indicate that a buffer was added to the vring instead of signalling it using "
"the vring's kick file descriptor or having the slave rely on polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1283 ../../../interop/vhost-user.rst:1419
#: ../../../interop/vhost-user.rst:1433
msgid "The state.num field is currently reserved and must be set to 0."
msgstr ""

#: ../../../interop/vhost-user.rst:1285
msgid "``VHOST_USER_GET_MAX_MEM_SLOTS``"
msgstr ""

#: ../../../interop/vhost-user.rst:1286
msgid "36"
msgstr ""

#: ../../../interop/vhost-user.rst:1290
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has "
"been successfully negotiated, this message is submitted by master to the "
"slave. The slave should return the message with a u64 payload containing the "
"maximum number of memory slots for QEMU to expose to the guest. The value "
"returned by the backend will be capped at the maximum number of ram slots "
"which can be supported by the target platform."
msgstr ""

#: ../../../interop/vhost-user.rst:1298
msgid "``VHOST_USER_ADD_MEM_REG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1299
msgid "37"
msgstr ""

#: ../../../interop/vhost-user.rst:1301 ../../../interop/vhost-user.rst:1316
msgid "single memory region description"
msgstr ""

#: ../../../interop/vhost-user.rst:1303
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has "
"been successfully negotiated, this message is submitted by the master to the "
"slave. The message payload contains a memory region descriptor struct, "
"describing a region of guest memory which the slave device must map in. When "
"the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has been "
"successfully negotiated, along with the ``VHOST_USER_REM_MEM_REG`` message, "
"this message is used to set and update the memory tables of the slave device."
msgstr ""

#: ../../../interop/vhost-user.rst:1313
msgid "``VHOST_USER_REM_MEM_REG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1314
msgid "38"
msgstr ""

#: ../../../interop/vhost-user.rst:1318
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has "
"been successfully negotiated, this message is submitted by the master to the "
"slave. The message payload contains a memory region descriptor struct, "
"describing a region of guest memory which the slave device must unmap. When "
"the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has been "
"successfully negotiated, along with the ``VHOST_USER_ADD_MEM_REG`` message, "
"this message is used to set and update the memory tables of the slave device."
msgstr ""

#: ../../../interop/vhost-user.rst:1328
msgid "``VHOST_USER_SET_STATUS``"
msgstr ""

#: ../../../interop/vhost-user.rst:1329
msgid "39"
msgstr ""

#: ../../../interop/vhost-user.rst:1330
msgid "VHOST_VDPA_SET_STATUS"
msgstr ""

#: ../../../interop/vhost-user.rst:1334
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_STATUS`` protocol feature has been "
"successfully negotiated, this message is submitted by the master to notify "
"the backend with updated device status as defined in the Virtio "
"specification."
msgstr ""

#: ../../../interop/vhost-user.rst:1339
msgid "``VHOST_USER_GET_STATUS``"
msgstr ""

#: ../../../interop/vhost-user.rst:1340
msgid "40"
msgstr ""

#: ../../../interop/vhost-user.rst:1341
msgid "VHOST_VDPA_GET_STATUS"
msgstr ""

#: ../../../interop/vhost-user.rst:1345
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_STATUS`` protocol feature has been "
"successfully negotiated, this message is submitted by the master to query "
"the backend for its device status as defined in the Virtio specification."
msgstr ""

#: ../../../interop/vhost-user.rst:1352
msgid "Slave message types"
msgstr ""

#: ../../../interop/vhost-user.rst:1354
msgid "``VHOST_USER_SLAVE_IOTLB_MSG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1360
msgid ""
"Send IOTLB messages with ``struct vhost_iotlb_msg`` as payload. Slave sends "
"such requests to notify of an IOTLB miss, or an IOTLB access failure. If "
"``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, and slave set the "
"``VHOST_USER_NEED_REPLY`` flag, master must respond with zero when operation "
"is successfully completed, or non-zero otherwise.  This request should be "
"send only when ``VIRTIO_F_IOMMU_PLATFORM`` feature has been successfully "
"negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1369
msgid "``VHOST_USER_SLAVE_CONFIG_CHANGE_MSG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1375
msgid ""
"When ``VHOST_USER_PROTOCOL_F_CONFIG`` is negotiated, vhost-user slave sends "
"such messages to notify that the virtio device's configuration space has "
"changed, for those host devices which can support such feature, host driver "
"can send ``VHOST_USER_GET_CONFIG`` message to slave to get the latest "
"content. If ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, and slave set "
"the ``VHOST_USER_NEED_REPLY`` flag, master must respond with zero when "
"operation is successfully completed, or non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1384
msgid "``VHOST_USER_SLAVE_VRING_HOST_NOTIFIER_MSG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1387
msgid "vring area description"
msgstr ""

#: ../../../interop/vhost-user.rst:1390
msgid ""
"Sets host notifier for a specified queue. The queue index is contained in "
"the ``u64`` field of the vring area description. The host notifier is "
"described by the file descriptor (typically it's a VFIO device fd) which is "
"passed as ancillary data and the size (which is mmap size and should be the "
"same as host page size) and offset (which is mmap offset) carried in the "
"vring area description. QEMU can mmap the file descriptor based on the size "
"and offset to get a memory range. Registering a host notifier means mapping "
"this memory range to the VM as the specified queue's notify MMIO region. "
"Slave sends this request to tell QEMU to de-register the existing notifier "
"if any and register the new notifier if the request is sent with a file "
"descriptor."
msgstr ""

#: ../../../interop/vhost-user.rst:1403
msgid ""
"This request should be sent only when "
"``VHOST_USER_PROTOCOL_F_HOST_NOTIFIER`` protocol feature has been "
"successfully negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1407
msgid "``VHOST_USER_SLAVE_VRING_CALL``"
msgstr ""

#: ../../../interop/vhost-user.rst:1413
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature has "
"been successfully negotiated, this message may be submitted by the slave to "
"indicate that a buffer was used from the vring instead of signalling this "
"using the vring's call file descriptor or having the master relying on "
"polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1421
msgid "``VHOST_USER_SLAVE_VRING_ERR``"
msgstr ""

#: ../../../interop/vhost-user.rst:1427
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature has "
"been successfully negotiated, this message may be submitted by the slave to "
"indicate that an error occurred on the specific vring, instead of signalling "
"the error file descriptor set by the master via ``VHOST_USER_SET_VRING_ERR``."
msgstr ""

#: ../../../interop/vhost-user.rst:1438
msgid "VHOST_USER_PROTOCOL_F_REPLY_ACK"
msgstr ""

#: ../../../interop/vhost-user.rst:1440
msgid ""
"The original vhost-user specification only demands replies for certain "
"commands. This differs from the vhost protocol implementation where commands "
"are sent over an ``ioctl()`` call and block until the client has completed."
msgstr ""

#: ../../../interop/vhost-user.rst:1445
msgid ""
"With this protocol extension negotiated, the sender (QEMU) can set the "
"``need_reply`` [Bit 3] flag to any command. This indicates that the client "
"MUST respond with a Payload ``VhostUserMsg`` indicating success or failure. "
"The payload should be set to zero on success or non-zero on failure, unless "
"the message already has an explicit reply body."
msgstr ""

#: ../../../interop/vhost-user.rst:1451
msgid ""
"The response payload gives QEMU a deterministic indication of the result of "
"the command. Today, QEMU is expected to terminate the main vhost-user loop "
"upon receiving such errors. In future, qemu could be taught to be more "
"resilient for selective requests."
msgstr ""

#: ../../../interop/vhost-user.rst:1456
msgid ""
"For the message types that already solicit a reply from the client, the "
"presence of ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` or need_reply bit being set "
"brings no behavioural change. (See the Communication_ section for details.)"
msgstr ""

#: ../../../interop/vhost-user.rst:1464
msgid "Backend program conventions"
msgstr ""

#: ../../../interop/vhost-user.rst:1466
msgid ""
"vhost-user backends can provide various devices & services and may need to "
"be configured manually depending on the use case. However, it is a good idea "
"to follow the conventions listed here when possible. Users, QEMU or libvirt, "
"can then rely on some common behaviour to avoid heterogeneous configuration "
"and management of the backend programs and facilitate interoperability."
msgstr ""

#: ../../../interop/vhost-user.rst:1473
msgid ""
"Each backend installed on a host system should come with at least one JSON "
"file that conforms to the vhost-user.json schema. Each file informs the "
"management applications about the backend type, and binary location. In "
"addition, it defines rules for management apps for picking the highest "
"priority backend when multiple match the search criteria (see "
"``@VhostUserBackend`` documentation in the schema file)."
msgstr ""

#: ../../../interop/vhost-user.rst:1480
msgid ""
"If the backend is not capable of enabling a requested feature on the host "
"(such as 3D acceleration with virgl), or the initialization failed, the "
"backend should fail to start early and exit with a status != 0. It may also "
"print a message to stderr for further details."
msgstr ""

#: ../../../interop/vhost-user.rst:1485
msgid ""
"The backend program must not daemonize itself, but it may be daemonized by "
"the management layer. It may also have a restricted access to the system."
msgstr ""

#: ../../../interop/vhost-user.rst:1489
msgid ""
"File descriptors 0, 1 and 2 will exist, and have regular stdin/stdout/stderr "
"usage (they may have been redirected to /dev/null by the management layer, "
"or to a log handler)."
msgstr ""

#: ../../../interop/vhost-user.rst:1493
msgid ""
"The backend program must end (as quickly and cleanly as possible) when the "
"SIGTERM signal is received. Eventually, it may receive SIGKILL by the "
"management layer after a few seconds."
msgstr ""

#: ../../../interop/vhost-user.rst:1497
msgid ""
"The following command line options have an expected behaviour. They are "
"mandatory, unless explicitly said differently:"
msgstr ""

#: ../../../interop/vhost-user.rst:1502
msgid ""
"This option specify the location of the vhost-user Unix domain socket. It is "
"incompatible with --fd."
msgstr ""

#: ../../../interop/vhost-user.rst:1507
msgid ""
"When this argument is given, the backend program is started with the vhost-"
"user socket as file descriptor FDNUM. It is incompatible with --socket-path."
msgstr ""

#: ../../../interop/vhost-user.rst:1513
msgid ""
"Output to stdout the backend capabilities in JSON format, and then exit "
"successfully. Other options and arguments should be ignored, and the backend "
"program should not perform its normal function.  The capabilities can be "
"reported dynamically depending on the host capabilities."
msgstr ""

#: ../../../interop/vhost-user.rst:1519
msgid ""
"The JSON output is described in the ``vhost-user.json`` schema, by "
"```@VHostUserBackendCapabilities``.  Example:"
msgstr ""

#: ../../../interop/vhost-user.rst:1522
msgid ""
"{\n"
"  \"type\": \"foo\",\n"
"  \"features\": [\n"
"    \"feature-a\",\n"
"    \"feature-b\"\n"
"  ]\n"
"}"
msgstr ""

#: ../../../interop/vhost-user.rst:1533
msgid "vhost-user-input"
msgstr ""

#: ../../../interop/vhost-user.rst:1535 ../../../interop/vhost-user.rst:1552
#: ../../../interop/vhost-user.rst:1569
msgid "Command line options:"
msgstr ""

#: ../../../interop/vhost-user.rst:1539
msgid "Specify the linux input device."
msgstr ""

#: ../../../interop/vhost-user.rst:1541 ../../../interop/vhost-user.rst:1547
#: ../../../interop/vhost-user.rst:1558 ../../../interop/vhost-user.rst:1564
#: ../../../interop/vhost-user.rst:1575 ../../../interop/vhost-user.rst:1581
msgid "(optional)"
msgstr ""

#: ../../../interop/vhost-user.rst:1545
msgid "Do no request exclusive access to the input device."
msgstr ""

#: ../../../interop/vhost-user.rst:1550
msgid "vhost-user-gpu"
msgstr ""

#: ../../../interop/vhost-user.rst:1556
msgid "Specify the GPU DRM render node."
msgstr ""

#: ../../../interop/vhost-user.rst:1562
msgid "Enable virgl rendering support."
msgstr ""

#: ../../../interop/vhost-user.rst:1567
msgid "vhost-user-blk"
msgstr ""

#: ../../../interop/vhost-user.rst:1573
msgid "Specify block device or file path."
msgstr ""

#: ../../../interop/vhost-user.rst:1579
msgid "Enable read-only."
msgstr ""
