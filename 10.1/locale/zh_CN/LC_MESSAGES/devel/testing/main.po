# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 10.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/testing/main.rst:4
msgid "Testing in QEMU"
msgstr ""

#: ../../../devel/testing/main.rst:6
msgid ""
"QEMU's testing infrastructure is fairly complex as it covers everything from "
"unit testing and exercising specific sub-systems all the way to full blown "
"functional tests. To get an overview of the tests you can run ``make check-"
"help`` from either the source or build tree."
msgstr ""

#: ../../../devel/testing/main.rst:12
msgid ""
"Most (but not all) tests are also integrated as an automated test into the "
"meson build system so can be run directly from the build tree, for example::"
msgstr ""

#: ../../../devel/testing/main.rst:16
msgid "[./pyvenv/bin/]meson test --suite qemu:softfloat"
msgstr ""

#: ../../../devel/testing/main.rst:18
msgid "will run just the softfloat tests."
msgstr ""

#: ../../../devel/testing/main.rst:20
msgid ""
"An automated test is written with one of the test frameworks using its "
"generic test functions/classes. The test framework can run the tests and "
"report their success or failure [1]_."
msgstr ""

#: ../../../devel/testing/main.rst:24
msgid "An automated test has essentially three parts:"
msgstr ""

#: ../../../devel/testing/main.rst:26
msgid ""
"The test initialization of the parameters, where the expected parameters, "
"like inputs and expected results, are set up;"
msgstr ""

#: ../../../devel/testing/main.rst:28
msgid "The call to the code that should be tested;"
msgstr ""

#: ../../../devel/testing/main.rst:29
msgid ""
"An assertion, comparing the result from the previous call with the expected "
"result set during the initialization of the parameters. If the result "
"matches the expected result, the test has been successful; otherwise, it has "
"failed."
msgstr ""

#: ../../../devel/testing/main.rst:34
msgid ""
"The rest of this document will cover the details for specific test groups."
msgstr ""

#: ../../../devel/testing/main.rst:38
msgid "Testing with \"make check\""
msgstr ""

#: ../../../devel/testing/main.rst:40
msgid ""
"The \"make check\" testing family includes most of the C based tests in QEMU."
msgstr ""

#: ../../../devel/testing/main.rst:42
msgid "The usual way to run these tests is:"
msgstr ""

#: ../../../devel/testing/main.rst:44
msgid "make check"
msgstr ""

#: ../../../devel/testing/main.rst:48
msgid ""
"which includes QAPI schema tests, unit tests, QTests and some iotests. "
"Different sub-types of \"make check\" tests will be explained below."
msgstr ""

#: ../../../devel/testing/main.rst:51
msgid ""
"Before running tests, it is best to build QEMU programs first. Some tests "
"expect the executables to exist and will fail with obscure messages if they "
"cannot find them."
msgstr ""

#: ../../../devel/testing/main.rst:58
msgid "Unit tests"
msgstr ""

#: ../../../devel/testing/main.rst:60
msgid ""
"A unit test is responsible for exercising individual software components as "
"a unit, like interfaces, data structures, and functionality, uncovering "
"errors within the boundaries of a component. The verification effort is in "
"the smallest software unit and focuses on the internal processing logic and "
"data structures. A test case of unit tests should be designed to uncover "
"errors due to erroneous computations, incorrect comparisons, or improper "
"control flow [2]_."
msgstr ""

#: ../../../devel/testing/main.rst:68
msgid ""
"In QEMU, unit tests can be invoked with ``make check-unit``. They are simple "
"C tests that typically link to individual QEMU object files and exercise "
"them by calling exported functions."
msgstr ""

#: ../../../devel/testing/main.rst:72
msgid ""
"If you are writing new code in QEMU, consider adding a unit test, especially "
"for utility modules that are relatively stateless or have few dependencies. "
"To add a new unit test:"
msgstr ""

#: ../../../devel/testing/main.rst:76
msgid "Create a new source file. For example, ``tests/unit/foo-test.c``."
msgstr ""

#: ../../../devel/testing/main.rst:78
msgid ""
"Write the test. Normally you would include the header file which exports the "
"module API, then verify the interface behaves as expected from your test. "
"The test code should be organized with the glib testing framework. Copying "
"and modifying an existing test is usually a good idea."
msgstr ""

#: ../../../devel/testing/main.rst:83
msgid ""
"Add the test to ``tests/unit/meson.build``. The unit tests are listed in a "
"dictionary called ``tests``.  The values are any additional sources and "
"dependencies to be linked with the test.  For a simple test whose source is "
"in ``tests/unit/foo-test.c``, it is enough to add an entry like::"
msgstr ""

#: ../../../devel/testing/main.rst:88
msgid ""
"{\n"
"  ...\n"
"  'foo-test': [],\n"
"  ...\n"
"}"
msgstr ""

#: ../../../devel/testing/main.rst:94
msgid ""
"Since unit tests don't require environment variables, the simplest way to "
"debug a unit test failure is often directly invoking it or even running it "
"under ``gdb``. However there can still be differences in behavior between "
"``make`` invocations and your manual run, due to ``$MALLOC_PERTURB_`` "
"environment variable (which affects memory reclamation and catches invalid "
"pointers better) and gtester options. If necessary, you can run"
msgstr ""

#: ../../../devel/testing/main.rst:101
msgid "make check-unit V=1"
msgstr ""

#: ../../../devel/testing/main.rst:105
msgid ""
"and copy the actual command line which executes the unit test, then run it "
"from the command line."
msgstr ""

#: ../../../devel/testing/main.rst:109
msgid "QTest"
msgstr ""

#: ../../../devel/testing/main.rst:111
msgid ""
"QTest is a device emulation testing framework.  It can be very useful to "
"test device models; it could also control certain aspects of QEMU (such as "
"virtual clock stepping), with a special purpose \"qtest\" protocol.  Refer "
"to :doc:`qtest` for more details."
msgstr ""

#: ../../../devel/testing/main.rst:116
msgid "QTest cases can be executed with"
msgstr ""

#: ../../../devel/testing/main.rst:118
msgid "make check-qtest"
msgstr ""

#: ../../../devel/testing/main.rst:123
msgid "Writing portable test cases"
msgstr ""

#: ../../../devel/testing/main.rst:124
msgid ""
"Both unit tests and qtests can run on POSIX hosts as well as Windows hosts. "
"Care must be taken when writing portable test cases that can be built and "
"run successfully on various hosts. The following list shows some best "
"practices:"
msgstr ""

#: ../../../devel/testing/main.rst:128
msgid ""
"Use portable APIs from glib whenever necessary, e.g.: g_setenv(), "
"g_mkdtemp(), g_mkdir()."
msgstr ""

#: ../../../devel/testing/main.rst:130
msgid ""
"Avoid using hardcoded /tmp for temporary file directory. Use g_get_tmp_dir() "
"instead."
msgstr ""

#: ../../../devel/testing/main.rst:132
msgid ""
"Bear in mind that Windows has different special string representation for "
"stdin/stdout/stderr and null devices. For example if your test case uses \"/"
"dev/fd/2\" and \"/dev/null\" on Linux, remember to use \"2\" and \"nul\" on "
"Windows instead. Also IO redirection does not work on Windows, so avoid "
"using \"2>nul\" whenever necessary."
msgstr ""

#: ../../../devel/testing/main.rst:137
msgid ""
"If your test cases uses the blkdebug feature, use relative path to pass the "
"config and image file paths in the command line as Windows absolute path "
"contains the delimiter \":\" which will confuse the blkdebug parser."
msgstr ""

#: ../../../devel/testing/main.rst:140
msgid ""
"Use double quotes in your extra QEMU command line in your test cases instead "
"of single quotes, as Windows does not drop single quotes when passing the "
"command line to QEMU."
msgstr ""

#: ../../../devel/testing/main.rst:143
msgid ""
"Windows opens a file in text mode by default, while a POSIX compliant "
"implementation treats text files and binary files the same. So if your test "
"cases opens a file to write some data and later wants to compare the written "
"data with the original one, be sure to pass the letter 'b' as part of the "
"mode string to fopen(), or O_BINARY flag for the open() call."
msgstr ""

#: ../../../devel/testing/main.rst:148
msgid ""
"If a certain test case can only run on POSIX or Linux hosts, use a proper "
"#ifdef in the codes. If the whole test suite cannot run on Windows, disable "
"the build in the meson.build file."
msgstr ""

#: ../../../devel/testing/main.rst:155
msgid "QAPI schema tests"
msgstr ""

#: ../../../devel/testing/main.rst:157
msgid ""
"The QAPI schema tests validate the QAPI parser used by QMP, by feeding "
"predefined input to the parser and comparing the result with the reference "
"output."
msgstr ""

#: ../../../devel/testing/main.rst:161
msgid ""
"The input/output data is managed under the ``tests/qapi-schema`` directory. "
"Each test case includes four files that have a common base name:"
msgstr ""

#: ../../../devel/testing/main.rst:164
msgid ""
"``${casename}.json`` - the file contains the JSON input for feeding the "
"parser"
msgstr ""

#: ../../../devel/testing/main.rst:166
msgid ""
"``${casename}.out`` - the file contains the expected stdout from the parser"
msgstr ""

#: ../../../devel/testing/main.rst:167
msgid ""
"``${casename}.err`` - the file contains the expected stderr from the parser"
msgstr ""

#: ../../../devel/testing/main.rst:168
msgid "``${casename}.exit`` - the expected error code"
msgstr ""

#: ../../../devel/testing/main.rst:170
msgid ""
"Consider adding a new QAPI schema test when you are making a change on the "
"QAPI parser (either fixing a bug or extending/modifying the syntax). To do "
"this:"
msgstr ""

#: ../../../devel/testing/main.rst:173
msgid "Add four files for the new case as explained above. For example:"
msgstr ""

#: ../../../devel/testing/main.rst:175
msgid "``$EDITOR tests/qapi-schema/foo.{json,out,err,exit}``."
msgstr ""

#: ../../../devel/testing/main.rst:177
msgid "Add the new test in ``tests/Makefile.include``. For example:"
msgstr ""

#: ../../../devel/testing/main.rst:179
msgid "``qapi-schema += foo.json``"
msgstr ""

#: ../../../devel/testing/main.rst:182
msgid "check-block"
msgstr ""

#: ../../../devel/testing/main.rst:184
msgid ""
"``make check-block`` runs a subset of the block layer iotests (the tests "
"that are in the \"auto\" group). See the \"QEMU iotests\" section below for "
"more information."
msgstr ""

#: ../../../devel/testing/main.rst:191
msgid "QEMU iotests"
msgstr ""

#: ../../../devel/testing/main.rst:193
msgid ""
"QEMU iotests, under the directory ``tests/qemu-iotests``, is the testing "
"framework widely used to test block layer related features. It is higher "
"level than \"make check\" tests and 99% of the code is written in bash or "
"Python scripts.  The testing success criteria is golden output comparison, "
"and the test files are named with numbers."
msgstr ""

#: ../../../devel/testing/main.rst:199
msgid ""
"To run iotests, make sure QEMU is built successfully, then switch to the "
"``tests/qemu-iotests`` directory under the build directory, and run ``./"
"check`` with desired arguments from there."
msgstr ""

#: ../../../devel/testing/main.rst:203
msgid ""
"By default, \"raw\" format and \"file\" protocol is used; all tests will be "
"executed, except the unsupported ones. You can override the format and "
"protocol with arguments:"
msgstr ""

#: ../../../devel/testing/main.rst:207
msgid ""
"# test with qcow2 format\n"
"./check -qcow2\n"
"# or test a different protocol\n"
"./check -nbd"
msgstr ""

#: ../../../devel/testing/main.rst:214
msgid "It's also possible to list test numbers explicitly:"
msgstr ""

#: ../../../devel/testing/main.rst:216
msgid ""
"# run selected cases with qcow2 format\n"
"./check -qcow2 001 030 153"
msgstr ""

#: ../../../devel/testing/main.rst:221
msgid ""
"Cache mode can be selected with the \"-c\" option, which may help reveal "
"bugs that are specific to certain cache mode."
msgstr ""

#: ../../../devel/testing/main.rst:224
msgid ""
"More options are supported by the ``./check`` script, run ``./check -h`` for "
"help."
msgstr ""

#: ../../../devel/testing/main.rst:228
msgid "Writing a new test case"
msgstr ""

#: ../../../devel/testing/main.rst:230
msgid ""
"Consider writing a tests case when you are making any changes to the block "
"layer. An iotest case is usually the choice for that. There are already many "
"test cases, so it is possible that extending one of them may achieve the "
"goal and save the boilerplate to create one.  (Unfortunately, there isn't a "
"100% reliable way to find a related one out of hundreds of tests.  One "
"approach is using ``git grep``.)"
msgstr ""

#: ../../../devel/testing/main.rst:237
msgid ""
"Usually an iotest case consists of two files. One is an executable that "
"produces output to stdout and stderr, the other is the expected reference "
"output. They are given the same number in file names. E.g. Test script "
"``055`` and reference output ``055.out``."
msgstr ""

#: ../../../devel/testing/main.rst:242
msgid ""
"In rare cases, when outputs differ between cache mode ``none`` and others, a "
"``.out.nocache`` file is added. In other cases, when outputs differ between "
"image formats, more than one ``.out`` files are created ending with the "
"respective format names, e.g. ``178.out.qcow2`` and ``178.out.raw``."
msgstr ""

#: ../../../devel/testing/main.rst:247
msgid ""
"There isn't a hard rule about how to write a test script, but a new test is "
"usually a (copy and) modification of an existing case.  There are a few "
"commonly used ways to create a test:"
msgstr ""

#: ../../../devel/testing/main.rst:251
msgid ""
"A Bash script. It will make use of several environmental variables related "
"to the testing procedure, and could source a group of ``common.*`` libraries "
"for some common helper routines."
msgstr ""

#: ../../../devel/testing/main.rst:255
msgid ""
"A Python unittest script. Import ``iotests`` and create a subclass of "
"``iotests.QMPTestCase``, then call ``iotests.main`` method. The downside of "
"this approach is that the output is too scarce, and the script is considered "
"harder to debug."
msgstr ""

#: ../../../devel/testing/main.rst:260
msgid ""
"A simple Python script without using unittest module. This could also import "
"``iotests`` for launching QEMU and utilities etc, but it doesn't inherit "
"from ``iotests.QMPTestCase`` therefore doesn't use the Python unittest "
"execution. This is a combination of 1 and 2."
msgstr ""

#: ../../../devel/testing/main.rst:265
msgid ""
"Pick the language per your preference since both Bash and Python have "
"comparable library support for invoking and interacting with QEMU programs. "
"If you opt for Python, it is strongly recommended to write Python 3 "
"compatible code."
msgstr ""

#: ../../../devel/testing/main.rst:270
msgid ""
"Both Python and Bash frameworks in iotests provide helpers to manage test "
"images. They can be used to create and clean up images under the test "
"directory. If no I/O or any protocol specific feature is needed, it is often "
"more convenient to use the pseudo block driver, ``null-co://``, as the test "
"image, which doesn't require image creation or cleaning up. Avoid system-"
"wide devices or files whenever possible, such as ``/dev/null`` or ``/dev/"
"zero``. Otherwise, image locking implications have to be considered.  For "
"example, another application on the host may have locked the file, possibly "
"leading to a test failure.  If using such devices are explicitly desired, "
"consider adding ``locking=off`` option to disable image locking."
msgstr ""

#: ../../../devel/testing/main.rst:282
msgid "Debugging a test case"
msgstr ""

#: ../../../devel/testing/main.rst:284
msgid ""
"The following options to the ``check`` script can be useful when debugging a "
"failing test:"
msgstr ""

#: ../../../devel/testing/main.rst:287
msgid ""
"``-gdb`` wraps every QEMU invocation in a ``gdbserver``, which waits for a "
"connection from a gdb client.  The options given to ``gdbserver`` (e.g. the "
"address on which to listen for connections) are taken from the "
"``$GDB_OPTIONS`` environment variable.  By default (if ``$GDB_OPTIONS`` is "
"empty), it listens on ``localhost:12345``. It is possible to connect to it "
"for example with ``gdb -iex \"target remote $addr\"``, where ``$addr`` is "
"the address ``gdbserver`` listens on. If the ``-gdb`` option is not used, "
"``$GDB_OPTIONS`` is ignored, regardless of whether it is set or not."
msgstr ""

#: ../../../devel/testing/main.rst:298
msgid ""
"``-valgrind`` attaches a valgrind instance to QEMU. If it detects warnings, "
"it will print and save the log in ``$TEST_DIR/<valgrind_pid>.valgrind``. The "
"final command line will be ``valgrind --log-file=$TEST_DIR/ <valgrind_pid>."
"valgrind --error-exitcode=99 $QEMU ...``"
msgstr ""

#: ../../../devel/testing/main.rst:304
msgid ""
"``-d`` (debug) just increases the logging verbosity, showing for example the "
"QMP commands and answers."
msgstr ""

#: ../../../devel/testing/main.rst:307
msgid ""
"``-p`` (print) redirects QEMU’s stdout and stderr to the test output, "
"instead of saving it into a log file in ``$TEST_DIR/qemu-machine-"
"<random_string>``."
msgstr ""

#: ../../../devel/testing/main.rst:312
msgid "Test case groups"
msgstr ""

#: ../../../devel/testing/main.rst:314
msgid ""
"\"Tests may belong to one or more test groups, which are defined in the form "
"of a comment in the test source file. By convention, test groups are listed "
"in the second line of the test file, after the \"#!/...\" line, like this:"
msgstr ""

#: ../../../devel/testing/main.rst:318
msgid ""
"#!/usr/bin/env python3\n"
"# group: auto quick\n"
"#\n"
"..."
msgstr ""

#: ../../../devel/testing/main.rst:325
msgid ""
"Another way of defining groups is creating the tests/qemu-iotests/group."
"local file. This should be used only for downstream (this file should never "
"appear in upstream). This file may be used for defining some downstream test "
"groups or for temporarily disabling tests, like this:"
msgstr ""

#: ../../../devel/testing/main.rst:330
msgid ""
"# groups for some company downstream process\n"
"#\n"
"# ci - tests to run on build\n"
"# down - our downstream tests, not for upstream\n"
"#\n"
"# Format of each line is:\n"
"# TEST_NAME TEST_GROUP [TEST_GROUP ]...\n"
"\n"
"013 ci\n"
"210 disabled\n"
"215 disabled\n"
"our-ugly-workaround-test down ci"
msgstr ""

#: ../../../devel/testing/main.rst:345
msgid "Note that the following group names have a special meaning:"
msgstr ""

#: ../../../devel/testing/main.rst:347
msgid "quick: Tests in this group should finish within a few seconds."
msgstr ""

#: ../../../devel/testing/main.rst:349
msgid ""
"auto: Tests in this group are used during \"make check\" and should be "
"runnable in any case. That means they should run with every QEMU binary "
"(also non-x86), with every QEMU configuration (i.e. must not fail if an "
"optional feature is not compiled in - but reporting a \"skip\" is ok), work "
"at least with the qcow2 file format, work with all kind of host filesystems "
"and users (e.g. \"nobody\" or \"root\") and must not take too much memory "
"and disk space (since CI pipelines tend to fail otherwise)."
msgstr ""

#: ../../../devel/testing/main.rst:357
msgid "disabled: Tests in this group are disabled and ignored by check."
msgstr ""

#: ../../../devel/testing/main.rst:362
msgid "Container based tests"
msgstr ""

#: ../../../devel/testing/main.rst:365
msgid "Introduction"
msgstr ""

#: ../../../devel/testing/main.rst:367
msgid ""
"The container testing framework in QEMU utilizes public images to build and "
"test QEMU in predefined and widely accessible Linux environments. This makes "
"it possible to expand the test coverage across distros, toolchain flavors "
"and library versions. The support was originally written for Docker although "
"we also support Podman as an alternative container runtime. Although many of "
"the target names and scripts are prefixed with \"docker\" the system will "
"automatically run on whichever is configured."
msgstr ""

#: ../../../devel/testing/main.rst:376
msgid ""
"The container images are also used to augment the generation of tests for "
"testing TCG. See :ref:`checktcg-ref` for more details."
msgstr ""

#: ../../../devel/testing/main.rst:380
msgid "Docker Prerequisites"
msgstr ""

#: ../../../devel/testing/main.rst:382
msgid ""
"Install \"docker\" with the system package manager and start the Docker "
"service on your development machine, then make sure you have the privilege "
"to run Docker commands. Typically it means setting up passwordless ``sudo "
"docker`` command or login as root. For example:"
msgstr ""

#: ../../../devel/testing/main.rst:387
msgid ""
"$ sudo yum install docker\n"
"$ # or `apt-get install docker` for Ubuntu, etc.\n"
"$ sudo systemctl start docker\n"
"$ sudo docker ps"
msgstr ""

#: ../../../devel/testing/main.rst:394 ../../../devel/testing/main.rst:420
msgid ""
"The last command should print an empty table, to verify the system is ready."
msgstr ""

#: ../../../devel/testing/main.rst:396
msgid ""
"An alternative method to set up permissions is by adding the current user to "
"\"docker\" group and making the docker daemon socket file (by default ``/var/"
"run/docker.sock``) accessible to the group:"
msgstr ""

#: ../../../devel/testing/main.rst:400
msgid ""
"$ sudo groupadd docker\n"
"$ sudo usermod $USER -a -G docker\n"
"$ sudo chown :docker /var/run/docker.sock"
msgstr ""

#: ../../../devel/testing/main.rst:406
msgid ""
"Note that any one of above configurations makes it possible for the user to "
"exploit the whole host with Docker bind mounting or other privileged "
"operations.  So only do it on development machines."
msgstr ""

#: ../../../devel/testing/main.rst:411
msgid "Podman Prerequisites"
msgstr ""

#: ../../../devel/testing/main.rst:413
msgid "Install \"podman\" with the system package manager."
msgstr ""

#: ../../../devel/testing/main.rst:415
msgid ""
"$ sudo dnf install podman\n"
"$ podman ps"
msgstr ""

#: ../../../devel/testing/main.rst:423 ../../../devel/testing/main.rst:800
msgid "Quickstart"
msgstr ""

#: ../../../devel/testing/main.rst:425
msgid ""
"From source tree, type ``make docker-help`` to see the help. Testing can be "
"started without configuring or building QEMU (``configure`` and ``make`` are "
"done in the container, with parameters defined by the make target):"
msgstr ""

#: ../../../devel/testing/main.rst:430
msgid "make docker-test-build@debian"
msgstr ""

#: ../../../devel/testing/main.rst:434
msgid ""
"This will create a container instance using the ``debian`` image (the image "
"is downloaded and initialized automatically), in which the ``test-build`` "
"job is executed."
msgstr ""

#: ../../../devel/testing/main.rst:439
msgid "Registry"
msgstr ""

#: ../../../devel/testing/main.rst:441
msgid ""
"The QEMU project has a container registry hosted by GitLab at ``registry."
"gitlab.com/qemu-project/qemu`` which will automatically be used to pull in "
"pre-built layers. This avoids unnecessary strain on the distro archives "
"created by multiple developers running the same container build steps over "
"and over again. This can be overridden locally by using the ``NOCACHE`` "
"build option:"
msgstr ""

#: ../../../devel/testing/main.rst:448
msgid "make docker-image-debian-arm64-cross NOCACHE=1"
msgstr ""

#: ../../../devel/testing/main.rst:453
msgid "Images"
msgstr ""

#: ../../../devel/testing/main.rst:455
msgid ""
"Along with many other images, the ``debian`` image is defined in a "
"Dockerfile in ``tests/docker/dockerfiles/``, called ``debian.docker``. "
"``make docker-help`` command will list all the available images."
msgstr ""

#: ../../../devel/testing/main.rst:459
msgid ""
"A ``.pre`` script can be added beside the ``.docker`` file, which will be "
"executed before building the image under the build context directory. This "
"is mainly used to do necessary host side setup. One such setup is "
"``binfmt_misc``, for example, to make qemu-user powered cross build "
"containers work."
msgstr ""

#: ../../../devel/testing/main.rst:464
msgid ""
"Most of the existing Dockerfiles were written by hand, simply by creating a "
"a new ``.docker`` file under the ``tests/docker/dockerfiles/`` directory. "
"This has led to an inconsistent set of packages being present across the "
"different containers."
msgstr ""

#: ../../../devel/testing/main.rst:469
msgid ""
"Thus going forward, QEMU is aiming to automatically generate the Dockerfiles "
"using the ``lcitool`` program provided by the ``libvirt-ci`` project:"
msgstr ""

#: ../../../devel/testing/main.rst:472
msgid "https://gitlab.com/libvirt/libvirt-ci"
msgstr ""

#: ../../../devel/testing/main.rst:474
msgid ""
"``libvirt-ci`` contains an ``lcitool`` program as well as a list of mappings "
"to distribution package names for a wide variety of third party projects.  "
"``lcitool`` applies the mappings to a list of build pre-requisites in "
"``tests/lcitool/projects/qemu.yml``, determines the list of native packages "
"to install on each distribution, and uses them to generate build "
"environments (dockerfiles and Cirrus CI variable files) that are consistent "
"across OS distribution."
msgstr ""

#: ../../../devel/testing/main.rst:484
msgid "Adding new build pre-requisites"
msgstr ""

#: ../../../devel/testing/main.rst:486
msgid ""
"When preparing a patch series that adds a new build pre-requisite to QEMU, "
"the prerequisites should to be added to ``tests/lcitool/projects/qemu.yml`` "
"in order to make the dependency available in the CI build environments."
msgstr ""

#: ../../../devel/testing/main.rst:491
msgid ""
"In the simple case where the pre-requisite is already known to ``libvirt-"
"ci`` the following steps are needed:"
msgstr ""

#: ../../../devel/testing/main.rst:494
msgid "Edit ``tests/lcitool/projects/qemu.yml`` and add the pre-requisite"
msgstr ""

#: ../../../devel/testing/main.rst:496
msgid ""
"Run ``make lcitool-refresh`` to re-generate all relevant build environment "
"manifests"
msgstr ""

#: ../../../devel/testing/main.rst:499
msgid ""
"It may be that ``libvirt-ci`` does not know about the new pre-requisite. If "
"that is the case, some extra preparation steps will be required first to "
"contribute the mapping to the ``libvirt-ci`` project:"
msgstr ""

#: ../../../devel/testing/main.rst:503 ../../../devel/testing/main.rst:559
msgid "Fork the ``libvirt-ci`` project on gitlab"
msgstr ""

#: ../../../devel/testing/main.rst:505
msgid ""
"Add an entry for the new build prerequisite to ``lcitool/facts/mappings."
"yml``, listing its native package name on as many OS distros as practical.  "
"Run ``python -m pytest --regenerate-output`` and check that the changes are "
"correct."
msgstr ""

#: ../../../devel/testing/main.rst:510
msgid ""
"Commit the ``mappings.yml`` change together with the regenerated test files, "
"and submit a merge request to the ``libvirt-ci`` project. Please note in the "
"description that this is a new build pre-requisite desired for use with QEMU."
msgstr ""

#: ../../../devel/testing/main.rst:515 ../../../devel/testing/main.rst:576
msgid ""
"CI pipeline will run to validate that the changes to ``mappings.yml`` are "
"correct, by attempting to install the newly listed package on all OS "
"distributions supported by ``libvirt-ci``."
msgstr ""

#: ../../../devel/testing/main.rst:519
msgid ""
"Once the merge request is accepted, go back to QEMU and update the ``tests/"
"lcitool/libvirt-ci`` submodule to point to a commit that contains the "
"``mappings.yml`` update.  Then add the prerequisite and run ``make lcitool-"
"refresh``."
msgstr ""

#: ../../../devel/testing/main.rst:524
msgid ""
"Please also trigger gitlab container generation pipelines on your change for "
"as many OS distros as practical to make sure that there are no obvious "
"breakages when adding the new pre-requisite. Please see `CI <https://www."
"qemu.org/docs/master/devel/ci.html>`__ documentation page on how to trigger "
"gitlab CI pipelines on your change."
msgstr ""

#: ../../../devel/testing/main.rst:530
msgid ""
"For enterprise distros that default to old, end-of-life versions of the "
"Python runtime, QEMU uses a separate set of mappings that work with more "
"recent versions.  These can be found in ``tests/lcitool/mappings.yml``. "
"Modifying this file should not be necessary unless the new pre-requisite is "
"a Python library or tool."
msgstr ""

#: ../../../devel/testing/main.rst:538
msgid "Adding new OS distros"
msgstr ""

#: ../../../devel/testing/main.rst:540
msgid ""
"In some cases ``libvirt-ci`` will not know about the OS distro that is "
"desired to be tested. Before adding a new OS distro, discuss the proposed "
"addition:"
msgstr ""

#: ../../../devel/testing/main.rst:544
msgid ""
"Send a mail to qemu-devel, copying people listed in the MAINTAINERS file for "
"``Build and test automation``."
msgstr ""

#: ../../../devel/testing/main.rst:547
msgid ""
"There are limited CI compute resources available to QEMU, so the cost/"
"benefit tradeoff of adding new OS distros needs to be considered."
msgstr ""

#: ../../../devel/testing/main.rst:550
msgid ""
"File an issue at https://gitlab.com/libvirt/libvirt-ci/-/issues pointing to "
"the qemu-devel mail thread in the archives."
msgstr ""

#: ../../../devel/testing/main.rst:553
msgid ""
"This alerts other people who might be interested in the work to avoid "
"duplication, as well as to get feedback from libvirt-ci maintainers on any "
"tips to ease the addition"
msgstr ""

#: ../../../devel/testing/main.rst:557
msgid "Assuming there is agreement to add a new OS distro then"
msgstr ""

#: ../../../devel/testing/main.rst:561
msgid ""
"Add metadata under ``lcitool/facts/targets/`` for the new OS distro. There "
"might be code changes required if the OS distro uses a package format not "
"currently known. The ``libvirt-ci`` maintainers can advise on this when the "
"issue is filed."
msgstr ""

#: ../../../devel/testing/main.rst:566
msgid ""
"Edit the ``lcitool/facts/mappings.yml`` change to add entries for the new "
"OS, listing the native package names for as many packages as practical.  Run "
"``python -m pytest --regenerate-output`` and check that the changes are "
"correct."
msgstr ""

#: ../../../devel/testing/main.rst:571
msgid ""
"Commit the changes to ``lcitool/facts`` and the regenerated test files, and "
"submit a merge request to the ``libvirt-ci`` project. Please note in the "
"description that this is a new build pre-requisite desired for use with QEMU"
msgstr ""

#: ../../../devel/testing/main.rst:580
msgid ""
"Once the merge request is accepted, go back to QEMU and update the ``libvirt-"
"ci`` submodule to point to a commit that contains the ``mappings.yml`` "
"update."
msgstr ""

#: ../../../devel/testing/main.rst:586
msgid "Tests"
msgstr ""

#: ../../../devel/testing/main.rst:588
msgid ""
"Different tests are added to cover various configurations to build and test "
"QEMU.  Docker tests are the executables under ``tests/docker`` named ``test-"
"*``. They are typically shell scripts and are built on top of a shell "
"library, ``tests/docker/common.rc``, which provides helpers to find the QEMU "
"source and build it."
msgstr ""

#: ../../../devel/testing/main.rst:594
msgid "The full list of tests is printed in the ``make docker-help`` help."
msgstr ""

#: ../../../devel/testing/main.rst:597
msgid "Debugging a Docker test failure"
msgstr ""

#: ../../../devel/testing/main.rst:599
msgid ""
"When CI tasks, maintainers or yourself report a Docker test failure, follow "
"the below steps to debug it:"
msgstr ""

#: ../../../devel/testing/main.rst:602
msgid ""
"Locally reproduce the failure with the reported command line. E.g. run "
"``make docker-test-mingw@fedora-win64-cross J=8``."
msgstr ""

#: ../../../devel/testing/main.rst:604
msgid "Add \"V=1\" to the command line, try again, to see the verbose output."
msgstr ""

#: ../../../devel/testing/main.rst:605
msgid ""
"Further add \"DEBUG=1\" to the command line. This will pause in a shell "
"prompt in the container right before testing starts. You could either "
"manually build QEMU and run tests from there, or press :kbd:`Ctrl+d` to let "
"the Docker testing continue."
msgstr ""

#: ../../../devel/testing/main.rst:609
msgid ""
"If you press :kbd:`Ctrl+d`, the same building and testing procedure will "
"begin, and will hopefully run into the error again. After that, you will be "
"dropped to the prompt for debug."
msgstr ""

#: ../../../devel/testing/main.rst:614
msgid "Options"
msgstr ""

#: ../../../devel/testing/main.rst:616
msgid ""
"Various options can be used to affect how Docker tests are done. The full "
"list is in the ``make docker`` help text. The frequently used ones are:"
msgstr ""

#: ../../../devel/testing/main.rst:619
msgid ""
"``V=1``: the same as in top level ``make``. It will be propagated to the "
"container and enable verbose output."
msgstr ""

#: ../../../devel/testing/main.rst:621
msgid ""
"``J=$N``: the number of parallel tasks in make commands in the container, "
"similar to the ``-j $N`` option in top level ``make``. (The ``-j`` option in "
"top level ``make`` will not be propagated into the container.)"
msgstr ""

#: ../../../devel/testing/main.rst:624
msgid ""
"``DEBUG=1``: enables debug. See the previous \"Debugging a Docker test "
"failure\" section."
msgstr ""

#: ../../../devel/testing/main.rst:628
msgid "Thread Sanitizer"
msgstr ""

#: ../../../devel/testing/main.rst:630
msgid ""
"Thread Sanitizer (TSan) is a tool which can detect data races.  QEMU "
"supports building and testing with this tool."
msgstr ""

#: ../../../devel/testing/main.rst:633
msgid "For more information on TSan:"
msgstr ""

#: ../../../devel/testing/main.rst:635
msgid "https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual"
msgstr ""

#: ../../../devel/testing/main.rst:638
msgid "Thread Sanitizer in Docker"
msgstr ""

#: ../../../devel/testing/main.rst:639
msgid "TSan is currently supported in the ubuntu2204 docker."
msgstr ""

#: ../../../devel/testing/main.rst:641
msgid "The test-tsan test will build using TSan and then run make check."
msgstr ""

#: ../../../devel/testing/main.rst:643
msgid "make docker-test-tsan@ubuntu2204"
msgstr ""

#: ../../../devel/testing/main.rst:647
msgid "TSan warnings under docker are placed in files located at build/tsan/."
msgstr ""

#: ../../../devel/testing/main.rst:649
msgid ""
"We recommend using DEBUG=1 to allow launching the test from inside the "
"docker, and to allow review of the warnings generated by TSan."
msgstr ""

#: ../../../devel/testing/main.rst:653
msgid "Building and Testing with TSan"
msgstr ""

#: ../../../devel/testing/main.rst:655
msgid ""
"It is possible to build and test with TSan, with a few additional steps. "
"These steps are normally done automatically in the docker."
msgstr ""

#: ../../../devel/testing/main.rst:658
msgid ""
"TSan is supported for clang and gcc. One particularity of sanitizers is that "
"all the code, including shared objects dependencies, should be built with "
"it. In the case of TSan, any synchronization primitive from glib (GMutex for "
"instance) will not be recognized, and will lead to false positives."
msgstr ""

#: ../../../devel/testing/main.rst:664
msgid "To build a tsan version of glib:"
msgstr ""

#: ../../../devel/testing/main.rst:666
msgid ""
"$ git clone --depth=1 --branch=2.81.0 https://github.com/GNOME/glib.git\n"
"$ cd glib\n"
"$ CFLAGS=\"-O2 -g -fsanitize=thread\" meson build\n"
"$ ninja -C build"
msgstr ""

#: ../../../devel/testing/main.rst:673
msgid "To configure the build for TSan:"
msgstr ""

#: ../../../devel/testing/main.rst:675
msgid ""
"../configure --enable-tsan \\\n"
"             --disable-werror --extra-cflags=\"-O0\""
msgstr ""

#: ../../../devel/testing/main.rst:680
msgid "When executing qemu, don't forget to point to tsan glib:"
msgstr ""

#: ../../../devel/testing/main.rst:682
msgid ""
"$ glib_dir=/path/to/glib\n"
"$ export LD_LIBRARY_PATH=$glib_dir/build/gio:$glib_dir/build/glib:$glib_dir/"
"build/gmodule:$glib_dir/build/gobject:$glib_dir/build/gthread\n"
"# check correct version is used\n"
"$ ldd build/qemu-x86_64 | grep glib\n"
"$ qemu-system-x86_64 ..."
msgstr ""

#: ../../../devel/testing/main.rst:690
msgid ""
"The runtime behavior of TSAN is controlled by the TSAN_OPTIONS environment "
"variable."
msgstr ""

#: ../../../devel/testing/main.rst:693
msgid "More information on the TSAN_OPTIONS can be found here:"
msgstr ""

#: ../../../devel/testing/main.rst:695 ../../../devel/testing/main.rst:735
msgid "https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags"
msgstr ""

#: ../../../devel/testing/main.rst:697
msgid "For example:"
msgstr ""

#: ../../../devel/testing/main.rst:699
msgid ""
"export TSAN_OPTIONS=suppressions=<path to qemu>/tests/tsan/suppressions.tsan "
"\\\n"
"                    detect_deadlocks=false history_size=7 exitcode=0 \\\n"
"                    log_path=<build path>/tsan/tsan_warning"
msgstr ""

#: ../../../devel/testing/main.rst:705
msgid ""
"The above exitcode=0 has TSan continue without error if any warnings are "
"found. This allows for running the test and then checking the warnings "
"afterwards. If you want TSan to stop and exit with error on warnings, use "
"exitcode=66."
msgstr ""

#: ../../../devel/testing/main.rst:712
msgid "TSan Suppressions"
msgstr ""

#: ../../../devel/testing/main.rst:713
msgid ""
"Keep in mind that for any data race warning, although there might be a data "
"race detected by TSan, there might be no actual bug here.  TSan provides "
"several different mechanisms for suppressing warnings.  In general it is "
"recommended to fix the code if possible to eliminate the data race rather "
"than suppress the warning."
msgstr ""

#: ../../../devel/testing/main.rst:719
msgid "A few important files for suppressing warnings are:"
msgstr ""

#: ../../../devel/testing/main.rst:721
msgid ""
"tests/tsan/suppressions.tsan - Has TSan warnings we wish to suppress at "
"runtime. The comment on each suppression will typically indicate why we are "
"suppressing it.  More information on the file format can be found here:"
msgstr ""

#: ../../../devel/testing/main.rst:725
msgid "https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions"
msgstr ""

#: ../../../devel/testing/main.rst:727
msgid ""
"tests/tsan/ignore.tsan - Has TSan warnings we wish to disable at compile "
"time for test or debug. Add flags to configure to enable:"
msgstr ""

#: ../../../devel/testing/main.rst:731
msgid ""
"\"--extra-cflags=-fsanitize-blacklist=<src path>/tests/tsan/ignore.tsan\""
msgstr ""

#: ../../../devel/testing/main.rst:733
msgid ""
"More information on the file format can be found here under \"Blacklist "
"Format\":"
msgstr ""

#: ../../../devel/testing/main.rst:738
msgid "TSan Annotations"
msgstr ""

#: ../../../devel/testing/main.rst:739
msgid ""
"include/qemu/tsan.h defines annotations.  See this file for more "
"descriptions of the annotations themselves.  Annotations can be used to "
"suppress TSan warnings or give TSan more information so that it can detect "
"proper relationships between accesses of data."
msgstr ""

#: ../../../devel/testing/main.rst:744
msgid "Annotation examples can be found here:"
msgstr ""

#: ../../../devel/testing/main.rst:746
msgid "https://github.com/llvm/llvm-project/tree/master/compiler-rt/test/tsan/"
msgstr ""

#: ../../../devel/testing/main.rst:748
msgid ""
"Good files to start with are: annotate_happens_before.cpp and ignore_race.cpp"
msgstr ""

#: ../../../devel/testing/main.rst:750
msgid "The full set of annotations can be found here:"
msgstr ""

#: ../../../devel/testing/main.rst:752
msgid ""
"https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/tsan/rtl/"
"tsan_interface_ann.cpp"
msgstr ""

#: ../../../devel/testing/main.rst:755
msgid "docker-binfmt-image-debian-% targets"
msgstr ""

#: ../../../devel/testing/main.rst:757
msgid ""
"It is possible to combine Debian's bootstrap scripts with a configured "
"``binfmt_misc`` to bootstrap a number of Debian's distros including "
"experimental ports not yet supported by a released OS. This can simplify "
"setting up a rootfs by using docker to contain the foreign rootfs rather "
"than manually invoking chroot."
msgstr ""

#: ../../../devel/testing/main.rst:764
msgid "Setting up ``binfmt_misc``"
msgstr ""

#: ../../../devel/testing/main.rst:766
msgid ""
"You can use the script ``qemu-binfmt-conf.sh`` to configure a QEMU user "
"binary to automatically run binaries for the foreign architecture. While the "
"scripts will try their best to work with dynamically linked QEMU's a "
"statically linked one will present less potential complications when copying "
"into the docker image. Modern kernels support the ``F`` (fix binary) flag "
"which will open the QEMU executable on setup and avoids the need to find and "
"re-open in the chroot environment. This is triggered with the ``--"
"persistent`` flag."
msgstr ""

#: ../../../devel/testing/main.rst:776
msgid "Example invocation"
msgstr ""

#: ../../../devel/testing/main.rst:778
msgid "For example to setup the HPPA ports builds of Debian::"
msgstr ""

#: ../../../devel/testing/main.rst:780
msgid ""
"make docker-binfmt-image-debian-sid-hppa \\\n"
"  DEB_TYPE=sid DEB_ARCH=hppa \\\n"
"  DEB_URL=http://ftp.ports.debian.org/debian-ports/ \\\n"
"  DEB_KEYRING=/usr/share/keyrings/debian-ports-archive-keyring.gpg \\\n"
"  EXECUTABLE=(pwd)/qemu-hppa V=1"
msgstr ""

#: ../../../devel/testing/main.rst:786
msgid ""
"The ``DEB_`` variables are substitutions used by ``debian-bootstrap.pre`` "
"which is called to do the initial debootstrap of the rootfs before it is "
"copied into the container. The second stage is run as part of the build. The "
"final image will be tagged as ``qemu/debian-sid-hppa``."
msgstr ""

#: ../../../devel/testing/main.rst:793
msgid "VM testing"
msgstr ""

#: ../../../devel/testing/main.rst:795
msgid ""
"This test suite contains scripts that bootstrap various guest images that "
"have necessary packages to build QEMU. The basic usage is documented in "
"``Makefile`` help which is displayed with ``make vm-help``."
msgstr ""

#: ../../../devel/testing/main.rst:802
msgid ""
"Run ``make vm-help`` to list available make targets. Invoke a specific make "
"command to run build test in an image. For example, ``make vm-build-"
"freebsd`` will build the source tree in the FreeBSD image. The command can "
"be executed from either the source tree or the build dir; if the former, ``./"
"configure`` is not needed. The command will then generate the test image in "
"``./tests/vm/`` under the working directory."
msgstr ""

#: ../../../devel/testing/main.rst:809
msgid ""
"Note: images created by the scripts accept a well-known RSA key pair for SSH "
"access, so they SHOULD NOT be exposed to external interfaces if you are "
"concerned about attackers taking control of the guest and potentially "
"exploiting a QEMU security bug to compromise the host."
msgstr ""

#: ../../../devel/testing/main.rst:815
msgid "QEMU binaries"
msgstr ""

#: ../../../devel/testing/main.rst:817
msgid ""
"By default, ``qemu-system-x86_64`` is searched in $PATH to run the guest. If "
"there isn't one, or if it is older than 2.10, the test won't work. In this "
"case, provide the QEMU binary in env var: ``QEMU=/path/to/qemu-2.10+``."
msgstr ""

#: ../../../devel/testing/main.rst:821
msgid ""
"Likewise the path to ``qemu-img`` can be set in QEMU_IMG environment "
"variable."
msgstr ""

#: ../../../devel/testing/main.rst:824
msgid "Make jobs"
msgstr ""

#: ../../../devel/testing/main.rst:826
msgid ""
"The ``-j$X`` option in the make command line is not propagated into the VM, "
"specify ``J=$X`` to control the make jobs in the guest."
msgstr ""

#: ../../../devel/testing/main.rst:830
msgid "Debugging"
msgstr ""

#: ../../../devel/testing/main.rst:832
msgid ""
"Add ``DEBUG=1`` and/or ``V=1`` to the make command to allow interactive "
"debugging and verbose output. If this is not enough, see the next section. "
"``V=1`` will be propagated down into the make jobs in the guest."
msgstr ""

#: ../../../devel/testing/main.rst:837
msgid "Manual invocation"
msgstr ""

#: ../../../devel/testing/main.rst:839
msgid ""
"Each guest script is an executable script with the same command line "
"options. For example to work with the netbsd guest, use ``$QEMU_SRC/tests/vm/"
"netbsd``:"
msgstr ""

#: ../../../devel/testing/main.rst:842
msgid ""
"$ cd $QEMU_SRC/tests/vm\n"
"\n"
"# To bootstrap the image\n"
"$ ./netbsd --build-image --image /var/tmp/netbsd.img\n"
"<...>\n"
"\n"
"# To run an arbitrary command in guest (the output will not be echoed "
"unless\n"
"# --debug is added)\n"
"$ ./netbsd --debug --image /var/tmp/netbsd.img uname -a\n"
"\n"
"# To build QEMU in guest\n"
"$ ./netbsd --debug --image /var/tmp/netbsd.img --build-qemu $QEMU_SRC\n"
"\n"
"# To get to an interactive shell\n"
"$ ./netbsd --interactive --image /var/tmp/netbsd.img sh"
msgstr ""

#: ../../../devel/testing/main.rst:861
msgid "Adding new guests"
msgstr ""

#: ../../../devel/testing/main.rst:863
msgid "Please look at existing guest scripts for how to add new guests."
msgstr ""

#: ../../../devel/testing/main.rst:865
msgid ""
"Most importantly, create a subclass of BaseVM and implement "
"``build_image()`` method and define ``BUILD_SCRIPT``, then finally call "
"``basevm.main()`` from the script's ``main()``."
msgstr ""

#: ../../../devel/testing/main.rst:869
msgid ""
"Usually in ``build_image()``, a template image is downloaded from a "
"predefined URL. ``BaseVM._download_with_cache()`` takes care of the cache "
"and the checksum, so consider using it."
msgstr ""

#: ../../../devel/testing/main.rst:873
msgid ""
"Once the image is downloaded, users, SSH server and QEMU build deps should "
"be set up:"
msgstr ""

#: ../../../devel/testing/main.rst:876
msgid "Root password set to ``BaseVM.ROOT_PASS``"
msgstr ""

#: ../../../devel/testing/main.rst:877
msgid ""
"User ``BaseVM.GUEST_USER`` is created, and password set to ``BaseVM."
"GUEST_PASS``"
msgstr ""

#: ../../../devel/testing/main.rst:879
msgid ""
"SSH service is enabled and started on boot, ``$QEMU_SRC/tests/keys/id_rsa."
"pub`` is added to ssh's ``authorized_keys`` file of both root and the normal "
"user"
msgstr ""

#: ../../../devel/testing/main.rst:882
msgid ""
"DHCP client service is enabled and started on boot, so that it can "
"automatically configure the virtio-net-pci NIC and communicate with QEMU "
"user net (10.0.2.2)"
msgstr ""

#: ../../../devel/testing/main.rst:885
msgid ""
"Necessary packages are installed to untar the source tarball and build QEMU"
msgstr ""

#: ../../../devel/testing/main.rst:888
msgid ""
"Write a proper ``BUILD_SCRIPT`` template, which should be a shell script "
"that untars a raw virtio-blk block device, which is the tarball data blob of "
"the QEMU source tree, then configure/build it. Running \"make check\" is "
"also recommended."
msgstr ""

#: ../../../devel/testing/main.rst:894
msgid "Image fuzzer testing"
msgstr ""

#: ../../../devel/testing/main.rst:896
msgid ""
"An image fuzzer was added to exercise format drivers. Currently only qcow2 "
"is supported. To start the fuzzer, run"
msgstr ""

#: ../../../devel/testing/main.rst:899
msgid ""
"tests/image-fuzzer/runner.py -c '[[\"qemu-img\", \"info\", \"$test_img\"]]' /"
"tmp/test qcow2"
msgstr ""

#: ../../../devel/testing/main.rst:903
msgid ""
"Alternatively, some command different from ``qemu-img info`` can be tested, "
"by changing the ``-c`` option."
msgstr ""

#: ../../../devel/testing/main.rst:907
msgid "Functional tests using Python"
msgstr ""

#: ../../../devel/testing/main.rst:909
msgid ""
"A functional test focuses on the functional requirement of the software, "
"attempting to find errors like incorrect functions, interface errors, "
"behavior errors, and initialization and termination errors [3]_."
msgstr ""

#: ../../../devel/testing/main.rst:913
msgid ""
"The ``tests/functional`` directory hosts functional tests written in Python. "
"You can run the functional tests simply by executing:"
msgstr ""

#: ../../../devel/testing/main.rst:916
msgid "make check-functional"
msgstr ""

#: ../../../devel/testing/main.rst:920
msgid "See :ref:`checkfunctional-ref` for more details."
msgstr ""

#: ../../../devel/testing/main.rst:925
msgid "Testing with \"make check-tcg\""
msgstr ""

#: ../../../devel/testing/main.rst:927
msgid ""
"The check-tcg tests are intended for simple smoke tests of both linux-user "
"and softmmu TCG functionality. However to build test programs for guest "
"targets you need to have cross compilers available. If your distribution "
"supports cross compilers you can do something as simple as::"
msgstr ""

#: ../../../devel/testing/main.rst:933
msgid "apt install gcc-aarch64-linux-gnu"
msgstr ""

#: ../../../devel/testing/main.rst:935
msgid ""
"The configure script will automatically pick up their presence. Sometimes "
"compilers have slightly odd names so the availability of them can be "
"prompted by passing in the appropriate configure option for the architecture "
"in question, for example::"
msgstr ""

#: ../../../devel/testing/main.rst:940
msgid "$(configure) --cross-cc-aarch64=aarch64-cc"
msgstr ""

#: ../../../devel/testing/main.rst:942
msgid ""
"There is also a ``--cross-cc-cflags-ARCH`` flag in case additional compiler "
"flags are needed to build for a given target."
msgstr ""

#: ../../../devel/testing/main.rst:945
msgid ""
"If you have the ability to run containers as the user the build system will "
"automatically use them where no system compiler is available. For "
"architectures where we also support building QEMU we will generally use the "
"same container to build tests. However there are a number of additional "
"containers defined that have a minimal cross-build environment that is only "
"suitable for building test cases. Sometimes we may use a bleeding edge "
"distribution for compiler features needed for test cases that aren't yet in "
"the LTS distros we support for QEMU itself."
msgstr ""

#: ../../../devel/testing/main.rst:955
msgid "See :ref:`container-ref` for more details."
msgstr ""

#: ../../../devel/testing/main.rst:958
msgid "Running subset of tests"
msgstr ""

#: ../../../devel/testing/main.rst:960
msgid "You can build the tests for one architecture::"
msgstr ""

#: ../../../devel/testing/main.rst:962
msgid "make build-tcg-tests-$TARGET"
msgstr ""

#: ../../../devel/testing/main.rst:964
msgid "And run with::"
msgstr ""

#: ../../../devel/testing/main.rst:966
msgid "make run-tcg-tests-$TARGET"
msgstr ""

#: ../../../devel/testing/main.rst:968
msgid ""
"Adding ``V=1`` to the invocation will show the details of how to invoke QEMU "
"for the test which is useful for debugging tests."
msgstr ""

#: ../../../devel/testing/main.rst:972
msgid "Running individual tests"
msgstr ""

#: ../../../devel/testing/main.rst:974
msgid ""
"Tests can also be run directly from the test build directory. If you run "
"``make help`` from the test build directory you will get a list of all the "
"tests that can be run. Please note that same binaries are used in multiple "
"tests, for example::"
msgstr ""

#: ../../../devel/testing/main.rst:979
msgid "make run-plugin-test-mmap-with-libinline.so"
msgstr ""

#: ../../../devel/testing/main.rst:981
msgid ""
"will run the mmap test with the ``libinline.so`` TCG plugin. The gdbstub "
"tests also re-use the test binaries but while exercising gdb."
msgstr ""

#: ../../../devel/testing/main.rst:985
msgid "TCG test dependencies"
msgstr ""

#: ../../../devel/testing/main.rst:987
msgid ""
"The TCG tests are deliberately very light on dependencies and are either "
"totally bare with minimal gcc lib support (for system-mode tests) or just "
"glibc (for linux-user tests). This is because getting a cross compiler to "
"work with additional libraries can be challenging."
msgstr ""

#: ../../../devel/testing/main.rst:993
msgid "Other TCG Tests"
msgstr ""

#: ../../../devel/testing/main.rst:995
msgid ""
"There are a number of out-of-tree test suites that are used for more "
"extensive testing of processor features."
msgstr ""

#: ../../../devel/testing/main.rst:999
msgid "KVM Unit Tests"
msgstr ""

#: ../../../devel/testing/main.rst:1001
msgid ""
"The KVM unit tests are designed to run as a Guest OS under KVM but there is "
"no reason why they can't exercise the TCG as well. It provides a minimal OS "
"kernel with hooks for enabling the MMU as well as reporting test results via "
"a special device::"
msgstr ""

#: ../../../devel/testing/main.rst:1006
msgid "https://git.kernel.org/pub/scm/virt/kvm/kvm-unit-tests.git"
msgstr ""

#: ../../../devel/testing/main.rst:1009
msgid "Linux Test Project"
msgstr ""

#: ../../../devel/testing/main.rst:1011
msgid ""
"The LTP is focused on exercising the syscall interface of a Linux kernel. It "
"checks that syscalls behave as documented and strives to exercise as many "
"corner cases as possible. It is a useful test suite to run to exercise "
"QEMU's linux-user code::"
msgstr ""

#: ../../../devel/testing/main.rst:1016
msgid "https://linux-test-project.github.io/"
msgstr ""

#: ../../../devel/testing/main.rst:1019
msgid "GCC gcov support"
msgstr ""

#: ../../../devel/testing/main.rst:1021
msgid ""
"``gcov`` is a GCC tool to analyze the testing coverage by instrumenting the "
"tested code. To use it, configure QEMU with ``--enable-gcov`` option and "
"build. Then run the tests as usual."
msgstr ""

#: ../../../devel/testing/main.rst:1025
msgid ""
"If you want to gather coverage information on a single test the ``make clean-"
"gcda`` target can be used to delete any existing coverage information before "
"running a single test."
msgstr ""

#: ../../../devel/testing/main.rst:1029
msgid ""
"You can generate a HTML coverage report by executing ``make coverage-html`` "
"which will create ``meson-logs/coveragereport/index.html``."
msgstr ""

#: ../../../devel/testing/main.rst:1033
msgid ""
"Further analysis can be conducted by running the ``gcov`` command directly "
"on the various .gcda output files. Please read the ``gcov`` documentation "
"for more information."
msgstr ""

#: ../../../devel/testing/main.rst:1038
msgid "Flaky tests"
msgstr ""

#: ../../../devel/testing/main.rst:1040
msgid ""
"A flaky test is defined as a test that exhibits both a passing and a failing "
"result with the same code on different runs. Some usual reasons for an "
"intermittent/flaky test are async wait, concurrency, and test order "
"dependency [4]_."
msgstr ""

#: ../../../devel/testing/main.rst:1045
msgid ""
"In QEMU, tests that are identified to be flaky are normally disabled by "
"default. Set the QEMU_TEST_FLAKY_TESTS environment variable before running "
"the tests to enable them."
msgstr ""

#: ../../../devel/testing/main.rst:1050
msgid "References"
msgstr ""

#: ../../../devel/testing/main.rst:1052
msgid "Sommerville, Ian (2016). Software Engineering. p. 233."
msgstr ""

#: ../../../devel/testing/main.rst:1053
msgid ""
"Pressman, Roger S. & Maxim, Bruce R. (2020). Software Engineering, A "
"Practitioner’s Approach. p. 48, 376, 378, 381."
msgstr ""

#: ../../../devel/testing/main.rst:1055
msgid ""
"Pressman, Roger S. & Maxim, Bruce R. (2020). Software Engineering, A "
"Practitioner’s Approach. p. 388."
msgstr ""

#: ../../../devel/testing/main.rst:1057
msgid ""
"Luo, Qingzhou, et al. An empirical analysis of flaky tests. Proceedings of "
"the 22nd ACM SIGSOFT International Symposium on Foundations of Software "
"Engineering. 2014."
msgstr ""
