# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 10.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/uefi-vars.rst:3
msgid "UEFI variables"
msgstr ""

#: ../../../devel/uefi-vars.rst:6
msgid "Guest UEFI variable management"
msgstr ""

#: ../../../devel/uefi-vars.rst:8
msgid ""
"The traditional approach for UEFI Variable storage in qemu guests is to work "
"as close as possible to physical hardware.  That means providing pflash as "
"storage and leaving the management of variables and flash to the guest."
msgstr ""

#: ../../../devel/uefi-vars.rst:13
msgid ""
"Secure boot support comes with the requirement that the UEFI variable "
"storage must be protected against direct access by the OS.  All update "
"requests must pass the sanity checks.  (Parts of) the firmware must run with "
"a higher privilege level than the OS so this can be enforced by the "
"firmware.  On x86 this has been implemented using System Management Mode "
"(SMM) in qemu and kvm, which again is the same approach taken by physical "
"hardware.  Only privileged code running in SMM mode is allowed to access "
"flash storage."
msgstr ""

#: ../../../devel/uefi-vars.rst:22
msgid ""
"Communication with the firmware code running in SMM mode works by "
"serializing the requests to a shared buffer, then trapping into SMM mode via "
"SMI.  The SMM code processes the request, stores the reply in the same "
"buffer and returns."
msgstr ""

#: ../../../devel/uefi-vars.rst:28
msgid "Host UEFI variable service"
msgstr ""

#: ../../../devel/uefi-vars.rst:30
msgid ""
"Instead of running the privileged code inside the guest we can run it on the "
"host.  The serialization protocol can be reused.  The communication with the "
"host uses a virtual device, which essentially configures the shared buffer "
"location and size, and traps to the host to process the requests."
msgstr ""

#: ../../../devel/uefi-vars.rst:36
msgid ""
"The ``uefi-vars`` device implements the UEFI virtual device.  It comes in "
"``uefi-vars-x64`` and ``uefi-vars-sysbus`` flavours.  The device "
"reimplements the handlers needed, specifically ``EfiSmmVariableProtocol`` "
"and ``VarCheckPolicyLibMmiHandler``.  It also consumes events "
"(``EfiEndOfDxeEventGroup``, ``EfiEventReadyToBoot`` and "
"``EfiEventExitBootServices``)."
msgstr ""

#: ../../../devel/uefi-vars.rst:43
msgid ""
"The advantage of the approach is that we do not need a special privilege "
"level for the firmware to protect itself, i.e. it does not depend on SMM "
"emulation on x64, which allows the removal of a bunch of complex code for "
"SMM emulation from the linux kernel (CONFIG_KVM_SMM=n).  It also allows "
"support for secure boot on arm without implementing secure world (el3) "
"emulation in kvm."
msgstr ""

#: ../../../devel/uefi-vars.rst:50
msgid ""
"Of course there are also downsides.  The added device increases the attack "
"surface of the host, and we are adding some code duplication because we have "
"to reimplement some edk2 functionality in qemu."
msgstr ""

#: ../../../devel/uefi-vars.rst:55
msgid "usage on x86_64"
msgstr ""

#: ../../../devel/uefi-vars.rst:57
msgid ""
"qemu-system-x86_64 \\\n"
"   -device uefi-vars-x64,jsonfile=/path/to/vars.json"
msgstr ""

#: ../../../devel/uefi-vars.rst:63
msgid "usage on aarch64"
msgstr ""

#: ../../../devel/uefi-vars.rst:65
msgid ""
"qemu-system-aarch64 -M virt \\\n"
"   -device uefi-vars-sysbus,jsonfile=/path/to/vars.json"
msgstr ""
