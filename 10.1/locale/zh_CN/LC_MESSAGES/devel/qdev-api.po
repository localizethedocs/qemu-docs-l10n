# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 10.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/qdev-api.rst:5
msgid "QEMU Device (qdev) API Reference"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1
msgid "**The QEMU Device API**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:15
msgid ""
"All modern devices should represented as a derived QOM class of TYPE_DEVICE. "
"The device API introduces the additional methods of **realize** and "
"**unrealize** to represent additional stages in a device objects life cycle."
msgstr ""

#: ../../../../include/hw/qdev-core.h:23
msgid "Devices are constructed in two stages:"
msgstr ""

#: ../../../../include/hw/qdev-core.h:25
msgid "object instantiation via object_initialize() and"
msgstr ""

#: ../../../../include/hw/qdev-core.h:26
msgid ""
"device realization via the :c:type:`DeviceState.realized <DeviceState>` "
"property"
msgstr ""

#: ../../../../include/hw/qdev-core.h:28
msgid ""
"The former may not fail (and must not abort or exit, since it is called "
"during device introspection already), and the latter may return error "
"information to the caller and must be re-entrant. Trivial field "
"initializations should go into :c:type:`TypeInfo.instance_init <TypeInfo>`. "
"Operations depending on **props** static properties should go into "
"**realize**. After successful realization, setting static properties will "
"fail."
msgstr ""

#: ../../../../include/hw/qdev-core.h:35
msgid ""
"As an interim step, the :c:type:`DeviceState.realized <DeviceState>` "
"property can also be set with qdev_realize(). In the future, devices will "
"propagate this state change to their children and along busses they expose. "
"The point in time will be deferred to machine creation, so that values set "
"in **realize** will not be introspectable beforehand. Therefore devices must "
"not create children during **realize**; they should initialize them via "
"object_initialize() in their own :c:type:`TypeInfo.instance_init <TypeInfo>` "
"and forward the realization events appropriately."
msgstr ""

#: ../../../../include/hw/qdev-core.h:45
msgid ""
"Any type may override the **realize** and/or **unrealize** callbacks but "
"needs to call the parent type's implementation if keeping their "
"functionality is desired. Refer to QOM documentation for further discussion "
"and examples."
msgstr ""

#: ../../../../include/hw/qdev-core.h:50
msgid ""
"Since TYPE_DEVICE doesn't implement **realize** and **unrealize**, types "
"derived directly from it need not call their parent's **realize** and "
"**unrealize**. For other types consult the documentation and implementation "
"of the respective parent types."
msgstr ""

#: ../../../../include/hw/qdev-core.h:58
msgid ""
"To hide a device, a DeviceListener function hide_device() needs to be "
"registered. It can be used to defer adding a device and therefore hide it "
"from the guest. The handler registering to this DeviceListener can save the "
"QOpts passed to it for re-using it later. It must return if it wants the "
"device to be hidden or visible. When the handler function decides the device "
"shall be visible it will be added with qdev_device_add() and realized as any "
"other device. Otherwise qdev_device_add() will return early without adding "
"the device. The guest will not see a \"hidden\" device until it was marked "
"visible and qdev_device_add called again."
msgstr ""

#: ../../../../include/hw/qdev-core.h:101
msgid "The base class for all devices."
msgstr ""

#: ../../../../include/hw/qdev-core.h:103
#: ../../../../include/hw/qdev-core.h:223
#: ../../../../include/hw/qdev-core.h:371
msgid "**Definition**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:107
msgid ""
"struct DeviceClass {\n"
"  unsigned long categories[BITS_TO_LONGS(DEVICE_CATEGORY_MAX)];\n"
"  const char *fw_name;\n"
"  const char *desc;\n"
"  const Property *props_;\n"
"  uint16_t props_count_;\n"
"  bool user_creatable;\n"
"  bool hotpluggable;\n"
"  DeviceReset legacy_reset;\n"
"  DeviceRealize realize;\n"
"  DeviceUnrealize unrealize;\n"
"  DeviceSyncConfig sync_config;\n"
"  const VMStateDescription *vmsd;\n"
"  const char *bus_type;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:123
#: ../../../../include/hw/qdev-core.h:247
#: ../../../../include/hw/qdev-core.h:388
msgid "**Members**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:121
msgid "``categories``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:122
msgid "device categories device belongs to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:125
msgid "``fw_name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:126
msgid "name used to identify device to firmware interfaces"
msgstr ""

#: ../../../../include/hw/qdev-core.h:129
msgid "``desc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:130
msgid "human readable description of device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:134
msgid "``props_``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:135
msgid ""
"properties associated with device, should only be assigned by using "
"device_class_set_props(). The underscore ensures a compile-time error if "
"someone attempts to assign dc->props directly."
msgstr ""

#: ../../../../include/hw/qdev-core.h:142
msgid "``props_count_``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:143
msgid ""
"number of elements in **props_**; should only be assigned by using "
"device_class_set_props()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:148
msgid "``user_creatable``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:149
msgid "Can user instantiate with -device / device_add?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:151
msgid ""
"All devices should support instantiation with device_add, and this flag "
"should not exist.  But we're not there, yet.  Some devices fail to "
"instantiate with cryptic error messages. Others instantiate, but don't "
"work.  Exposing users to such behavior would be cruel; clearing this flag "
"will protect them. It should never be cleared without a comment explaining "
"why it is cleared."
msgstr ""

#: ../../../../include/hw/qdev-core.h:159
msgid "TODO remove once we're there"
msgstr ""

#: ../../../../include/hw/qdev-core.h:110
msgid "``hotpluggable``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:111
msgid ""
"indicates if :c:type:`DeviceClass <DeviceClass>` is hotpluggable, available "
"as readonly \"hotpluggable\" property of :c:type:`DeviceState <DeviceState>` "
"instance"
msgstr ""

#: ../../../../include/hw/qdev-core.h:165
msgid "``legacy_reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:166
msgid "deprecated device reset method pointer"
msgstr ""

#: ../../../../include/hw/qdev-core.h:168
msgid ""
"Modern code should use the ResettableClass interface to implement a multi-"
"phase reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:171
msgid "TODO: remove once every reset callback is unused"
msgstr ""

#: ../../../../include/hw/qdev-core.h:103
msgid "``realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:104
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``true``."
msgstr ""

#: ../../../../include/hw/qdev-core.h:105
msgid "``unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:106
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``false``."
msgstr ""

#: ../../../../include/hw/qdev-core.h:107
msgid "``sync_config``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:108
msgid ""
"Callback function invoked when QMP command device-sync-config is called. "
"Should synchronize device configuration from host to guest part and notify "
"the guest about the change."
msgstr ""

#: ../../../../include/hw/qdev-core.h:178
msgid "``vmsd``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:179
msgid "device state serialisation description for migration/save/restore"
msgstr ""

#: ../../../../include/hw/qdev-core.h:184
msgid "``bus_type``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:185
msgid "bus type private: to qdev / bus."
msgstr ""

#: ../../../../include/hw/qdev-core.h:221
msgid "common device state, accessed with qdev helpers"
msgstr ""

#: ../../../../include/hw/qdev-core.h:227
msgid ""
"struct DeviceState {\n"
"  char *id;\n"
"  char *canonical_path;\n"
"  bool realized;\n"
"  bool pending_deleted_event;\n"
"  int64_t pending_deleted_expires_ms;\n"
"  int hotplugged;\n"
"  bool allow_unplug_during_migration;\n"
"  BusState *parent_bus;\n"
"  NamedGPIOListHead gpios;\n"
"  NamedClockListHead clocks;\n"
"  BusStateHead child_bus;\n"
"  int num_child_bus;\n"
"  int instance_id_alias;\n"
"  int alias_required_for_version;\n"
"  ResettableState reset;\n"
"  GSList *unplug_blockers;\n"
"  MemReentrancyGuard mem_reentrancy_guard;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:232
msgid "``id``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:233
msgid "global device id"
msgstr ""

#: ../../../../include/hw/qdev-core.h:236
msgid "``canonical_path``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:237
msgid "canonical path of realized device in the QOM tree"
msgstr ""

#: ../../../../include/hw/qdev-core.h:240
#: ../../../../include/hw/qdev-core.h:376
msgid "``realized``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:241
msgid "has device been realized?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:244
msgid "``pending_deleted_event``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:245
msgid "track pending deletion events during unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:248
msgid "``pending_deleted_expires_ms``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:249
msgid "optional timeout for deletion events"
msgstr ""

#: ../../../../include/hw/qdev-core.h:252
msgid "``hotplugged``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:253
msgid "was device added after PHASE_MACHINE_READY?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:256
msgid "``allow_unplug_during_migration``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:257
msgid "can device be unplugged during migration"
msgstr ""

#: ../../../../include/hw/qdev-core.h:260
msgid "``parent_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:261
msgid "bus this device belongs to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:264
msgid "``gpios``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:265
msgid "QLIST of named GPIOs the device provides."
msgstr ""

#: ../../../../include/hw/qdev-core.h:268
msgid "``clocks``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:269
msgid "QLIST of named clocks the device provides."
msgstr ""

#: ../../../../include/hw/qdev-core.h:272
msgid "``child_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:273
msgid "QLIST of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:276
msgid "``num_child_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:277
msgid "number of **child_bus** entries"
msgstr ""

#: ../../../../include/hw/qdev-core.h:280
msgid "``instance_id_alias``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:281
msgid "device alias for handling legacy migration setups"
msgstr ""

#: ../../../../include/hw/qdev-core.h:284
msgid "``alias_required_for_version``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:285
msgid "indicates **instance_id_alias** is needed for migration"
msgstr ""

#: ../../../../include/hw/qdev-core.h:289
#: ../../../../include/hw/qdev-core.h:402
msgid "``reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:290
msgid "ResettableState for the device; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/qdev-core.h:293
msgid "``unplug_blockers``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:294
msgid "list of reasons to block unplugging of device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:297
msgid "``mem_reentrancy_guard``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:298
msgid "Is the device currently in mmio/pio/dma?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:300
msgid "Used to prevent re-entrancy confusing things."
msgstr ""

#: ../../../../include/hw/qdev-core.h:303
#: ../../../../include/hw/qdev-core.h:410
#: ../../../../include/hw/qdev-core.h:440
#: ../../../../include/hw/qdev-core.h:452
#: ../../../../include/hw/qdev-core.h:478
#: ../../../../include/hw/qdev-core.h:497
#: ../../../../include/hw/qdev-core.h:523
#: ../../../../include/hw/qdev-core.h:595
#: ../../../../include/hw/qdev-core.h:613
#: ../../../../include/hw/qdev-core.h:636
#: ../../../../include/hw/qdev-core.h:656
#: ../../../../include/hw/qdev-core.h:689
#: ../../../../include/hw/qdev-core.h:716
#: ../../../../include/hw/qdev-core.h:737
#: ../../../../include/hw/qdev-core.h:762
#: ../../../../include/hw/qdev-core.h:781
#: ../../../../include/hw/qdev-core.h:811
#: ../../../../include/hw/qdev-core.h:838
#: ../../../../include/hw/qdev-core.h:854
#: ../../../../include/hw/qdev-core.h:902
#: ../../../../include/hw/qdev-core.h:911
#: ../../../../include/hw/qdev-core.h:943
#: ../../../../include/hw/qdev-core.h:968
#: ../../../../include/hw/qdev-core.h:980
#: ../../../../include/hw/qdev-core.h:995
#: ../../../../include/hw/qdev-core.h:1010
#: ../../../../include/hw/qdev-core.h:1035
#: ../../../../include/hw/qdev-core.h:1041
#: ../../../../include/hw/qdev-core.h:1051
#: ../../../../include/hw/qdev-core.h:1091
#: ../../../../include/hw/qdev-core.h:1120
msgid "**Description**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:223
msgid ""
"This structure should not be accessed directly.  We declare it here so that "
"it can be embedded in individual device state structures."
msgstr ""

#: ../../../../include/hw/qdev-core.h:375
msgid ""
"struct BusState {\n"
"  DeviceState *parent;\n"
"  char *name;\n"
"  HotplugHandler *hotplug_handler;\n"
"  int max_index;\n"
"  bool realized;\n"
"  bool full;\n"
"  int num_children;\n"
"  BusChildHead children;\n"
"  BusStateEntry sibling;\n"
"  ResettableState reset;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:372
msgid "``parent``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:373
msgid "parent Device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:373
msgid "``name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:374
msgid "name of bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:374
msgid "``hotplug_handler``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:375
msgid "link to a hotplug handler associated with bus."
msgstr ""

#: ../../../../include/hw/qdev-core.h:375
msgid "``max_index``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:376
msgid "max number of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:377
msgid "is the bus itself realized?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:377
msgid "``full``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:378
msgid "is the bus full?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:378
msgid "``num_children``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:379
msgid "current number of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:393
msgid "``children``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:394
msgid ""
"an RCU protected QTAILQ, thus readers must use RCU to access it, and writers "
"must hold the big qemu lock"
msgstr ""

#: ../../../../include/hw/qdev-core.h:398
msgid "``sibling``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:399
msgid "next bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:403
msgid "ResettableState for the bus; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/qdev-core.h:408
msgid "a global property type"
msgstr ""

#: ../../../../include/hw/qdev-core.h:414
msgid ""
"An error is fatal for non-hotplugged devices, when the global is applied."
msgstr ""

#: ../../../../include/hw/qdev-core.h:437
msgid "Create a device on the heap"
msgstr ""

#: ../../../../include/hw/qdev-core.h:439
#: ../../../../include/hw/qdev-core.h:451
#: ../../../../include/hw/qdev-core.h:463
#: ../../../../include/hw/qdev-core.h:475
#: ../../../../include/hw/qdev-core.h:494
#: ../../../../include/hw/qdev-core.h:522
#: ../../../../include/hw/qdev-core.h:549
#: ../../../../include/hw/qdev-core.h:567
#: ../../../../include/hw/qdev-core.h:575
#: ../../../../include/hw/qdev-core.h:584
#: ../../../../include/hw/qdev-core.h:611
#: ../../../../include/hw/qdev-core.h:633
#: ../../../../include/hw/qdev-core.h:653
#: ../../../../include/hw/qdev-core.h:684
#: ../../../../include/hw/qdev-core.h:713
#: ../../../../include/hw/qdev-core.h:733
#: ../../../../include/hw/qdev-core.h:759
#: ../../../../include/hw/qdev-core.h:778
#: ../../../../include/hw/qdev-core.h:807
#: ../../../../include/hw/qdev-core.h:821
#: ../../../../include/hw/qdev-core.h:834
#: ../../../../include/hw/qdev-core.h:851
#: ../../../../include/hw/qdev-core.h:901
#: ../../../../include/hw/qdev-core.h:910
#: ../../../../include/hw/qdev-core.h:919
#: ../../../../include/hw/qdev-core.h:927
#: ../../../../include/hw/qdev-core.h:941
#: ../../../../include/hw/qdev-core.h:965
#: ../../../../include/hw/qdev-core.h:977
#: ../../../../include/hw/qdev-core.h:993
#: ../../../../include/hw/qdev-core.h:1007
#: ../../../../include/hw/qdev-core.h:1030
#: ../../../../include/hw/qdev-core.h:1039
#: ../../../../include/hw/qdev-core.h:1050
#: ../../../../include/hw/qdev-core.h:1090
#: ../../../../include/hw/qdev-core.h:1116
msgid "**Parameters**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:441
#: ../../../../include/hw/qdev-core.h:453
#: ../../../../include/hw/qdev-core.h:634
#: ../../../../include/hw/qdev-core.h:686
#: ../../../../include/hw/qdev-core.h:714
#: ../../../../include/hw/qdev-core.h:735
#: ../../../../include/hw/qdev-core.h:809
#: ../../../../include/hw/qdev-core.h:824
#: ../../../../include/hw/qdev-core.h:836
#: ../../../../include/hw/qdev-core.h:853
#: ../../../../include/hw/qdev-core.h:1041
msgid "``const char *name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:438
msgid "device type to create (we assert() that this type exists)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:440
msgid ""
"This only allocates the memory and initializes the device state structure, "
"ready for the caller to set properties if they wish. The device still needs "
"to be realized."
msgstr ""

#: ../../../../include/hw/qdev-core.h:444
#: ../../../../include/hw/qdev-core.h:455
#: ../../../../include/hw/qdev-core.h:466
#: ../../../../include/hw/qdev-core.h:487
#: ../../../../include/hw/qdev-core.h:515
#: ../../../../include/hw/qdev-core.h:553
#: ../../../../include/hw/qdev-core.h:587
#: ../../../../include/hw/qdev-core.h:626
#: ../../../../include/hw/qdev-core.h:646
#: ../../../../include/hw/qdev-core.h:726
#: ../../../../include/hw/qdev-core.h:747
#: ../../../../include/hw/qdev-core.h:920
#: ../../../../include/hw/qdev-core.h:928
#: ../../../../include/hw/qdev-core.h:1043
#: ../../../../include/hw/qdev-core.h:1056
#: ../../../../include/hw/qdev-core.h:1122
msgid "**Return**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:444
msgid "a derived DeviceState object with a reference count of 1."
msgstr ""

#: ../../../../include/hw/qdev-core.h:449
msgid "Try to create a device on the heap"
msgstr ""

#: ../../../../include/hw/qdev-core.h:450
msgid "device type to create"
msgstr ""

#: ../../../../include/hw/qdev-core.h:452
msgid ""
"This is like qdev_new(), except it returns ``NULL`` when type **name** does "
"not exist, rather than asserting."
msgstr ""

#: ../../../../include/hw/qdev-core.h:455
msgid ""
"a derived DeviceState object with a reference count of 1 or NULL if type "
"**name** does not exist."
msgstr ""

#: ../../../../include/hw/qdev-core.h:461
msgid "check if device is realized"
msgstr ""

#: ../../../../include/hw/qdev-core.h:465
#: ../../../../include/hw/qdev-core.h:477
#: ../../../../include/hw/qdev-core.h:496
#: ../../../../include/hw/qdev-core.h:524
#: ../../../../include/hw/qdev-core.h:551
#: ../../../../include/hw/qdev-core.h:569
#: ../../../../include/hw/qdev-core.h:577
#: ../../../../include/hw/qdev-core.h:586
#: ../../../../include/hw/qdev-core.h:613
#: ../../../../include/hw/qdev-core.h:635
#: ../../../../include/hw/qdev-core.h:655
#: ../../../../include/hw/qdev-core.h:686
#: ../../../../include/hw/qdev-core.h:715
#: ../../../../include/hw/qdev-core.h:735
#: ../../../../include/hw/qdev-core.h:761
#: ../../../../include/hw/qdev-core.h:780
#: ../../../../include/hw/qdev-core.h:809
#: ../../../../include/hw/qdev-core.h:823
#: ../../../../include/hw/qdev-core.h:836
#: ../../../../include/hw/qdev-core.h:853
#: ../../../../include/hw/qdev-core.h:903
#: ../../../../include/hw/qdev-core.h:921
#: ../../../../include/hw/qdev-core.h:1052
msgid "``DeviceState *dev``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:462
msgid "The device to check."
msgstr ""

#: ../../../../include/hw/qdev-core.h:464
msgid "**Context**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:464
msgid "May be called outside big qemu lock."
msgstr ""

#: ../../../../include/hw/qdev-core.h:465
msgid "true if the device has been fully constructed, false otherwise."
msgstr ""

#: ../../../../include/hw/qdev-core.h:473
msgid "Realize **dev**."
msgstr ""

#: ../../../../include/hw/qdev-core.h:474
#: ../../../../include/hw/qdev-core.h:493
msgid "device to realize"
msgstr ""

#: ../../../../include/hw/qdev-core.h:476
#: ../../../../include/hw/qdev-core.h:495
#: ../../../../include/hw/qdev-core.h:912
#: ../../../../include/hw/qdev-core.h:929
#: ../../../../include/hw/qdev-core.h:1092
msgid "``BusState *bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:475
#: ../../../../include/hw/qdev-core.h:494
msgid "bus to plug it into (may be NULL)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:477
#: ../../../../include/hw/qdev-core.h:496
#: ../../../../include/hw/qdev-core.h:586
#: ../../../../include/hw/qdev-core.h:1119
msgid "``Error **errp``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:476
#: ../../../../include/hw/qdev-core.h:495
#: ../../../../include/hw/qdev-core.h:1118
msgid "pointer to error object"
msgstr ""

#: ../../../../include/hw/qdev-core.h:478
msgid ""
"\"Realize\" the device, i.e. perform the second phase of device "
"initialization. **dev** must not be plugged into a bus already. If **bus**, "
"plug **dev** into **bus**.  This takes a reference to **dev**. If **dev** "
"has no QOM parent, make one up, taking another reference."
msgstr ""

#: ../../../../include/hw/qdev-core.h:484
msgid ""
"If you created **dev** using qdev_new(), you probably want to use "
"qdev_realize_and_unref() instead."
msgstr ""

#: ../../../../include/hw/qdev-core.h:487
#: ../../../../include/hw/qdev-core.h:515
msgid "true on success, else false setting **errp** with error"
msgstr ""

#: ../../../../include/hw/qdev-core.h:492
msgid "Realize **dev** and drop a reference"
msgstr ""

#: ../../../../include/hw/qdev-core.h:497
msgid ""
"Realize **dev** and drop a reference. This is like qdev_realize(), except "
"the caller must hold a (private) reference, which is dropped on return "
"regardless of success or failure.  Intended use::"
msgstr ""

#: ../../../../include/hw/qdev-core.h:502
msgid ""
"dev = qdev_new();\n"
"[...]\n"
"qdev_realize_and_unref(dev, bus, errp);"
msgstr ""

#: ../../../../include/hw/qdev-core.h:506
msgid "Now **dev** can go away without further ado."
msgstr ""

#: ../../../../include/hw/qdev-core.h:508
msgid ""
"If you are embedding the device into some other QOM device and initialized "
"it via some variant on object_initialize_child() then do not use this "
"function, because that family of functions arrange for the only reference to "
"the child device to be held by the parent via the child<> property, and so "
"the reference-count-drop done here would be incorrect. For that use case you "
"want qdev_realize()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:520
msgid "Unrealize a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:521
msgid "device to unrealize"
msgstr ""

#: ../../../../include/hw/qdev-core.h:523
msgid ""
"This function will \"unrealize\" a device, which is the first phase of "
"correctly destroying a device that has been realized. It will:"
msgstr ""

#: ../../../../include/hw/qdev-core.h:526
msgid ""
"unrealize any child buses by calling qbus_unrealize() (this will recursively "
"unrealize any devices on those buses)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:528
msgid "call the unrealize method of **dev**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:530
msgid ""
"The device can then be freed by causing its reference count to go to zero."
msgstr ""

#: ../../../../include/hw/qdev-core.h:533
msgid ""
"Warning: most devices in QEMU do not expect to be unrealized.  Only devices "
"which are hot-unpluggable should be unrealized (as part of the unplugging "
"process); all other devices are expected to last for the life of the "
"simulation and should not be unrealized and freed."
msgstr ""

#: ../../../../include/hw/qdev-core.h:547
msgid "Get handler responsible for device wiring"
msgstr ""

#: ../../../../include/hw/qdev-core.h:548
msgid "the device we want the HOTPLUG_HANDLER for."
msgstr ""

#: ../../../../include/hw/qdev-core.h:550
msgid "**Note**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:550
msgid ""
"in case **dev** has a parent bus, it will be returned as handler unless "
"machine handler overrides it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:553
msgid ""
"pointer to object that implements TYPE_HOTPLUG_HANDLER interface or NULL if "
"there aren't any."
msgstr ""

#: ../../../../include/hw/qdev-core.h:565
msgid "Add an unplug blocker to a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:567
msgid "Device to be blocked from unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:569
#: ../../../../include/hw/qdev-core.h:577
msgid "``Error *reason``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:568
msgid "Reason for blocking"
msgstr ""

#: ../../../../include/hw/qdev-core.h:573
msgid "Remove an unplug blocker from a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:575
msgid "Device to be unblocked"
msgstr ""

#: ../../../../include/hw/qdev-core.h:576
msgid ""
"Pointer to the Error used with qdev_add_unplug_blocker. Used as a handle to "
"lookup the blocker for deletion."
msgstr ""

#: ../../../../include/hw/qdev-core.h:582
msgid "Confirm if a device is blocked from unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:584
msgid "Device to be tested"
msgstr ""

#: ../../../../include/hw/qdev-core.h:585
msgid "The reasons why the device is blocked, if any"
msgstr ""

#: ../../../../include/hw/qdev-core.h:587
msgid ""
"true (also setting **errp**) if device is blocked from unplug, false "
"otherwise"
msgstr ""

#: ../../../../include/hw/qdev-core.h:593
msgid "Polarity of a GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:595
msgid ""
"GPIO lines use either positive (active-high) logic, or negative (active-low) "
"logic."
msgstr ""

#: ../../../../include/hw/qdev-core.h:598
msgid ""
"In active-high logic (``GPIO_POLARITY_ACTIVE_HIGH``), a pin is active when "
"the voltage on the pin is high (relative to ground); whereas in active-low "
"logic (``GPIO_POLARITY_ACTIVE_LOW``), a pin is active when the voltage on "
"the pin is low (or grounded)."
msgstr ""

#: ../../../../include/hw/qdev-core.h:609
msgid "Get one of a device's anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:610
#: ../../../../include/hw/qdev-core.h:632
msgid "Device whose GPIO we want"
msgstr ""

#: ../../../../include/hw/qdev-core.h:612
#: ../../../../include/hw/qdev-core.h:635
#: ../../../../include/hw/qdev-core.h:654
#: ../../../../include/hw/qdev-core.h:687
#: ../../../../include/hw/qdev-core.h:715
#: ../../../../include/hw/qdev-core.h:736
#: ../../../../include/hw/qdev-core.h:761
#: ../../../../include/hw/qdev-core.h:780
#: ../../../../include/hw/qdev-core.h:810
#: ../../../../include/hw/qdev-core.h:825
#: ../../../../include/hw/qdev-core.h:837
msgid "``int n``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:611
msgid "Number of the anonymous GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:613
msgid ""
"Returns the qemu_irq corresponding to an anonymous input GPIO line (which "
"the device has set up with qdev_init_gpio_in()). The index **n** of the GPIO "
"line must be valid (i.e. be at least 0 and less than the total number of "
"anonymous input GPIOs the device has); this function will assert() if passed "
"an invalid index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:619
msgid ""
"This function is intended to be used by board code or SoC \"container\" "
"device models to wire up the GPIO lines; usually the return value will be "
"passed to qdev_connect_gpio_out() or a similar function to connect another "
"device's output GPIO line to this input."
msgstr ""

#: ../../../../include/hw/qdev-core.h:624
msgid "For named input GPIO lines, use qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:626
msgid "qemu_irq corresponding to anonymous input GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:631
msgid "Get one of a device's named input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:633
msgid "Name of the input GPIO array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:634
msgid "Number of the GPIO line in that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:636
msgid ""
"Returns the qemu_irq corresponding to a single input GPIO line in a named "
"array of input GPIO lines on a device (which the device has set up with "
"qdev_init_gpio_in_named()). The **name** string must correspond to an input "
"GPIO array which exists on the device, and the index **n** of the GPIO line "
"must be valid (i.e. be at least 0 and less than the total number of input "
"GPIOs in that array); this function will assert() if passed an invalid name "
"or index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:644
msgid "For anonymous input GPIO lines, use qdev_get_gpio_in()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:646
msgid "qemu_irq corresponding to named input GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:651
msgid "Connect one of a device's anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:652
#: ../../../../include/hw/qdev-core.h:684
msgid "Device whose GPIO to connect"
msgstr ""

#: ../../../../include/hw/qdev-core.h:653
msgid "Number of the anonymous output GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:655
msgid "``qemu_irq pin``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:654
#: ../../../../include/hw/qdev-core.h:687
msgid "qemu_irq to connect the output line to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:656
msgid ""
"This function connects an anonymous output GPIO line on a device up to an "
"arbitrary qemu_irq, so that when the device asserts that output GPIO line, "
"the qemu_irq's callback is invoked. The index **n** of the GPIO line must be "
"valid (i.e. be at least 0 and less than the total number of anonymous output "
"GPIOs the device has created with qdev_init_gpio_out()); otherwise this "
"function will assert()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:663
#: ../../../../include/hw/qdev-core.h:697
msgid ""
"Outbound GPIO lines can be connected to any qemu_irq, but the common case is "
"connecting them to another device's inbound GPIO line, using the qemu_irq "
"returned by qdev_get_gpio_in() or qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:667
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq. (Warning: "
"there is no assertion or other guard to catch this error: the model will "
"just not do the right thing.) Instead, for fan-out you can use the "
"TYPE_SPLIT_IRQ device: connect a device's outbound GPIO to the splitter's "
"input, and connect each of the splitter's outputs to a different device.  "
"For fan-in you can use the TYPE_OR_IRQ device, which is a model of a logical "
"OR gate with multiple inputs and one output."
msgstr ""

#: ../../../../include/hw/qdev-core.h:677
msgid "For named output GPIO lines, use qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:682
msgid "Connect one of a device's named output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:685
#: ../../../../include/hw/qdev-core.h:713
#: ../../../../include/hw/qdev-core.h:734
msgid "Name of the output GPIO array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:686
msgid ""
"Number of the output GPIO line within that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:688
msgid "``qemu_irq input_pin``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:689
msgid ""
"This function connects a single GPIO output in a named array of output GPIO "
"lines on a device up to an arbitrary qemu_irq, so that when the device "
"asserts that output GPIO line, the qemu_irq's callback is invoked. The "
"**name** string must correspond to an output GPIO array which exists on the "
"device, and the index **n** of the GPIO line must be valid (i.e. be at least "
"0 and less than the total number of output GPIOs in that array); this "
"function will assert() if passed an invalid name or index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:701
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq; see "
"qdev_connect_gpio_out() for details."
msgstr ""

#: ../../../../include/hw/qdev-core.h:705
msgid "For anonymous output GPIO lines, use qdev_connect_gpio_out()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:711
msgid "Get the qemu_irq connected to an output GPIO"
msgstr ""

#: ../../../../include/hw/qdev-core.h:712
msgid "Device whose output GPIO we are interested in"
msgstr ""

#: ../../../../include/hw/qdev-core.h:714
msgid "Number of the output GPIO line within that array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:716
msgid ""
"Returns whatever qemu_irq is currently connected to the specified output "
"GPIO line of **dev**. This will be NULL if the output GPIO line has never "
"been wired up to the anything.  Note that the qemu_irq returned does not "
"belong to **dev** -- it will be the input GPIO or IRQ of whichever device "
"the board code has connected up to **dev**'s output GPIO."
msgstr ""

#: ../../../../include/hw/qdev-core.h:723
msgid ""
"You probably don't need to use this function -- it is used only by the "
"platform-bus subsystem."
msgstr ""

#: ../../../../include/hw/qdev-core.h:726
msgid "qemu_irq associated with GPIO or NULL if un-wired."
msgstr ""

#: ../../../../include/hw/qdev-core.h:731
msgid "Intercept an existing GPIO connection"
msgstr ""

#: ../../../../include/hw/qdev-core.h:732
msgid "Device to intercept the outbound GPIO line from"
msgstr ""

#: ../../../../include/hw/qdev-core.h:734
msgid "``qemu_irq icpt``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:733
msgid "New qemu_irq to connect instead"
msgstr ""

#: ../../../../include/hw/qdev-core.h:735
msgid "Number of the GPIO line in the array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:738
msgid ""
"This function is provided only for use by the qtest testing framework and is "
"not suitable for use in non-testing parts of QEMU."
msgstr ""

#: ../../../../include/hw/qdev-core.h:741
msgid ""
"This function breaks an existing connection of an outbound GPIO line from "
"**dev**, and replaces it with the new qemu_irq **icpt**, as if "
"``qdev_connect_gpio_out_named(dev, icpt, name, n)`` had been called. The "
"previously connected qemu_irq is returned, so it can be restored by a second "
"call to qdev_intercept_gpio_out() if desired."
msgstr ""

#: ../../../../include/hw/qdev-core.h:747
msgid "old disconnected qemu_irq if one existed"
msgstr ""

#: ../../../../include/hw/qdev-core.h:757
msgid "create an array of anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:758
#: ../../../../include/hw/qdev-core.h:820
msgid "Device to create input GPIOs for"
msgstr ""

#: ../../../../include/hw/qdev-core.h:760
#: ../../../../include/hw/qdev-core.h:822
#: ../../../../include/hw/qdev-core.h:835
msgid "``qemu_irq_handler handler``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:759
#: ../../../../include/hw/qdev-core.h:821
msgid "Function to call when GPIO line value is set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:760
#: ../../../../include/hw/qdev-core.h:779
msgid "Number of GPIO lines to create"
msgstr ""

#: ../../../../include/hw/qdev-core.h:762
msgid ""
"Devices should use functions in the qdev_init_gpio_in* family in their "
"instance_init or realize methods to create any input GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO input whose "
"purpose is obvious. Note that input GPIO lines can serve as 'sinks' for IRQ "
"lines."
msgstr ""

#: ../../../../include/hw/qdev-core.h:770
msgid ""
"See qdev_get_gpio_in() for how code that uses such a device can get hold of "
"an input GPIO line to manipulate it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:776
msgid "create an array of anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:777
#: ../../../../include/hw/qdev-core.h:806
msgid "Device to create output GPIOs for"
msgstr ""

#: ../../../../include/hw/qdev-core.h:779
#: ../../../../include/hw/qdev-core.h:808
msgid "``qemu_irq *pins``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:778
#: ../../../../include/hw/qdev-core.h:807
msgid "Pointer to qemu_irq or qemu_irq array for the GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:781
msgid ""
"Devices should use functions in the qdev_init_gpio_out* family in their "
"instance_init or realize methods to create any output GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO output whose "
"purpose is obvious."
msgstr ""

#: ../../../../include/hw/qdev-core.h:788
msgid ""
"The **pins** argument should be a pointer to either a \"qemu_irq\" (if **n** "
"== 1) or a \"qemu_irq []\" array (if **n** > 1) in the device's state "
"structure. The device implementation can then raise and lower the GPIO line "
"by calling qemu_set_irq(). (If anything is connected to the other end of the "
"GPIO this will cause the handler function for that input GPIO to be called.)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:795
msgid ""
"See qdev_connect_gpio_out() for how code that uses such a device can connect "
"to one of its output GPIO lines."
msgstr ""

#: ../../../../include/hw/qdev-core.h:798
msgid ""
"There is no need to release the **pins** allocated array because it will be "
"automatically released when **dev** calls its instance_finalize() handler."
msgstr ""

#: ../../../../include/hw/qdev-core.h:805
msgid "create an array of named output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:808
msgid "Name to give this array of GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:809
msgid "Number of GPIO lines to create in this array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:811
msgid ""
"Like qdev_init_gpio_out(), but creates an array of GPIO output lines with a "
"name. Code using the device can then connect these GPIO lines using "
"qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:819
#: ../../../../include/hw/qdev-core.h:832
msgid "create an array of input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:823
msgid "``void *opaque``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:822
msgid "Opaque data pointer to pass to **handler**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:823
#: ../../../../include/hw/qdev-core.h:835
msgid "Name of the GPIO input (must be unique for this device)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:824
#: ../../../../include/hw/qdev-core.h:836
msgid "Number of GPIO lines in this input set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:833
msgid "device to add array to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:834
msgid "a &typedef qemu_irq_handler function to call when GPIO is set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:838
msgid ""
"Like qdev_init_gpio_in_named_with_opaque(), but the opaque pointer passed to "
"the handler is **dev** (which is the most commonly desired behaviour)."
msgstr ""

#: ../../../../include/hw/qdev-core.h:849
msgid "create GPIO lines on container which pass through to device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:850
msgid "Device which has GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:852
msgid "``DeviceState *container``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:851
msgid "Container device which needs to expose them"
msgstr ""

#: ../../../../include/hw/qdev-core.h:852
msgid "Name of GPIO array to pass through (NULL for the anonymous GPIO array)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:854
msgid ""
"In QEMU, complicated devices like SoCs are often modelled with a "
"\"container\" QOM device which itself contains other QOM devices and which "
"wires them up appropriately. This function allows the container to create "
"GPIO arrays on itself which simply pass through to a GPIO array of one of "
"its internal devices."
msgstr ""

#: ../../../../include/hw/qdev-core.h:860
msgid ""
"If **dev** has both input and output GPIOs named **name** then both will be "
"passed through. It is not possible to pass a subset of the array with this "
"function."
msgstr ""

#: ../../../../include/hw/qdev-core.h:864
msgid ""
"To users of the container device, the GPIO array created on **container** "
"behaves exactly like any other."
msgstr ""

#: ../../../../include/hw/qdev-core.h:899
msgid "perform a recursive cold reset on a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:900
msgid "device to reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:902
msgid ""
"Reset device **dev** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/qdev-core.h:908
msgid "perform a recursive cold reset on a bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:909
msgid "bus to reset"
msgstr ""

#: ../../../../include/hw/qdev-core.h:911
msgid ""
"Reset bus **bus** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/qdev-core.h:917
msgid "check device reset state"
msgstr ""

#: ../../../../include/hw/qdev-core.h:918
msgid "device to check"
msgstr ""

#: ../../../../include/hw/qdev-core.h:920
msgid "true if the device **dev** is currently being reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:925
msgid "check bus reset state"
msgstr ""

#: ../../../../include/hw/qdev-core.h:926
msgid "bus to check"
msgstr ""

#: ../../../../include/hw/qdev-core.h:928
msgid "true if the bus **bus** is currently being reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:954
msgid "``device_class_set_props (dc, props)``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:939
#: ../../../../include/hw/qdev-core.h:963
msgid "add a set of properties to an device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:943
msgid "``dc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:940
#: ../../../../include/hw/qdev-core.h:964
msgid "the parent DeviceClass all devices inherit"
msgstr ""

#: ../../../../include/hw/qdev-core.h:942
msgid "``props``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:941
#: ../../../../include/hw/qdev-core.h:965
msgid "an array of properties"
msgstr ""

#: ../../../../include/hw/qdev-core.h:943
#: ../../../../include/hw/qdev-core.h:968
msgid ""
"This will add a set of properties to the object. It will fault if you "
"attempt to add an existing property defined by a parent class. To modify an "
"inherited property you need to use????"
msgstr ""

#: ../../../../include/hw/qdev-core.h:947
msgid ""
"Validate that **props** has at least one Property. Validate that **props** "
"is an array, not a pointer, via ARRAY_SIZE. Validate that the array does not "
"have a legacy terminator at compile-time; requires -O2 and the array to be "
"const."
msgstr ""

#: ../../../../include/hw/qdev-core.h:967
#: ../../../../include/hw/qdev-core.h:979
#: ../../../../include/hw/qdev-core.h:995
#: ../../../../include/hw/qdev-core.h:1009
msgid "``DeviceClass *dc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:966
msgid "``const Property *props``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:967
msgid "``size_t n``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:966
msgid "ARRAY_SIZE(**props**)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:975
msgid "set up for chaining realize fns"
msgstr ""

#: ../../../../include/hw/qdev-core.h:976
#: ../../../../include/hw/qdev-core.h:992
#: ../../../../include/hw/qdev-core.h:1006
msgid "The device class"
msgstr ""

#: ../../../../include/hw/qdev-core.h:978
msgid "``DeviceRealize dev_realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:977
#: ../../../../include/hw/qdev-core.h:1007
msgid "the device realize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:979
msgid "``DeviceRealize *parent_realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:978
msgid "somewhere to save the parents realize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:980
msgid ""
"This is intended to be used when the new realize function will eventually "
"call its parent realization function during creation. This requires storing "
"the function call somewhere (usually in the instance structure) so you can "
"eventually call dc->parent_realize(dev, errp)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:991
msgid "set the DeviceClass::reset method"
msgstr ""

#: ../../../../include/hw/qdev-core.h:994
msgid "``DeviceReset dev_reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:993
msgid "the reset function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:995
msgid ""
"This function sets the DeviceClass::reset method. This is widely used in "
"existing code, but new code should prefer to use the Resettable API as "
"documented in docs/devel/reset.rst. In addition, devices which need to chain "
"to their parent class's reset methods or which need to be subclassed must "
"use Resettable."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1005
msgid "set up for chaining unrealize fns"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1008
msgid "``DeviceUnrealize dev_unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1009
msgid "``DeviceUnrealize *parent_unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1008
msgid "somewhere to save the parents unrealize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1010
msgid ""
"This is intended to be used when the new unrealize function will eventually "
"call its parent unrealization function during the unrealize phase. This "
"requires storing the function call somewhere (usually in the instance "
"structure) so you can eventually call dc->parent_unrealize(dev);"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1028
msgid "Create a fake machine container."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1032
msgid "``void``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1033
msgid "no arguments"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1031
msgid ""
"This function is a kludge for user emulation (USER_ONLY) because when thread "
"(TYPE_CPU) are realized, qdev_realize() access a machine container."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1039
msgid "The name of container to lookup"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1041
msgid "Get a container of the machine (QOM path \"/machine/NAME\")."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1043
msgid "the machine container object."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1048
msgid "Return a human-readable name for a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1049
msgid "The device. Must be a valid and non-NULL pointer."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1052
msgid "This function is intended for user friendly error messages."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1054
msgid "Use g_free() to free it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1054
msgid ""
"A newly allocated string containing the device id if not null, else the "
"object canonical path."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1088
msgid "Mark this bus as full, so no more devices can be attached"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1089
msgid "Bus to mark as full"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1091
msgid ""
"By default, QEMU will allow devices to be plugged into a bus up to the bus "
"class's device count limit. Calling this function marks a particular bus as "
"full, so that no more devices can be plugged into it. In particular this "
"means that the bus will not be considered as a candidate for plugging in "
"devices created by the user on the commandline or via the monitor. If a "
"machine has multiple buses of a given type, such as I2C, where some of those "
"buses in the real hardware are used only for internal devices and some are "
"exposed via expansion ports, you can use this function to mark the internal-"
"only buses as full after you have created all their internal devices. Then "
"user created devices will appear on the expansion-port bus where guest "
"software expects them."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1114
msgid "check if device should be hidden"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1118
msgid "``const QDict *opts``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1116
msgid "options QDict"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1118
msgid "``bool from_json``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1117
msgid "true if **opts** entries are typed, false for all strings"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1120
msgid "When a device is added via qdev_device_add() this will be called."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1122
msgid "if the device should be added now or not."
msgstr ""
