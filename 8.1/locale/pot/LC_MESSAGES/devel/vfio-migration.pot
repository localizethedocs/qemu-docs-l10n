# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/vfio-migration.rst:3
msgid "VFIO device Migration"
msgstr ""

#: ../../../devel/vfio-migration.rst:5
msgid ""
"Migration of virtual machine involves saving the state for each device that "
"the guest is running on source host and restoring this saved state on the "
"destination host. This document details how saving and restoring of VFIO "
"devices is done in QEMU."
msgstr ""

#: ../../../devel/vfio-migration.rst:10
msgid ""
"Migration of VFIO devices consists of two phases: the optional pre-copy "
"phase, and the stop-and-copy phase. The pre-copy phase is iterative and "
"allows to accommodate VFIO devices that have a large amount of data that "
"needs to be transferred. The iterative pre-copy phase of migration allows "
"for the guest to continue whilst the VFIO device state is transferred to the "
"destination, this helps to reduce the total downtime of the VM. VFIO devices "
"opt-in to pre-copy support by reporting the VFIO_MIGRATION_PRE_COPY flag in "
"the VFIO_DEVICE_FEATURE_MIGRATION ioctl."
msgstr ""

#: ../../../devel/vfio-migration.rst:19
msgid ""
"When pre-copy is supported, it's possible to further reduce downtime by "
"enabling \"switchover-ack\" migration capability. VFIO migration uAPI "
"defines \"initial bytes\" as part of its pre-copy data stream and recommends "
"that the initial bytes are sent and loaded in the destination before "
"stopping the source VM. Enabling this migration capability will guarantee "
"that and thus, can potentially reduce downtime even further."
msgstr ""

#: ../../../devel/vfio-migration.rst:26
msgid ""
"Note that currently VFIO migration is supported only for a single device. "
"This is due to VFIO migration's lack of P2P support. However, P2P support is "
"planned to be added later on."
msgstr ""

#: ../../../devel/vfio-migration.rst:30
msgid ""
"A detailed description of the UAPI for VFIO device migration can be found in "
"the comment for the ``vfio_device_mig_state`` structure in the header file "
"linux-headers/linux/vfio.h."
msgstr ""

#: ../../../devel/vfio-migration.rst:34
msgid "VFIO implements the device hooks for the iterative approach as follows:"
msgstr ""

#: ../../../devel/vfio-migration.rst:36
msgid "A ``save_setup`` function that sets up migration on the source."
msgstr ""

#: ../../../devel/vfio-migration.rst:38
msgid ""
"A ``load_setup`` function that sets the VFIO device on the destination in "
"_RESUMING state."
msgstr ""

#: ../../../devel/vfio-migration.rst:41
msgid ""
"A ``state_pending_estimate`` function that reports an estimate of the "
"remaining pre-copy data that the vendor driver has yet to save for the VFIO "
"device."
msgstr ""

#: ../../../devel/vfio-migration.rst:45
msgid ""
"A ``state_pending_exact`` function that reads pending_bytes from the vendor "
"driver, which indicates the amount of data that the vendor driver has yet to "
"save for the VFIO device."
msgstr ""

#: ../../../devel/vfio-migration.rst:49
msgid ""
"An ``is_active_iterate`` function that indicates ``save_live_iterate`` is "
"active only when the VFIO device is in pre-copy states."
msgstr ""

#: ../../../devel/vfio-migration.rst:52
msgid ""
"A ``save_live_iterate`` function that reads the VFIO device's data from the "
"vendor driver during iterative pre-copy phase."
msgstr ""

#: ../../../devel/vfio-migration.rst:55
msgid ""
"A ``switchover_ack_needed`` function that checks if the VFIO device uses "
"\"switchover-ack\" migration capability when this capability is enabled."
msgstr ""

#: ../../../devel/vfio-migration.rst:58
msgid ""
"A ``save_state`` function to save the device config space if it is present."
msgstr ""

#: ../../../devel/vfio-migration.rst:60
msgid ""
"A ``save_live_complete_precopy`` function that sets the VFIO device in "
"_STOP_COPY state and iteratively copies the data for the VFIO device until "
"the vendor driver indicates that no data remains."
msgstr ""

#: ../../../devel/vfio-migration.rst:64
msgid ""
"A ``load_state`` function that loads the config section and the data "
"sections that are generated by the save functions above."
msgstr ""

#: ../../../devel/vfio-migration.rst:67
msgid ""
"``cleanup`` functions for both save and load that perform any migration "
"related cleanup."
msgstr ""

#: ../../../devel/vfio-migration.rst:71
msgid ""
"The VFIO migration code uses a VM state change handler to change the VFIO "
"device state when the VM state changes from running to not-running, and vice "
"versa."
msgstr ""

#: ../../../devel/vfio-migration.rst:75
msgid ""
"Similarly, a migration state change handler is used to trigger a transition "
"of the VFIO device state when certain changes of the migration state occur. "
"For example, the VFIO device state is transitioned back to _RUNNING in case "
"a migration failed or was canceled."
msgstr ""

#: ../../../devel/vfio-migration.rst:81
msgid "System memory dirty pages tracking"
msgstr ""

#: ../../../devel/vfio-migration.rst:83
msgid ""
"A ``log_global_start`` and ``log_global_stop`` memory listener callback "
"informs the VFIO dirty tracking module to start and stop dirty page "
"tracking. A ``log_sync`` memory listener callback queries the dirty page "
"bitmap from the dirty tracking module and marks system memory pages which "
"were DMA-ed by the VFIO device as dirty. The dirty page bitmap is queried "
"per container."
msgstr ""

#: ../../../devel/vfio-migration.rst:89
msgid ""
"Currently there are two ways dirty page tracking can be done: (1) Device "
"dirty tracking: In this method the device is responsible to log and report "
"its DMAs. This method can be used only if the device is capable of tracking "
"its DMAs. Discovering device capability, starting and stopping dirty "
"tracking, and syncing the dirty bitmaps from the device are done using the "
"DMA logging uAPI. More info about the uAPI can be found in the comments of "
"the ``vfio_device_feature_dma_logging_control`` and "
"``vfio_device_feature_dma_logging_report`` structures in the header file "
"linux-headers/linux/vfio.h."
msgstr ""

#: ../../../devel/vfio-migration.rst:100
msgid ""
"(2) VFIO IOMMU module: In this method dirty tracking is done by IOMMU. "
"However, there is currently no IOMMU support for dirty page tracking. For "
"this reason, all pages are perpetually marked dirty, unless the device "
"driver pins pages through external APIs in which case only those pinned "
"pages are perpetually marked dirty."
msgstr ""

#: ../../../devel/vfio-migration.rst:106
msgid ""
"If the above two methods are not supported, all pages are perpetually marked "
"dirty by QEMU."
msgstr ""

#: ../../../devel/vfio-migration.rst:109
msgid ""
"By default, dirty pages are tracked during pre-copy as well as stop-and-copy "
"phase. So, a page marked as dirty will be copied to the destination in both "
"phases. Copying dirty pages in pre-copy phase helps QEMU to predict if it "
"can achieve its downtime tolerances. If QEMU during pre-copy phase keeps "
"finding dirty pages continuously, then it understands that even in stop-and-"
"copy phase, it is likely to find dirty pages and can predict the downtime "
"accordingly."
msgstr ""

#: ../../../devel/vfio-migration.rst:116
msgid ""
"QEMU also provides a per device opt-out option ``pre-copy-dirty-page-"
"tracking`` which disables querying the dirty bitmap during pre-copy phase. "
"If it is set to off, all dirty pages will be copied to the destination in "
"stop-and-copy phase only."
msgstr ""

#: ../../../devel/vfio-migration.rst:122
msgid "System memory dirty pages tracking when vIOMMU is enabled"
msgstr ""

#: ../../../devel/vfio-migration.rst:124
msgid ""
"With vIOMMU, an IO virtual address range can get unmapped while in pre-copy "
"phase of migration. In that case, the unmap ioctl returns any dirty pages in "
"that range and QEMU reports corresponding guest physical pages dirty. During "
"stop-and-copy phase, an IOMMU notifier is used to get a callback for mapped "
"pages and then dirty pages bitmap is fetched from VFIO IOMMU modules for "
"those mapped ranges. If device dirty tracking is enabled with vIOMMU, live "
"migration will be blocked."
msgstr ""

#: ../../../devel/vfio-migration.rst:133
msgid "Flow of state changes during Live migration"
msgstr ""

#: ../../../devel/vfio-migration.rst:135
msgid ""
"Below is the flow of state change during live migration. The values in the "
"parentheses represent the VM state, the migration state, and the VFIO device "
"state, respectively. The text in the square brackets represents the flow if "
"the VFIO device supports pre-copy."
msgstr ""

#: ../../../devel/vfio-migration.rst:142
msgid "Live migration save path"
msgstr ""

#: ../../../devel/vfio-migration.rst:146
msgid ""
"                      QEMU normal running state\n"
"                      (RUNNING, _NONE, _RUNNING)\n"
"                                |\n"
"                   migrate_init spawns migration_thread\n"
"              Migration thread then calls each device's .save_setup()\n"
"                (RUNNING, _SETUP, _RUNNING [_PRE_COPY])\n"
"                                |\n"
"                (RUNNING, _ACTIVE, _RUNNING [_PRE_COPY])\n"
"    If device is active, get pending_bytes by .state_pending_{estimate,exact}"
"()\n"
"        If total pending_bytes >= threshold_size, call .save_live_iterate()\n"
"                [Data of VFIO device for pre-copy phase is copied]\n"
"      Iterate till total pending bytes converge and are less than threshold\n"
"                                |\n"
"On migration completion, vCPU stops and calls .save_live_complete_precopy "
"for\n"
"each active device. The VFIO device is then transitioned into _STOP_COPY "
"state\n"
"                (FINISH_MIGRATE, _DEVICE, _STOP_COPY)\n"
"                                |\n"
"   For the VFIO device, iterate in .save_live_complete_precopy until\n"
"                       pending data is 0\n"
"                 (FINISH_MIGRATE, _DEVICE, _STOP)\n"
"                                |\n"
"               (FINISH_MIGRATE, _COMPLETED, _STOP)\n"
"           Migraton thread schedules cleanup bottom half and exits"
msgstr ""

#: ../../../devel/vfio-migration.rst:171
msgid "Live migration resume path"
msgstr ""

#: ../../../devel/vfio-migration.rst:175
msgid ""
"          Incoming migration calls .load_setup for each device\n"
"                   (RESTORE_VM, _ACTIVE, _STOP)\n"
"                             |\n"
"   For each device, .load_state is called for that device section data\n"
"                   (RESTORE_VM, _ACTIVE, _RESUMING)\n"
"                             |\n"
"At the end, .load_cleanup is called for each device and vCPUs are started\n"
"                   (RUNNING, _NONE, _RUNNING)"
msgstr ""

#: ../../../devel/vfio-migration.rst:185
msgid "Postcopy"
msgstr ""

#: ../../../devel/vfio-migration.rst:187
msgid "Postcopy migration is currently not supported for VFIO devices."
msgstr ""
