# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../interop/vhost-user.rst:5
msgid "Vhost-user Protocol"
msgstr ""

#: ../../../interop/vhost-user.rst:14
msgid "Table of Contents"
msgstr ""

#: ../../../interop/vhost-user.rst:17
msgid "Introduction"
msgstr ""

#: ../../../interop/vhost-user.rst:19
msgid ""
"This protocol is aiming to complement the ``ioctl`` interface used to "
"control the vhost implementation in the Linux kernel. It implements the "
"control plane needed to establish virtqueue sharing with a user space "
"process on the same host. It uses communication over a Unix domain socket to "
"share file descriptors in the ancillary data of the message."
msgstr ""

#: ../../../interop/vhost-user.rst:26
msgid ""
"The protocol defines 2 sides of the communication, *front-end* and *back-"
"end*. The *front-end* is the application that shares its virtqueues, in our "
"case QEMU. The *back-end* is the consumer of the virtqueues."
msgstr ""

#: ../../../interop/vhost-user.rst:30
msgid ""
"In the current implementation QEMU is the *front-end*, and the *back-end* is "
"the external process consuming the virtio queues, for example a software "
"Ethernet switch running in user space, such as Snabbswitch, or a block "
"device back-end processing read & write to a virtual disk. In order to "
"facilitate interoperability between various back-end implementations, it is "
"recommended to follow the :ref:`Backend program conventions "
"<backend_conventions>`."
msgstr ""

#: ../../../interop/vhost-user.rst:38
msgid ""
"The *front-end* and *back-end* can be either a client (i.e. connecting) or "
"server (listening) in the socket communication."
msgstr ""

#: ../../../interop/vhost-user.rst:42
msgid "Support for platforms other than Linux"
msgstr ""

#: ../../../interop/vhost-user.rst:44
msgid ""
"While vhost-user was initially developed targeting Linux, nowadays it is "
"supported on any platform that provides the following features:"
msgstr ""

#: ../../../interop/vhost-user.rst:47
msgid ""
"A way for requesting shared memory represented by a file descriptor so it "
"can be passed over a UNIX domain socket and then mapped by the other process."
msgstr ""

#: ../../../interop/vhost-user.rst:51
msgid ""
"AF_UNIX sockets with SCM_RIGHTS, so QEMU and the other process can exchange "
"messages through it, including ancillary data when needed."
msgstr ""

#: ../../../interop/vhost-user.rst:54
msgid ""
"Either eventfd or pipe/pipe2. On platforms where eventfd is not available, "
"QEMU will automatically fall back to pipe2 or, as a last resort, pipe. Each "
"file descriptor will be used for receiving or sending events by reading or "
"writing (respectively) an 8-byte value to the corresponding it. The 8-value "
"itself has no meaning and should not be interpreted."
msgstr ""

#: ../../../interop/vhost-user.rst:62
msgid "Message Specification"
msgstr ""

#: ../../../interop/vhost-user.rst:64
msgid "All numbers are in the machine native byte order."
msgstr ""

#: ../../../interop/vhost-user.rst:66
msgid "A vhost-user message consists of 3 header fields and a payload."
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:69
msgid "request"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:69
#: ../../../interop/vhost-user.rst:115 ../../../interop/vhost-user.rst:234
msgid "flags"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:69
#: ../../../interop/vhost-user.rst:115 ../../../interop/vhost-user.rst:137
#: ../../../interop/vhost-user.rst:153 ../../../interop/vhost-user.rst:209
#: ../../../interop/vhost-user.rst:234 ../../../interop/vhost-user.rst:252
msgid "size"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:69
#: ../../../interop/vhost-user.rst:234
msgid "payload"
msgstr ""

#: ../../../interop/vhost-user.rst:73
msgid "Header"
msgstr ""

#: ../../../interop/vhost-user.rst:75
msgid "32-bit type of the request"
msgstr ""

#: ../../../interop/vhost-user.rst:77 ../../../interop/vhost-user.rst:156
msgid "32-bit bit field"
msgstr ""

#: ../../../interop/vhost-user.rst:79
msgid "Lower 2 bits are the version (currently 0x01)"
msgstr ""

#: ../../../interop/vhost-user.rst:80
msgid ""
"Bit 2 is the reply flag - needs to be sent on each reply from the back-end"
msgstr ""

#: ../../../interop/vhost-user.rst:81
msgid ""
"Bit 3 is the need_reply flag - see :ref:`REPLY_ACK <reply_ack>` for details."
msgstr ""

#: ../../../interop/vhost-user.rst:84
msgid "32-bit size of the payload"
msgstr ""

#: ../../../interop/vhost-user.rst:87
msgid "Payload"
msgstr ""

#: ../../../interop/vhost-user.rst:89
msgid "Depending on the request type, **payload** can be:"
msgstr ""

#: ../../../interop/vhost-user.rst:92
msgid "A single 64-bit integer"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:95
#: ../../../interop/vhost-user.rst:252 ../../../interop/vhost-user.rst:997
#: ../../../interop/vhost-user.rst:1107 ../../../interop/vhost-user.rst:1363
msgid "u64"
msgstr ""

#: ../../../interop/vhost-user.rst:98
msgid "a 64-bit unsigned integer"
msgstr ""

#: ../../../interop/vhost-user.rst:101
msgid "A vring state description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:104
#: ../../../interop/vhost-user.rst:115
msgid "index"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:104
msgid "num"
msgstr ""

#: ../../../interop/vhost-user.rst:107
msgid "a 32-bit index"
msgstr ""

#: ../../../interop/vhost-user.rst:109
msgid "a 32-bit number"
msgstr ""

#: ../../../interop/vhost-user.rst:112
msgid "A vring address description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:115
msgid "descriptor"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:115
msgid "used"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:115
msgid "available"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:115
msgid "log"
msgstr ""

#: ../../../interop/vhost-user.rst:118
msgid "a 32-bit vring index"
msgstr ""

#: ../../../interop/vhost-user.rst:120
msgid "a 32-bit vring flags"
msgstr ""

#: ../../../interop/vhost-user.rst:122
msgid "a 64-bit ring address of the vring descriptor table"
msgstr ""

#: ../../../interop/vhost-user.rst:124
msgid "a 64-bit ring address of the vring used ring"
msgstr ""

#: ../../../interop/vhost-user.rst:126
msgid "a 64-bit ring address of the vring available ring"
msgstr ""

#: ../../../interop/vhost-user.rst:128
msgid "a 64-bit guest address for logging"
msgstr ""

#: ../../../interop/vhost-user.rst:130
msgid ""
"Note that a ring address is an IOVA if ``VIRTIO_F_IOMMU_PLATFORM`` has been "
"negotiated. Otherwise it is a user address."
msgstr ""

#: ../../../interop/vhost-user.rst:134
msgid "Memory region description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:137
#: ../../../interop/vhost-user.rst:153
msgid "guest address"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:137
#: ../../../interop/vhost-user.rst:153 ../../../interop/vhost-user.rst:209
msgid "user address"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:137
#: ../../../interop/vhost-user.rst:153 ../../../interop/vhost-user.rst:266
msgid "mmap offset"
msgstr ""

#: ../../../interop/vhost-user.rst:140
msgid "a 64-bit guest address of the region"
msgstr ""

#: ../../../interop/vhost-user.rst:142 ../../../interop/vhost-user.rst:214
msgid "a 64-bit size"
msgstr ""

#: ../../../interop/vhost-user.rst:144 ../../../interop/vhost-user.rst:216
msgid "a 64-bit user address"
msgstr ""

#: ../../../interop/vhost-user.rst:146
msgid "64-bit offset where region starts in the mapped memory"
msgstr ""

#: ../../../interop/vhost-user.rst:148
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_XEN_MMAP`` protocol feature has been "
"successfully negotiated, the memory region description contains two extra "
"fields at the end."
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:153
msgid "xen mmap flags"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:153
msgid "domid"
msgstr ""

#: ../../../interop/vhost-user.rst:158
msgid "Bit 0 is set for Xen foreign memory mapping."
msgstr ""

#: ../../../interop/vhost-user.rst:159
msgid "Bit 1 is set for Xen grant memory mapping."
msgstr ""

#: ../../../interop/vhost-user.rst:160
msgid ""
"Bit 8 is set if the memory region can not be mapped in advance, and memory "
"areas within this region must be mapped / unmapped only when required by the "
"back-end. The back-end shouldn't try to map the entire region at once, as "
"the front-end may not allow it. The back-end should rather map only the "
"required amount of memory at once and unmap it after it is used."
msgstr ""

#: ../../../interop/vhost-user.rst:166
msgid "a 32-bit Xen hypervisor specific domain id."
msgstr ""

#: ../../../interop/vhost-user.rst:169
msgid "Single memory region description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:172
#: ../../../interop/vhost-user.rst:183
msgid "padding"
msgstr ""

#: ../../../interop/vhost-user.rst:172
msgid "region"
msgstr ""

#: ../../../interop/vhost-user.rst:175
msgid "64-bit"
msgstr ""

#: ../../../interop/vhost-user.rst:177 ../../../interop/vhost-user.rst:190
msgid "A region is represented by Memory region description."
msgstr ""

#: ../../../interop/vhost-user.rst:180
msgid "Multiple Memory regions description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:183
msgid "num regions"
msgstr ""

#: ../../../interop/vhost-user.rst:183
msgid "region0"
msgstr ""

#: ../../../interop/vhost-user.rst:183 ../../../interop/vhost-user.rst:592
msgid "..."
msgstr ""

#: ../../../interop/vhost-user.rst:183
msgid "region7"
msgstr ""

#: ../../../interop/vhost-user.rst:186
msgid "a 32-bit number of regions"
msgstr ""

#: ../../../interop/vhost-user.rst:188
msgid "32-bit"
msgstr ""

#: ../../../interop/vhost-user.rst:193
msgid "Log description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:196
msgid "log size"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:196
msgid "log offset"
msgstr ""

#: ../../../interop/vhost-user.rst:199
msgid "size of area used for logging"
msgstr ""

#: ../../../interop/vhost-user.rst:201
msgid ""
"offset from start of supplied file descriptor where logging starts (i.e. "
"where guest address 0 would be logged)"
msgstr ""

#: ../../../interop/vhost-user.rst:206
msgid "An IOTLB message"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:209
msgid "iova"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:209
msgid "permissions flags"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:209
msgid "type"
msgstr ""

#: ../../../interop/vhost-user.rst:212
msgid "a 64-bit I/O virtual address programmed by the guest"
msgstr ""

#: ../../../interop/vhost-user.rst:218
msgid ""
"an 8-bit value: - 0: No access - 1: Read access - 2: Write access - 3: Read/"
"Write access"
msgstr ""

#: ../../../interop/vhost-user.rst:224
msgid ""
"an 8-bit IOTLB message type: - 1: IOTLB miss - 2: IOTLB update - 3: IOTLB "
"invalidate - 4: IOTLB access fail"
msgstr ""

#: ../../../interop/vhost-user.rst:231
msgid "Virtio device config space"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:234
#: ../../../interop/vhost-user.rst:252
msgid "offset"
msgstr ""

#: ../../../interop/vhost-user.rst:237
msgid "a 32-bit offset of virtio device's configuration space"
msgstr ""

#: ../../../interop/vhost-user.rst:239
msgid "a 32-bit configuration space access size in bytes"
msgstr ""

#: ../../../interop/vhost-user.rst:241
msgid ""
"a 32-bit value: - 0: Vhost front-end messages used for writable fields - 1: "
"Vhost front-end messages used for live migration"
msgstr ""

#: ../../../interop/vhost-user.rst:245
msgid ""
"Size bytes array holding the contents of the virtio device's configuration "
"space"
msgstr ""

#: ../../../interop/vhost-user.rst:249
msgid "Vring area description"
msgstr ""

#: ../../../interop/vhost-user.rst:255
msgid "a 64-bit integer contains vring index and flags"
msgstr ""

#: ../../../interop/vhost-user.rst:257
msgid "a 64-bit size of this area"
msgstr ""

#: ../../../interop/vhost-user.rst:259 ../../../interop/vhost-user.rst:271
msgid ""
"a 64-bit offset of this area from the start of the supplied file descriptor"
msgstr ""

#: ../../../interop/vhost-user.rst:263
msgid "Inflight description"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:266
msgid "mmap size"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:266
msgid "num queues"
msgstr ""

#: ../../../interop/vhost-user.rst:0 ../../../interop/vhost-user.rst:266
msgid "queue size"
msgstr ""

#: ../../../interop/vhost-user.rst:269
msgid "a 64-bit size of area to track inflight I/O"
msgstr ""

#: ../../../interop/vhost-user.rst:274
msgid "a 16-bit number of virtqueues"
msgstr ""

#: ../../../interop/vhost-user.rst:276
msgid "a 16-bit size of virtqueues"
msgstr ""

#: ../../../interop/vhost-user.rst:279
msgid "C structure"
msgstr ""

#: ../../../interop/vhost-user.rst:281
msgid ""
"In QEMU the vhost-user message is implemented with the following struct:"
msgstr ""

#: ../../../interop/vhost-user.rst:283
msgid ""
"typedef struct VhostUserMsg {\n"
"    VhostUserRequest request;\n"
"    uint32_t flags;\n"
"    uint32_t size;\n"
"    union {\n"
"        uint64_t u64;\n"
"        struct vhost_vring_state state;\n"
"        struct vhost_vring_addr addr;\n"
"        VhostUserMemory memory;\n"
"        VhostUserLog log;\n"
"        struct vhost_iotlb_msg iotlb;\n"
"        VhostUserConfig config;\n"
"        VhostUserVringArea area;\n"
"        VhostUserInflight inflight;\n"
"    };\n"
"} QEMU_PACKED VhostUserMsg;"
msgstr ""

#: ../../../interop/vhost-user.rst:303
msgid "Communication"
msgstr ""

#: ../../../interop/vhost-user.rst:305
msgid ""
"The protocol for vhost-user is based on the existing implementation of vhost "
"for the Linux Kernel. Most messages that can be sent via the Unix domain "
"socket implementing vhost-user have an equivalent ioctl to the kernel "
"implementation."
msgstr ""

#: ../../../interop/vhost-user.rst:310
msgid ""
"The communication consists of the *front-end* sending message requests and "
"the *back-end* sending message replies. Most of the requests don't require "
"replies. Here is a list of the ones that do:"
msgstr ""

#: ../../../interop/vhost-user.rst:314 ../../../interop/vhost-user.rst:892
msgid "``VHOST_USER_GET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:315 ../../../interop/vhost-user.rst:914
msgid "``VHOST_USER_GET_PROTOCOL_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:316 ../../../interop/vhost-user.rst:1039
#: ../../../interop/vhost-user.rst:1041
msgid "``VHOST_USER_GET_VRING_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:317 ../../../interop/vhost-user.rst:330
msgid "``VHOST_USER_SET_LOG_BASE`` (if ``VHOST_USER_PROTOCOL_F_LOG_SHMFD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:318
msgid ""
"``VHOST_USER_GET_INFLIGHT_FD`` (if ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:322
msgid ":ref:`REPLY_ACK <reply_ack>`"
msgstr ""

#: ../../../interop/vhost-user.rst:323
msgid "The section on ``REPLY_ACK`` protocol extension."
msgstr ""

#: ../../../interop/vhost-user.rst:325
msgid ""
"There are several messages that the front-end sends with file descriptors "
"passed in the ancillary data:"
msgstr ""

#: ../../../interop/vhost-user.rst:328 ../../../interop/vhost-user.rst:1373
msgid "``VHOST_USER_ADD_MEM_REG``"
msgstr ""

#: ../../../interop/vhost-user.rst:329 ../../../interop/vhost-user.rst:970
msgid "``VHOST_USER_SET_MEM_TABLE``"
msgstr ""

#: ../../../interop/vhost-user.rst:331 ../../../interop/vhost-user.rst:1007
msgid "``VHOST_USER_SET_LOG_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:332 ../../../interop/vhost-user.rst:1047
msgid "``VHOST_USER_SET_VRING_KICK``"
msgstr ""

#: ../../../interop/vhost-user.rst:333 ../../../interop/vhost-user.rst:1066
msgid "``VHOST_USER_SET_VRING_CALL``"
msgstr ""

#: ../../../interop/vhost-user.rst:334 ../../../interop/vhost-user.rst:1085
msgid "``VHOST_USER_SET_VRING_ERR``"
msgstr ""

#: ../../../interop/vhost-user.rst:335 ../../../interop/vhost-user.rst:1160
msgid ""
"``VHOST_USER_SET_BACKEND_REQ_FD`` (previous name "
"``VHOST_USER_SET_SLAVE_REQ_FD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:336
msgid ""
"``VHOST_USER_SET_INFLIGHT_FD`` (if ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD``)"
msgstr ""

#: ../../../interop/vhost-user.rst:338
msgid ""
"If *front-end* is unable to send the full message or receives a wrong reply "
"it will close the connection. An optional reconnection mechanism can be "
"implemented."
msgstr ""

#: ../../../interop/vhost-user.rst:342
msgid ""
"If *back-end* detects some error such as incompatible features, it may also "
"close the connection. This should only happen in exceptional circumstances."
msgstr ""

#: ../../../interop/vhost-user.rst:345
msgid ""
"Any protocol extensions are gated by protocol feature bits, which allows "
"full backwards compatibility on both front-end and back-end.  As older back-"
"ends don't support negotiating protocol features, a feature bit was "
"dedicated for this purpose::"
msgstr ""

#: ../../../interop/vhost-user.rst:350
msgid "#define VHOST_USER_F_PROTOCOL_FEATURES 30"
msgstr ""

#: ../../../interop/vhost-user.rst:352
msgid ""
"Note that VHOST_USER_F_PROTOCOL_FEATURES is the UNUSED (30) feature bit "
"defined in `VIRTIO 1.1 6.3 Legacy Interface: Reserved Feature Bits <https://"
"docs.oasis-open.org/virtio/virtio/v1.1/cs01/virtio-v1.1-cs01."
"html#x1-4130003>`_. VIRTIO devices do not advertise this feature bit and "
"therefore VIRTIO drivers cannot negotiate it."
msgstr ""

#: ../../../interop/vhost-user.rst:358
msgid ""
"This reserved feature bit was reused by the vhost-user protocol to add vhost-"
"user protocol feature negotiation in a backwards compatible fashion. Old "
"vhost-user front-end and back-end implementations continue to work even "
"though they are not aware of vhost-user protocol feature negotiation."
msgstr ""

#: ../../../interop/vhost-user.rst:365
msgid "Ring states"
msgstr ""

#: ../../../interop/vhost-user.rst:367
msgid "Rings can be in one of three states:"
msgstr ""

#: ../../../interop/vhost-user.rst:369
msgid "stopped: the back-end must not process the ring at all."
msgstr ""

#: ../../../interop/vhost-user.rst:371
msgid ""
"started but disabled: the back-end must process the ring without causing any "
"side effects.  For example, for a networking device, in the disabled state "
"the back-end must not supply any new RX packets, but must process and "
"discard any TX packets."
msgstr ""

#: ../../../interop/vhost-user.rst:376
msgid "started and enabled."
msgstr ""

#: ../../../interop/vhost-user.rst:378
msgid ""
"Each ring is initialized in a stopped state.  The back-end must start ring "
"upon receiving a kick (that is, detecting that file descriptor is readable) "
"on the descriptor specified by ``VHOST_USER_SET_VRING_KICK`` or receiving "
"the in-band message ``VHOST_USER_VRING_KICK`` if negotiated, and stop ring "
"upon receiving ``VHOST_USER_GET_VRING_BASE``."
msgstr ""

#: ../../../interop/vhost-user.rst:384
msgid "Rings can be enabled or disabled by ``VHOST_USER_SET_VRING_ENABLE``."
msgstr ""

#: ../../../interop/vhost-user.rst:386
msgid ""
"If ``VHOST_USER_F_PROTOCOL_FEATURES`` has not been negotiated, the ring "
"starts directly in the enabled state."
msgstr ""

#: ../../../interop/vhost-user.rst:389
msgid ""
"If ``VHOST_USER_F_PROTOCOL_FEATURES`` has been negotiated, the ring is "
"initialized in a disabled state and is enabled by "
"``VHOST_USER_SET_VRING_ENABLE`` with parameter 1."
msgstr ""

#: ../../../interop/vhost-user.rst:393
msgid ""
"While processing the rings (whether they are enabled or not), the back-end "
"must support changing some configuration aspects on the fly."
msgstr ""

#: ../../../interop/vhost-user.rst:397
msgid "Multiple queue support"
msgstr ""

#: ../../../interop/vhost-user.rst:399
msgid ""
"Many devices have a fixed number of virtqueues.  In this case the front-end "
"already knows the number of available virtqueues without communicating with "
"the back-end."
msgstr ""

#: ../../../interop/vhost-user.rst:403
msgid ""
"Some devices do not have a fixed number of virtqueues.  Instead the maximum "
"number of virtqueues is chosen by the back-end.  The number can depend on "
"host resource availability or back-end implementation details.  Such devices "
"are called multiple queue devices."
msgstr ""

#: ../../../interop/vhost-user.rst:408
msgid ""
"Multiple queue support allows the back-end to advertise the maximum number "
"of queues.  This is treated as a protocol extension, hence the back-end has "
"to implement protocol features first. The multiple queues feature is "
"supported only when the protocol feature ``VHOST_USER_PROTOCOL_F_MQ`` (bit "
"0) is set."
msgstr ""

#: ../../../interop/vhost-user.rst:413
msgid ""
"The max number of queues the back-end supports can be queried with message "
"``VHOST_USER_GET_QUEUE_NUM``. Front-end should stop when the number of "
"requested queues is bigger than that."
msgstr ""

#: ../../../interop/vhost-user.rst:417
msgid ""
"As all queues share one connection, the front-end uses a unique index for "
"each queue in the sent message to identify a specified queue."
msgstr ""

#: ../../../interop/vhost-user.rst:420
msgid ""
"The front-end enables queues by sending message "
"``VHOST_USER_SET_VRING_ENABLE``. vhost-user-net has historically "
"automatically enabled the first queue pair."
msgstr ""

#: ../../../interop/vhost-user.rst:423
msgid ""
"Back-ends should always implement the ``VHOST_USER_PROTOCOL_F_MQ`` protocol "
"feature, even for devices with a fixed number of virtqueues, since it is "
"simple to implement and offers a degree of introspection."
msgstr ""

#: ../../../interop/vhost-user.rst:427
msgid ""
"Front-ends must not rely on the ``VHOST_USER_PROTOCOL_F_MQ`` protocol "
"feature for devices with a fixed number of virtqueues.  Only true multiqueue "
"devices require this protocol feature."
msgstr ""

#: ../../../interop/vhost-user.rst:432
msgid "Migration"
msgstr ""

#: ../../../interop/vhost-user.rst:434
msgid ""
"During live migration, the front-end may need to track the modifications the "
"back-end makes to the memory mapped regions. The front-end should mark the "
"dirty pages in a log. Once it complies to this logging, it may declare the "
"``VHOST_F_LOG_ALL`` vhost feature."
msgstr ""

#: ../../../interop/vhost-user.rst:439
msgid ""
"To start/stop logging of data/used ring writes, the front-end may send "
"messages ``VHOST_USER_SET_FEATURES`` with ``VHOST_F_LOG_ALL`` and "
"``VHOST_USER_SET_VRING_ADDR`` with ``VHOST_VRING_F_LOG`` in ring's flags set "
"to 1/0, respectively."
msgstr ""

#: ../../../interop/vhost-user.rst:444
msgid ""
"All the modifications to memory pointed by vring \"descriptor\" should be "
"marked. Modifications to \"used\" vring should be marked if "
"``VHOST_VRING_F_LOG`` is part of ring's flags."
msgstr ""

#: ../../../interop/vhost-user.rst:448
msgid "Dirty pages are of size::"
msgstr ""

#: ../../../interop/vhost-user.rst:450
msgid "#define VHOST_LOG_PAGE 0x1000"
msgstr ""

#: ../../../interop/vhost-user.rst:452
msgid ""
"The log memory fd is provided in the ancillary data of "
"``VHOST_USER_SET_LOG_BASE`` message when the back-end has "
"``VHOST_USER_PROTOCOL_F_LOG_SHMFD`` protocol feature."
msgstr ""

#: ../../../interop/vhost-user.rst:456
msgid ""
"The size of the log is supplied as part of ``VhostUserMsg`` which should be "
"large enough to cover all known guest addresses. Log starts at the supplied "
"offset in the supplied file descriptor.  The log covers from address 0 to "
"the maximum of guest regions. In pseudo-code, to mark page at ``addr`` as "
"dirty::"
msgstr ""

#: ../../../interop/vhost-user.rst:462
msgid ""
"page = addr / VHOST_LOG_PAGE\n"
"log[page / 8] |= 1 << page % 8"
msgstr ""

#: ../../../interop/vhost-user.rst:465
msgid "Where ``addr`` is the guest physical address."
msgstr ""

#: ../../../interop/vhost-user.rst:467
msgid "Use atomic operations, as the log may be concurrently manipulated."
msgstr ""

#: ../../../interop/vhost-user.rst:469
msgid ""
"Note that when logging modifications to the used ring (when "
"``VHOST_VRING_F_LOG`` is set for this ring), ``log_guest_addr`` should be "
"used to calculate the log offset: the write to first byte of the used ring "
"is logged at this offset from log start. Also note that this value might be "
"outside the legal guest physical address range (i.e. does not have to be "
"covered by the ``VhostUserMemory`` table), but the bit offset of the last "
"byte of the ring must fall within the size supplied by ``VhostUserLog``."
msgstr ""

#: ../../../interop/vhost-user.rst:478
msgid ""
"``VHOST_USER_SET_LOG_FD`` is an optional message with an eventfd in "
"ancillary data, it may be used to inform the front-end that the log has been "
"modified."
msgstr ""

#: ../../../interop/vhost-user.rst:482
msgid ""
"Once the source has finished migration, rings will be stopped by the source. "
"No further update must be done before rings are restarted."
msgstr ""

#: ../../../interop/vhost-user.rst:485
msgid ""
"In postcopy migration the back-end is started before all the memory has been "
"received from the source host, and care must be taken to avoid accessing "
"pages that have yet to be received.  The back-end opens a 'userfault'-fd and "
"registers the memory with it; this fd is then passed back over to the front-"
"end.  The front-end services requests on the userfaultfd for pages that are "
"accessed and when the page is available it performs WAKE ioctl's on the "
"userfaultfd to wake the stalled back-end.  The front-end indicates support "
"for this via the ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` feature."
msgstr ""

#: ../../../interop/vhost-user.rst:496
msgid "Memory access"
msgstr ""

#: ../../../interop/vhost-user.rst:498
msgid ""
"The front-end sends a list of vhost memory regions to the back-end using the "
"``VHOST_USER_SET_MEM_TABLE`` message.  Each region has two base addresses: a "
"guest address and a user address."
msgstr ""

#: ../../../interop/vhost-user.rst:502
msgid ""
"Messages contain guest addresses and/or user addresses to reference "
"locations within the shared memory.  The mapping of these addresses works as "
"follows."
msgstr ""

#: ../../../interop/vhost-user.rst:505
msgid ""
"User addresses map to the vhost memory region containing that user address."
msgstr ""

#: ../../../interop/vhost-user.rst:507
msgid "When the ``VIRTIO_F_IOMMU_PLATFORM`` feature has not been negotiated:"
msgstr ""

#: ../../../interop/vhost-user.rst:509
msgid ""
"Guest addresses map to the vhost memory region containing that guest address."
msgstr ""

#: ../../../interop/vhost-user.rst:512
msgid "When the ``VIRTIO_F_IOMMU_PLATFORM`` feature has been negotiated:"
msgstr ""

#: ../../../interop/vhost-user.rst:514
msgid ""
"Guest addresses are also called I/O virtual addresses (IOVAs).  They are "
"translated to user addresses via the IOTLB."
msgstr ""

#: ../../../interop/vhost-user.rst:517
msgid "The vhost memory region guest address is not used."
msgstr ""

#: ../../../interop/vhost-user.rst:520
msgid "IOMMU support"
msgstr ""

#: ../../../interop/vhost-user.rst:522
msgid ""
"When the ``VIRTIO_F_IOMMU_PLATFORM`` feature has been negotiated, the front-"
"end sends IOTLB entries update & invalidation by sending "
"``VHOST_USER_IOTLB_MSG`` requests to the back-end with a ``struct "
"vhost_iotlb_msg`` as payload. For update events, the ``iotlb`` payload has "
"to be filled with the update message type (2), the I/O virtual address, the "
"size, the user virtual address, and the permissions flags. Addresses and "
"size must be within vhost memory regions set via the "
"``VHOST_USER_SET_MEM_TABLE`` request. For invalidation events, the ``iotlb`` "
"payload has to be filled with the invalidation message type (3), the I/O "
"virtual address and the size. On success, the back-end is expected to reply "
"with a zero payload, non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:534
msgid ""
"The back-end relies on the back-end communication channel (see :ref:`Back-"
"end communication <backend_communication>` section below) to send IOTLB miss "
"and access failure events, by sending ``VHOST_USER_BACKEND_IOTLB_MSG`` "
"requests to the front-end with a ``struct vhost_iotlb_msg`` as payload. For "
"miss events, the iotlb payload has to be filled with the miss message type "
"(1), the I/O virtual address and the permissions flags. For access failure "
"event, the iotlb payload has to be filled with the access failure message "
"type (4), the I/O virtual address and the permissions flags.  For "
"synchronization purpose, the back-end may rely on the reply-ack feature, so "
"the front-end may send a reply when operation is completed if the reply-ack "
"feature is negotiated and back-ends requests a reply. For miss events, "
"completed operation means either front-end sent an update message containing "
"the IOTLB entry containing requested address and permission, or front-end "
"sent nothing if the IOTLB miss message is invalid (invalid IOVA or "
"permission)."
msgstr ""

#: ../../../interop/vhost-user.rst:550
msgid ""
"The front-end isn't expected to take the initiative to send IOTLB update "
"messages, as the back-end sends IOTLB miss messages for the guest virtual "
"memory areas it needs to access."
msgstr ""

#: ../../../interop/vhost-user.rst:557
msgid "Back-end communication"
msgstr ""

#: ../../../interop/vhost-user.rst:559
msgid ""
"An optional communication channel is provided if the back-end declares "
"``VHOST_USER_PROTOCOL_F_BACKEND_REQ`` protocol feature, to allow the back-"
"end to make requests to the front-end."
msgstr ""

#: ../../../interop/vhost-user.rst:563
msgid ""
"The fd is provided via ``VHOST_USER_SET_BACKEND_REQ_FD`` ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:565
msgid ""
"A back-end may then send ``VHOST_USER_BACKEND_*`` messages to the front-end "
"using this fd communication channel."
msgstr ""

#: ../../../interop/vhost-user.rst:568
msgid ""
"If ``VHOST_USER_PROTOCOL_F_BACKEND_SEND_FD`` protocol feature is negotiated, "
"back-end can send file descriptors (at most 8 descriptors in each message) "
"to front-end via ancillary data using this fd communication channel."
msgstr ""

#: ../../../interop/vhost-user.rst:574
msgid "Inflight I/O tracking"
msgstr ""

#: ../../../interop/vhost-user.rst:576
msgid ""
"To support reconnecting after restart or crash, back-end may need to "
"resubmit inflight I/Os. If virtqueue is processed in order, we can easily "
"achieve that by getting the inflight descriptors from descriptor table "
"(split virtqueue) or descriptor ring (packed virtqueue). However, it can't "
"work when we process descriptors out-of-order because some entries which "
"store the information of inflight descriptors in available ring (split "
"virtqueue) or descriptor ring (packed virtqueue) might be overridden by new "
"entries. To solve this problem, the back-end need to allocate an extra "
"buffer to store this information of inflight descriptors and share it with "
"front-end for persistent. ``VHOST_USER_GET_INFLIGHT_FD`` and "
"``VHOST_USER_SET_INFLIGHT_FD`` are used to transfer this buffer between "
"front-end and back-end. And the format of this buffer is described below:"
msgstr ""

#: ../../../interop/vhost-user.rst:592
msgid "queue0 region"
msgstr ""

#: ../../../interop/vhost-user.rst:592
msgid "queue1 region"
msgstr ""

#: ../../../interop/vhost-user.rst:592
msgid "queueN region"
msgstr ""

#: ../../../interop/vhost-user.rst:595
msgid ""
"N is the number of available virtqueues. The back-end could get it from num "
"queues field of ``VhostUserInflight``."
msgstr ""

#: ../../../interop/vhost-user.rst:598
msgid "For split virtqueue, queue region can be implemented as:"
msgstr ""

#: ../../../interop/vhost-user.rst:600
msgid ""
"typedef struct DescStateSplit {\n"
"    /* Indicate whether this descriptor is inflight or not.\n"
"     * Only available for head-descriptor. */\n"
"    uint8_t inflight;\n"
"\n"
"    /* Padding */\n"
"    uint8_t padding[5];\n"
"\n"
"    /* Maintain a list for the last batch of used descriptors.\n"
"     * Only available when batching is used for submitting */\n"
"    uint16_t next;\n"
"\n"
"    /* Used to preserve the order of fetching available descriptors.\n"
"     * Only available for head-descriptor. */\n"
"    uint64_t counter;\n"
"} DescStateSplit;\n"
"\n"
"typedef struct QueueRegionSplit {\n"
"    /* The feature flags of this region. Now it's initialized to 0. */\n"
"    uint64_t features;\n"
"\n"
"    /* The version of this region. It's 1 currently.\n"
"     * Zero value indicates an uninitialized buffer */\n"
"    uint16_t version;\n"
"\n"
"    /* The size of DescStateSplit array. It's equal to the virtqueue size.\n"
"     * The back-end could get it from queue size field of VhostUserInflight. "
"*/\n"
"    uint16_t desc_num;\n"
"\n"
"    /* The head of list that track the last batch of used descriptors. */\n"
"    uint16_t last_batch_head;\n"
"\n"
"    /* Store the idx value of used ring */\n"
"    uint16_t used_idx;\n"
"\n"
"    /* Used to track the state of each descriptor in descriptor table */\n"
"    DescStateSplit desc[];\n"
"} QueueRegionSplit;"
msgstr ""

#: ../../../interop/vhost-user.rst:641 ../../../interop/vhost-user.rst:763
msgid "To track inflight I/O, the queue region should be processed as follows:"
msgstr ""

#: ../../../interop/vhost-user.rst:643 ../../../interop/vhost-user.rst:765
msgid "When receiving available buffers from the driver:"
msgstr ""

#: ../../../interop/vhost-user.rst:645
msgid "Get the next available head-descriptor index from available ring, ``i``"
msgstr ""

#: ../../../interop/vhost-user.rst:647
msgid "Set ``desc[i].counter`` to the value of global counter"
msgstr ""

#: ../../../interop/vhost-user.rst:649 ../../../interop/vhost-user.rst:775
msgid "Increase global counter by 1"
msgstr ""

#: ../../../interop/vhost-user.rst:651
msgid "Set ``desc[i].inflight`` to 1"
msgstr ""

#: ../../../interop/vhost-user.rst:653 ../../../interop/vhost-user.rst:792
msgid "When supplying used buffers to the driver:"
msgstr ""

#: ../../../interop/vhost-user.rst:655
msgid "Get corresponding used head-descriptor index, i"
msgstr ""

#: ../../../interop/vhost-user.rst:657
msgid "Set ``desc[i].next`` to ``last_batch_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:659
msgid "Set ``last_batch_head`` to ``i``"
msgstr ""

#: ../../../interop/vhost-user.rst:661
msgid "Steps 1,2,3 may be performed repeatedly if batching is possible"
msgstr ""

#: ../../../interop/vhost-user.rst:663
msgid "Increase the ``idx`` value of used ring by the size of the batch"
msgstr ""

#: ../../../interop/vhost-user.rst:665
msgid ""
"Set the ``inflight`` field of each ``DescStateSplit`` entry in the batch to 0"
msgstr ""

#: ../../../interop/vhost-user.rst:667 ../../../interop/vhost-user.rst:681
msgid "Set ``used_idx`` to the ``idx`` value of used ring"
msgstr ""

#: ../../../interop/vhost-user.rst:669 ../../../interop/vhost-user.rst:816
msgid "When reconnecting:"
msgstr ""

#: ../../../interop/vhost-user.rst:671
msgid ""
"If the value of ``used_idx`` does not match the ``idx`` value of used ring "
"(means the inflight field of ``DescStateSplit`` entries in last batch may be "
"incorrect),"
msgstr ""

#: ../../../interop/vhost-user.rst:675
msgid ""
"Subtract the value of ``used_idx`` from the ``idx`` value of used ring to "
"get last batch size of ``DescStateSplit`` entries"
msgstr ""

#: ../../../interop/vhost-user.rst:678
msgid ""
"Set the ``inflight`` field of each ``DescStateSplit`` entry to 0 in last "
"batch list which starts from ``last_batch_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:683
msgid ""
"Resubmit inflight ``DescStateSplit`` entries in order of their counter value"
msgstr ""

#: ../../../interop/vhost-user.rst:686
msgid "For packed virtqueue, queue region can be implemented as:"
msgstr ""

#: ../../../interop/vhost-user.rst:688
msgid ""
"typedef struct DescStatePacked {\n"
"    /* Indicate whether this descriptor is inflight or not.\n"
"     * Only available for head-descriptor. */\n"
"    uint8_t inflight;\n"
"\n"
"    /* Padding */\n"
"    uint8_t padding;\n"
"\n"
"    /* Link to the next free entry */\n"
"    uint16_t next;\n"
"\n"
"    /* Link to the last entry of descriptor list.\n"
"     * Only available for head-descriptor. */\n"
"    uint16_t last;\n"
"\n"
"    /* The length of descriptor list.\n"
"     * Only available for head-descriptor. */\n"
"    uint16_t num;\n"
"\n"
"    /* Used to preserve the order of fetching available descriptors.\n"
"     * Only available for head-descriptor. */\n"
"    uint64_t counter;\n"
"\n"
"    /* The buffer id */\n"
"    uint16_t id;\n"
"\n"
"    /* The descriptor flags */\n"
"    uint16_t flags;\n"
"\n"
"    /* The buffer length */\n"
"    uint32_t len;\n"
"\n"
"    /* The buffer address */\n"
"    uint64_t addr;\n"
"} DescStatePacked;\n"
"\n"
"typedef struct QueueRegionPacked {\n"
"    /* The feature flags of this region. Now it's initialized to 0. */\n"
"    uint64_t features;\n"
"\n"
"    /* The version of this region. It's 1 currently.\n"
"     * Zero value indicates an uninitialized buffer */\n"
"    uint16_t version;\n"
"\n"
"    /* The size of DescStatePacked array. It's equal to the virtqueue size.\n"
"     * The back-end could get it from queue size field of VhostUserInflight. "
"*/\n"
"    uint16_t desc_num;\n"
"\n"
"    /* The head of free DescStatePacked entry list */\n"
"    uint16_t free_head;\n"
"\n"
"    /* The old head of free DescStatePacked entry list */\n"
"    uint16_t old_free_head;\n"
"\n"
"    /* The used index of descriptor ring */\n"
"    uint16_t used_idx;\n"
"\n"
"    /* The old used index of descriptor ring */\n"
"    uint16_t old_used_idx;\n"
"\n"
"    /* Device ring wrap counter */\n"
"    uint8_t used_wrap_counter;\n"
"\n"
"    /* The old device ring wrap counter */\n"
"    uint8_t old_used_wrap_counter;\n"
"\n"
"    /* Padding */\n"
"    uint8_t padding[7];\n"
"\n"
"    /* Used to track the state of each descriptor fetched from descriptor "
"ring */\n"
"    DescStatePacked desc[];\n"
"} QueueRegionPacked;"
msgstr ""

#: ../../../interop/vhost-user.rst:767
msgid "Get the next available descriptor entry from descriptor ring, ``d``"
msgstr ""

#: ../../../interop/vhost-user.rst:769
msgid "If ``d`` is head descriptor,"
msgstr ""

#: ../../../interop/vhost-user.rst:771
msgid "Set ``desc[old_free_head].num`` to 0"
msgstr ""

#: ../../../interop/vhost-user.rst:773
msgid "Set ``desc[old_free_head].counter`` to the value of global counter"
msgstr ""

#: ../../../interop/vhost-user.rst:777
msgid "Set ``desc[old_free_head].inflight`` to 1"
msgstr ""

#: ../../../interop/vhost-user.rst:779
msgid ""
"If ``d`` is last descriptor, set ``desc[old_free_head].last`` to "
"``free_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:782
msgid "Increase ``desc[old_free_head].num`` by 1"
msgstr ""

#: ../../../interop/vhost-user.rst:784
msgid ""
"Set ``desc[free_head].addr``, ``desc[free_head].len``, ``desc[free_head]."
"flags``, ``desc[free_head].id`` to ``d.addr``, ``d.len``, ``d.flags``, ``d."
"id``"
msgstr ""

#: ../../../interop/vhost-user.rst:788
msgid "Set ``free_head`` to ``desc[free_head].next``"
msgstr ""

#: ../../../interop/vhost-user.rst:790
msgid "If ``d`` is last descriptor, set ``old_free_head`` to ``free_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:794
msgid ""
"Get corresponding used head-descriptor entry from descriptor ring, ``d``"
msgstr ""

#: ../../../interop/vhost-user.rst:797
msgid "Get corresponding ``DescStatePacked`` entry, ``e``"
msgstr ""

#: ../../../interop/vhost-user.rst:799
msgid "Set ``desc[e.last].next`` to ``free_head``"
msgstr ""

#: ../../../interop/vhost-user.rst:801
msgid "Set ``free_head`` to the index of ``e``"
msgstr ""

#: ../../../interop/vhost-user.rst:803
msgid "Steps 1,2,3,4 may be performed repeatedly if batching is possible"
msgstr ""

#: ../../../interop/vhost-user.rst:805
msgid ""
"Increase ``used_idx`` by the size of the batch and update "
"``used_wrap_counter`` if needed"
msgstr ""

#: ../../../interop/vhost-user.rst:808
msgid "Update ``d.flags``"
msgstr ""

#: ../../../interop/vhost-user.rst:810
msgid ""
"Set the ``inflight`` field of each head ``DescStatePacked`` entry in the "
"batch to 0"
msgstr ""

#: ../../../interop/vhost-user.rst:813
msgid ""
"Set ``old_free_head``,  ``old_used_idx``, ``old_used_wrap_counter`` to "
"``free_head``, ``used_idx``, ``used_wrap_counter``"
msgstr ""

#: ../../../interop/vhost-user.rst:818
msgid ""
"If ``used_idx`` does not match ``old_used_idx`` (means the ``inflight`` "
"field of ``DescStatePacked`` entries in last batch may be incorrect),"
msgstr ""

#: ../../../interop/vhost-user.rst:822
msgid "Get the next descriptor ring entry through ``old_used_idx``, ``d``"
msgstr ""

#: ../../../interop/vhost-user.rst:824
msgid "Use ``old_used_wrap_counter`` to calculate the available flags"
msgstr ""

#: ../../../interop/vhost-user.rst:826
msgid ""
"If ``d.flags`` is not equal to the calculated flags value (means back-end "
"has submitted the buffer to guest driver before crash, so it has to commit "
"the in-progres update), set ``old_free_head``, ``old_used_idx``, "
"``old_used_wrap_counter`` to ``free_head``, ``used_idx``, "
"``used_wrap_counter``"
msgstr ""

#: ../../../interop/vhost-user.rst:832
msgid ""
"Set ``free_head``, ``used_idx``, ``used_wrap_counter`` to ``old_free_head``, "
"``old_used_idx``, ``old_used_wrap_counter`` (roll back any in-progress "
"update)"
msgstr ""

#: ../../../interop/vhost-user.rst:836
msgid ""
"Set the ``inflight`` field of each ``DescStatePacked`` entry in free list to "
"0"
msgstr ""

#: ../../../interop/vhost-user.rst:839
msgid ""
"Resubmit inflight ``DescStatePacked`` entries in order of their counter value"
msgstr ""

#: ../../../interop/vhost-user.rst:843
msgid "In-band notifications"
msgstr ""

#: ../../../interop/vhost-user.rst:845
msgid ""
"In some limited situations (e.g. for simulation) it is desirable to have the "
"kick, call and error (if used) signals done via in-band messages instead of "
"asynchronous eventfd notifications. This can be done by negotiating the "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature."
msgstr ""

#: ../../../interop/vhost-user.rst:851
msgid ""
"Note that due to the fact that too many messages on the sockets can cause "
"the sending application(s) to block, it is not advised to use this feature "
"unless absolutely necessary. It is also considered an error to negotiate "
"this feature without also negotiating ``VHOST_USER_PROTOCOL_F_BACKEND_REQ`` "
"and ``VHOST_USER_PROTOCOL_F_REPLY_ACK``, the former is necessary for getting "
"a message channel from the back-end to the front-end, while the latter needs "
"to be used with the in-band notification messages to block until they are "
"processed, both to avoid blocking later and for proper processing (at least "
"in the simulation use case.) As it has no other way of signalling this "
"error, the back-end should close the connection as a response to a "
"``VHOST_USER_SET_PROTOCOL_FEATURES`` message that sets the in-band "
"notifications feature flag without the other two."
msgstr ""

#: ../../../interop/vhost-user.rst:866
msgid "Protocol features"
msgstr ""

#: ../../../interop/vhost-user.rst:868
msgid ""
"#define VHOST_USER_PROTOCOL_F_MQ                    0\n"
"#define VHOST_USER_PROTOCOL_F_LOG_SHMFD             1\n"
"#define VHOST_USER_PROTOCOL_F_RARP                  2\n"
"#define VHOST_USER_PROTOCOL_F_REPLY_ACK             3\n"
"#define VHOST_USER_PROTOCOL_F_MTU                   4\n"
"#define VHOST_USER_PROTOCOL_F_BACKEND_REQ           5\n"
"#define VHOST_USER_PROTOCOL_F_CROSS_ENDIAN          6\n"
"#define VHOST_USER_PROTOCOL_F_CRYPTO_SESSION        7\n"
"#define VHOST_USER_PROTOCOL_F_PAGEFAULT             8\n"
"#define VHOST_USER_PROTOCOL_F_CONFIG                9\n"
"#define VHOST_USER_PROTOCOL_F_BACKEND_SEND_FD      10\n"
"#define VHOST_USER_PROTOCOL_F_HOST_NOTIFIER        11\n"
"#define VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD       12\n"
"#define VHOST_USER_PROTOCOL_F_RESET_DEVICE         13\n"
"#define VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS 14\n"
"#define VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS  15\n"
"#define VHOST_USER_PROTOCOL_F_STATUS               16\n"
"#define VHOST_USER_PROTOCOL_F_XEN_MMAP             17"
msgstr ""

#: ../../../interop/vhost-user.rst:890
msgid "Front-end message types"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "id"
msgstr ""

#: ../../../interop/vhost-user.rst:893 ../../../interop/vhost-user.rst:1451
msgid "1"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "equivalent ioctl"
msgstr ""

#: ../../../interop/vhost-user.rst:894 ../../../interop/vhost-user.rst:916
msgid "``VHOST_GET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "request payload"
msgstr ""

#: ../../../interop/vhost-user.rst:895 ../../../interop/vhost-user.rst:907
#: ../../../interop/vhost-user.rst:917 ../../../interop/vhost-user.rst:935
#: ../../../interop/vhost-user.rst:950 ../../../interop/vhost-user.rst:951
#: ../../../interop/vhost-user.rst:959 ../../../interop/vhost-user.rst:960
#: ../../../interop/vhost-user.rst:998 ../../../interop/vhost-user.rst:1010
#: ../../../interop/vhost-user.rst:1011 ../../../interop/vhost-user.rst:1019
#: ../../../interop/vhost-user.rst:1027 ../../../interop/vhost-user.rst:1035
#: ../../../interop/vhost-user.rst:1051 ../../../interop/vhost-user.rst:1070
#: ../../../interop/vhost-user.rst:1089 ../../../interop/vhost-user.rst:1105
#: ../../../interop/vhost-user.rst:1106 ../../../interop/vhost-user.rst:1117
#: ../../../interop/vhost-user.rst:1119 ../../../interop/vhost-user.rst:1128
#: ../../../interop/vhost-user.rst:1130 ../../../interop/vhost-user.rst:1144
#: ../../../interop/vhost-user.rst:1146 ../../../interop/vhost-user.rst:1162
#: ../../../interop/vhost-user.rst:1163 ../../../interop/vhost-user.rst:1164
#: ../../../interop/vhost-user.rst:1195 ../../../interop/vhost-user.rst:1209
#: ../../../interop/vhost-user.rst:1223 ../../../interop/vhost-user.rst:1225
#: ../../../interop/vhost-user.rst:1236 ../../../interop/vhost-user.rst:1249
#: ../../../interop/vhost-user.rst:1251 ../../../interop/vhost-user.rst:1263
#: ../../../interop/vhost-user.rst:1273 ../../../interop/vhost-user.rst:1274
#: ../../../interop/vhost-user.rst:1285 ../../../interop/vhost-user.rst:1300
#: ../../../interop/vhost-user.rst:1302 ../../../interop/vhost-user.rst:1312
#: ../../../interop/vhost-user.rst:1314 ../../../interop/vhost-user.rst:1323
#: ../../../interop/vhost-user.rst:1324 ../../../interop/vhost-user.rst:1325
#: ../../../interop/vhost-user.rst:1333 ../../../interop/vhost-user.rst:1334
#: ../../../interop/vhost-user.rst:1335 ../../../interop/vhost-user.rst:1347
#: ../../../interop/vhost-user.rst:1349 ../../../interop/vhost-user.rst:1361
#: ../../../interop/vhost-user.rst:1362 ../../../interop/vhost-user.rst:1375
#: ../../../interop/vhost-user.rst:1376 ../../../interop/vhost-user.rst:1399
#: ../../../interop/vhost-user.rst:1400 ../../../interop/vhost-user.rst:1425
#: ../../../interop/vhost-user.rst:1435 ../../../interop/vhost-user.rst:1454
#: ../../../interop/vhost-user.rst:1467 ../../../interop/vhost-user.rst:1468
#: ../../../interop/vhost-user.rst:1469 ../../../interop/vhost-user.rst:1482
#: ../../../interop/vhost-user.rst:1484 ../../../interop/vhost-user.rst:1505
#: ../../../interop/vhost-user.rst:1507 ../../../interop/vhost-user.rst:1519
#: ../../../interop/vhost-user.rst:1521
msgid "N/A"
msgstr ""

#: ../../../interop/vhost-user.rst:0
msgid "reply payload"
msgstr ""

#: ../../../interop/vhost-user.rst:896 ../../../interop/vhost-user.rst:906
#: ../../../interop/vhost-user.rst:918 ../../../interop/vhost-user.rst:934
#: ../../../interop/vhost-user.rst:1050 ../../../interop/vhost-user.rst:1069
#: ../../../interop/vhost-user.rst:1088 ../../../interop/vhost-user.rst:1129
#: ../../../interop/vhost-user.rst:1145 ../../../interop/vhost-user.rst:1180
#: ../../../interop/vhost-user.rst:1250 ../../../interop/vhost-user.rst:1286
#: ../../../interop/vhost-user.rst:1424 ../../../interop/vhost-user.rst:1436
msgid "``u64``"
msgstr ""

#: ../../../interop/vhost-user.rst:898
msgid ""
"Get from the underlying vhost implementation the features bitmask. Feature "
"bit ``VHOST_USER_F_PROTOCOL_FEATURES`` signals back-end support for "
"``VHOST_USER_GET_PROTOCOL_FEATURES`` and "
"``VHOST_USER_SET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:903
msgid "``VHOST_USER_SET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:904 ../../../interop/vhost-user.rst:1466
msgid "2"
msgstr ""

#: ../../../interop/vhost-user.rst:905 ../../../interop/vhost-user.rst:933
msgid "``VHOST_SET_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:909
msgid ""
"Enable features in the underlying vhost implementation using a bitmask.  "
"Feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` signals back-end support for "
"``VHOST_USER_GET_PROTOCOL_FEATURES`` and "
"``VHOST_USER_SET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:915
msgid "15"
msgstr ""

#: ../../../interop/vhost-user.rst:920
msgid ""
"Get the protocol feature bitmask from the underlying vhost implementation.  "
"Only legal if feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES``.  It does not need to be acknowledged by "
"``VHOST_USER_SET_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:927 ../../../interop/vhost-user.rst:944
msgid ""
"Back-ends that report ``VHOST_USER_F_PROTOCOL_FEATURES`` must support this "
"message even before ``VHOST_USER_SET_FEATURES`` was called."
msgstr ""

#: ../../../interop/vhost-user.rst:931
msgid "``VHOST_USER_SET_PROTOCOL_FEATURES``"
msgstr ""

#: ../../../interop/vhost-user.rst:932
msgid "16"
msgstr ""

#: ../../../interop/vhost-user.rst:937
msgid "Enable protocol features in the underlying vhost implementation."
msgstr ""

#: ../../../interop/vhost-user.rst:939
msgid ""
"Only legal if feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES``.  It does not need to be acknowledged by "
"``VHOST_USER_SET_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:947
msgid "``VHOST_USER_SET_OWNER``"
msgstr ""

#: ../../../interop/vhost-user.rst:948 ../../../interop/vhost-user.rst:1481
msgid "3"
msgstr ""

#: ../../../interop/vhost-user.rst:949
msgid "``VHOST_SET_OWNER``"
msgstr ""

#: ../../../interop/vhost-user.rst:953
msgid ""
"Issued when a new connection is established. It marks the sender as the "
"front-end that owns of the session. This can be used on the *back-end* as a "
"\"session start\" flag."
msgstr ""

#: ../../../interop/vhost-user.rst:957
msgid "``VHOST_USER_RESET_OWNER``"
msgstr ""

#: ../../../interop/vhost-user.rst:958 ../../../interop/vhost-user.rst:1504
msgid "4"
msgstr ""

#: ../../../interop/vhost-user.rst:962
msgid "Deprecated"
msgstr ""

#: ../../../interop/vhost-user.rst:964
msgid ""
"This is no longer used. Used to be sent to request disabling all rings, but "
"some back-ends interpreted it to also discard connection state (this "
"interpretation would lead to bugs).  It is recommended that back-ends either "
"ignore this message, or use it to disable all rings."
msgstr ""

#: ../../../interop/vhost-user.rst:971 ../../../interop/vhost-user.rst:1518
msgid "5"
msgstr ""

#: ../../../interop/vhost-user.rst:972
msgid "``VHOST_SET_MEM_TABLE``"
msgstr ""

#: ../../../interop/vhost-user.rst:973
msgid "multiple memory regions description"
msgstr ""

#: ../../../interop/vhost-user.rst:974
msgid "(postcopy only) multiple memory regions description"
msgstr ""

#: ../../../interop/vhost-user.rst:976
msgid ""
"Sets the memory map regions on the back-end so it can translate the vring "
"addresses. In the ancillary data there is an array of file descriptors for "
"each memory mapped region. The size and ordering of the fds matches the "
"number and ordering of memory regions."
msgstr ""

#: ../../../interop/vhost-user.rst:981
msgid ""
"When ``VHOST_USER_POSTCOPY_LISTEN`` has been received, ``SET_MEM_TABLE`` "
"replies with the bases of the memory mapped regions to the front-end.  The "
"back-end must have mmap'd the regions but not yet accessed them and should "
"not yet generate a userfault event."
msgstr ""

#: ../../../interop/vhost-user.rst:988
msgid ""
"``NEED_REPLY_MASK`` is not set in this case.  QEMU will then reply back to "
"the list of mappings with an empty ``VHOST_USER_SET_MEM_TABLE`` as an "
"acknowledgement; only upon reception of this message may the guest start "
"accessing the memory and generating faults."
msgstr ""

#: ../../../interop/vhost-user.rst:994
msgid "``VHOST_USER_SET_LOG_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:995
msgid "6"
msgstr ""

#: ../../../interop/vhost-user.rst:996
msgid "``VHOST_SET_LOG_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1000
msgid "Sets logging shared memory space."
msgstr ""

#: ../../../interop/vhost-user.rst:1002
msgid ""
"When the back-end has ``VHOST_USER_PROTOCOL_F_LOG_SHMFD`` protocol feature, "
"the log memory fd is provided in the ancillary data of "
"``VHOST_USER_SET_LOG_BASE`` message, the size and offset of shared memory "
"area provided in the message."
msgstr ""

#: ../../../interop/vhost-user.rst:1008
msgid "7"
msgstr ""

#: ../../../interop/vhost-user.rst:1009
msgid "``VHOST_SET_LOG_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:1013
msgid "Sets the logging file descriptor, which is passed as ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1015
msgid "``VHOST_USER_SET_VRING_NUM``"
msgstr ""

#: ../../../interop/vhost-user.rst:1016
msgid "8"
msgstr ""

#: ../../../interop/vhost-user.rst:1017
msgid "``VHOST_SET_VRING_NUM``"
msgstr ""

#: ../../../interop/vhost-user.rst:1018 ../../../interop/vhost-user.rst:1034
#: ../../../interop/vhost-user.rst:1042 ../../../interop/vhost-user.rst:1043
#: ../../../interop/vhost-user.rst:1118 ../../../interop/vhost-user.rst:1194
#: ../../../interop/vhost-user.rst:1348 ../../../interop/vhost-user.rst:1506
#: ../../../interop/vhost-user.rst:1520
msgid "vring state description"
msgstr ""

#: ../../../interop/vhost-user.rst:1021
msgid "Set the size of the queue."
msgstr ""

#: ../../../interop/vhost-user.rst:1023
msgid "``VHOST_USER_SET_VRING_ADDR``"
msgstr ""

#: ../../../interop/vhost-user.rst:1024
msgid "9"
msgstr ""

#: ../../../interop/vhost-user.rst:1025
msgid "``VHOST_SET_VRING_ADDR``"
msgstr ""

#: ../../../interop/vhost-user.rst:1026
msgid "vring address description"
msgstr ""

#: ../../../interop/vhost-user.rst:1029
msgid "Sets the addresses of the different aspects of the vring."
msgstr ""

#: ../../../interop/vhost-user.rst:1031
msgid "``VHOST_USER_SET_VRING_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1032
msgid "10"
msgstr ""

#: ../../../interop/vhost-user.rst:1033
msgid "``VHOST_SET_VRING_BASE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1037
msgid "Sets the base offset in the available vring."
msgstr ""

#: ../../../interop/vhost-user.rst:1040
msgid "11"
msgstr ""

#: ../../../interop/vhost-user.rst:1045
msgid "Get the available vring base offset."
msgstr ""

#: ../../../interop/vhost-user.rst:1048
msgid "12"
msgstr ""

#: ../../../interop/vhost-user.rst:1049
msgid "``VHOST_SET_VRING_KICK``"
msgstr ""

#: ../../../interop/vhost-user.rst:1053
msgid ""
"Set the event file descriptor for adding buffers to the vring. It is passed "
"in the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1056
msgid ""
"Bits (0-7) of the payload contain the vring index. Bit 8 is the invalid FD "
"flag. This flag is set when there is no file descriptor in the ancillary "
"data. This signals that polling should be used instead of waiting for the "
"kick. Note that if the protocol feature "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` has been negotiated this "
"message isn't necessary as the ring is also started on the "
"``VHOST_USER_VRING_KICK`` message, it may however still be used to set an "
"event file descriptor (which will be preferred over the message) or to "
"enable polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1067
msgid "13"
msgstr ""

#: ../../../interop/vhost-user.rst:1068
msgid "``VHOST_SET_VRING_CALL``"
msgstr ""

#: ../../../interop/vhost-user.rst:1072
msgid ""
"Set the event file descriptor to signal when buffers are used. It is passed "
"in the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1075
msgid ""
"Bits (0-7) of the payload contain the vring index. Bit 8 is the invalid FD "
"flag. This flag is set when there is no file descriptor in the ancillary "
"data. This signals that polling will be used instead of waiting for the "
"call. Note that if the protocol features "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` and "
"``VHOST_USER_PROTOCOL_F_BACKEND_REQ`` have been negotiated this message "
"isn't necessary as the ``VHOST_USER_BACKEND_VRING_CALL`` message can be "
"used, it may however still be used to set an event file descriptor or to "
"enable polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1086
msgid "14"
msgstr ""

#: ../../../interop/vhost-user.rst:1087
msgid "``VHOST_SET_VRING_ERR``"
msgstr ""

#: ../../../interop/vhost-user.rst:1091
msgid ""
"Set the event file descriptor to signal when error occurs. It is passed in "
"the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1094
msgid ""
"Bits (0-7) of the payload contain the vring index. Bit 8 is the invalid FD "
"flag. This flag is set when there is no file descriptor in the ancillary "
"data. Note that if the protocol features "
"``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` and "
"``VHOST_USER_PROTOCOL_F_BACKEND_REQ`` have been negotiated this message "
"isn't necessary as the ``VHOST_USER_BACKEND_VRING_ERR`` message can be used, "
"it may however still be used to set an event file descriptor (which will be "
"preferred over the message)."
msgstr ""

#: ../../../interop/vhost-user.rst:1103
msgid "``VHOST_USER_GET_QUEUE_NUM``"
msgstr ""

#: ../../../interop/vhost-user.rst:1104
msgid "17"
msgstr ""

#: ../../../interop/vhost-user.rst:1109
msgid "Query how many queues the back-end supports."
msgstr ""

#: ../../../interop/vhost-user.rst:1111
msgid ""
"This request should be sent only when ``VHOST_USER_PROTOCOL_F_MQ`` is set in "
"queried protocol features by ``VHOST_USER_GET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:1115
msgid "``VHOST_USER_SET_VRING_ENABLE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1116
msgid "18"
msgstr ""

#: ../../../interop/vhost-user.rst:1121
msgid "Signal the back-end to enable or disable corresponding vring."
msgstr ""

#: ../../../interop/vhost-user.rst:1123
msgid ""
"This request should be sent only when ``VHOST_USER_F_PROTOCOL_FEATURES`` has "
"been negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1126
msgid "``VHOST_USER_SEND_RARP``"
msgstr ""

#: ../../../interop/vhost-user.rst:1127
msgid "19"
msgstr ""

#: ../../../interop/vhost-user.rst:1132
msgid ""
"Ask vhost user back-end to broadcast a fake RARP to notify the migration is "
"terminated for guest that does not support GUEST_ANNOUNCE."
msgstr ""

#: ../../../interop/vhost-user.rst:1135
msgid ""
"Only legal if feature bit ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES`` and protocol feature bit "
"``VHOST_USER_PROTOCOL_F_RARP`` is present in "
"``VHOST_USER_GET_PROTOCOL_FEATURES``.  The first 6 bytes of the payload "
"contain the mac address of the guest to allow the vhost user back-end to "
"construct and broadcast the fake RARP."
msgstr ""

#: ../../../interop/vhost-user.rst:1142
msgid "``VHOST_USER_NET_SET_MTU``"
msgstr ""

#: ../../../interop/vhost-user.rst:1143
msgid "20"
msgstr ""

#: ../../../interop/vhost-user.rst:1148
msgid "Set host MTU value exposed to the guest."
msgstr ""

#: ../../../interop/vhost-user.rst:1150
msgid ""
"This request should be sent only when ``VIRTIO_NET_F_MTU`` feature has been "
"successfully negotiated, ``VHOST_USER_F_PROTOCOL_FEATURES`` is present in "
"``VHOST_USER_GET_FEATURES`` and protocol feature bit "
"``VHOST_USER_PROTOCOL_F_NET_MTU`` is present in "
"``VHOST_USER_GET_PROTOCOL_FEATURES``."
msgstr ""

#: ../../../interop/vhost-user.rst:1156
msgid ""
"If ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, the back-end must "
"respond with zero in case the specified MTU is valid, or non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1161
msgid "21"
msgstr ""

#: ../../../interop/vhost-user.rst:1166
msgid ""
"Set the socket file descriptor for back-end initiated requests. It is passed "
"in the ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1169
msgid ""
"This request should be sent only when ``VHOST_USER_F_PROTOCOL_FEATURES`` has "
"been negotiated, and protocol feature bit "
"``VHOST_USER_PROTOCOL_F_BACKEND_REQ`` bit is present in "
"``VHOST_USER_GET_PROTOCOL_FEATURES``.  If "
"``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, the back-end must respond "
"with zero for success, non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1176
msgid "``VHOST_USER_IOTLB_MSG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1177
msgid "22"
msgstr ""

#: ../../../interop/vhost-user.rst:1178 ../../../interop/vhost-user.rst:1452
msgid "N/A (equivalent to ``VHOST_IOTLB_MSG`` message type)"
msgstr ""

#: ../../../interop/vhost-user.rst:1179 ../../../interop/vhost-user.rst:1453
msgid "``struct vhost_iotlb_msg``"
msgstr ""

#: ../../../interop/vhost-user.rst:1182
msgid "Send IOTLB messages with ``struct vhost_iotlb_msg`` as payload."
msgstr ""

#: ../../../interop/vhost-user.rst:1184
msgid ""
"The front-end sends such requests to update and invalidate entries in the "
"device IOTLB. The back-end has to acknowledge the request with sending zero "
"as ``u64`` payload for success, non-zero otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1188
msgid ""
"This request should be send only when ``VIRTIO_F_IOMMU_PLATFORM`` feature "
"has been successfully negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1191
msgid "``VHOST_USER_SET_VRING_ENDIAN``"
msgstr ""

#: ../../../interop/vhost-user.rst:1192
msgid "23"
msgstr ""

#: ../../../interop/vhost-user.rst:1193
msgid "``VHOST_SET_VRING_ENDIAN``"
msgstr ""

#: ../../../interop/vhost-user.rst:1197
msgid ""
"Set the endianness of a VQ for legacy devices. Little-endian is indicated "
"with state.num set to 0 and big-endian is indicated with state.num set to 1. "
"Other values are invalid."
msgstr ""

#: ../../../interop/vhost-user.rst:1201
msgid ""
"This request should be sent only when ``VHOST_USER_PROTOCOL_F_CROSS_ENDIAN`` "
"has been negotiated. Backends that negotiated this feature should handle "
"both endiannesses and expect this message once (per VQ) during device "
"configuration (ie. before the front-end starts the VQ)."
msgstr ""

#: ../../../interop/vhost-user.rst:1207
msgid "``VHOST_USER_GET_CONFIG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1208
msgid "24"
msgstr ""

#: ../../../interop/vhost-user.rst:1210 ../../../interop/vhost-user.rst:1211
#: ../../../interop/vhost-user.rst:1224
msgid "virtio device config space"
msgstr ""

#: ../../../interop/vhost-user.rst:1213
msgid ""
"When ``VHOST_USER_PROTOCOL_F_CONFIG`` is negotiated, this message is "
"submitted by the vhost-user front-end to fetch the contents of the virtio "
"device configuration space, vhost-user back-end's payload size MUST match "
"the front-end's request, vhost-user back-end uses zero length of payload to "
"indicate an error to the vhost-user front-end. The vhost-user front-end may "
"cache the contents to avoid repeated ``VHOST_USER_GET_CONFIG`` calls."
msgstr ""

#: ../../../interop/vhost-user.rst:1221
msgid "``VHOST_USER_SET_CONFIG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1222
msgid "25"
msgstr ""

#: ../../../interop/vhost-user.rst:1227
msgid ""
"When ``VHOST_USER_PROTOCOL_F_CONFIG`` is negotiated, this message is "
"submitted by the vhost-user front-end when the Guest changes the virtio "
"device configuration space and also can be used for live migration on the "
"destination host. The vhost-user back-end must check the flags field, and "
"back-ends MUST NOT accept SET_CONFIG for read-only configuration space "
"fields unless the live migration bit is set."
msgstr ""

#: ../../../interop/vhost-user.rst:1234
msgid "``VHOST_USER_CREATE_CRYPTO_SESSION``"
msgstr ""

#: ../../../interop/vhost-user.rst:1235
msgid "26"
msgstr ""

#: ../../../interop/vhost-user.rst:1237 ../../../interop/vhost-user.rst:1238
msgid "crypto session description"
msgstr ""

#: ../../../interop/vhost-user.rst:1240
msgid ""
"Create a session for crypto operation. The back-end must return the session "
"id, 0 or positive for success, negative for failure. This request should be "
"sent only when ``VHOST_USER_PROTOCOL_F_CRYPTO_SESSION`` feature has been "
"successfully negotiated.  It's a required feature for crypto devices."
msgstr ""

#: ../../../interop/vhost-user.rst:1247
msgid "``VHOST_USER_CLOSE_CRYPTO_SESSION``"
msgstr ""

#: ../../../interop/vhost-user.rst:1248
msgid "27"
msgstr ""

#: ../../../interop/vhost-user.rst:1253
msgid ""
"Close a session for crypto operation which was previously created by "
"``VHOST_USER_CREATE_CRYPTO_SESSION``."
msgstr ""

#: ../../../interop/vhost-user.rst:1256
msgid ""
"This request should be sent only when "
"``VHOST_USER_PROTOCOL_F_CRYPTO_SESSION`` feature has been successfully "
"negotiated.  It's a required feature for crypto devices."
msgstr ""

#: ../../../interop/vhost-user.rst:1261
msgid "``VHOST_USER_POSTCOPY_ADVISE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1262
msgid "28"
msgstr ""

#: ../../../interop/vhost-user.rst:1264
msgid "userfault fd"
msgstr ""

#: ../../../interop/vhost-user.rst:1266
msgid ""
"When ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` is supported, the front-end advises "
"back-end that a migration with postcopy enabled is underway, the back-end "
"must open a userfaultfd for later use.  Note that at this stage the "
"migration is still in precopy mode."
msgstr ""

#: ../../../interop/vhost-user.rst:1271
msgid "``VHOST_USER_POSTCOPY_LISTEN``"
msgstr ""

#: ../../../interop/vhost-user.rst:1272
msgid "29"
msgstr ""

#: ../../../interop/vhost-user.rst:1276
msgid ""
"The front-end advises back-end that a transition to postcopy mode has "
"happened.  The back-end must ensure that shared memory is registered with "
"userfaultfd to cause faulting of non-present pages."
msgstr ""

#: ../../../interop/vhost-user.rst:1280
msgid ""
"This is always sent sometime after a ``VHOST_USER_POSTCOPY_ADVISE``, and "
"thus only when ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` is supported."
msgstr ""

#: ../../../interop/vhost-user.rst:1283
msgid "``VHOST_USER_POSTCOPY_END``"
msgstr ""

#: ../../../interop/vhost-user.rst:1284
msgid "30"
msgstr ""

#: ../../../interop/vhost-user.rst:1288
msgid ""
"The front-end advises that postcopy migration has now completed.  The back-"
"end must disable the userfaultfd. The reply is an acknowledgement only."
msgstr ""

#: ../../../interop/vhost-user.rst:1292
msgid ""
"When ``VHOST_USER_PROTOCOL_F_PAGEFAULT`` is supported, this message is sent "
"at the end of the migration, after ``VHOST_USER_POSTCOPY_LISTEN`` was "
"previously sent."
msgstr ""

#: ../../../interop/vhost-user.rst:1296
msgid "The value returned is an error indication; 0 is success."
msgstr ""

#: ../../../interop/vhost-user.rst:1298
msgid "``VHOST_USER_GET_INFLIGHT_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:1299
msgid "31"
msgstr ""

#: ../../../interop/vhost-user.rst:1301 ../../../interop/vhost-user.rst:1313
msgid "inflight description"
msgstr ""

#: ../../../interop/vhost-user.rst:1304
msgid ""
"When ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD`` protocol feature has been "
"successfully negotiated, this message is submitted by the front-end to get a "
"shared buffer from back-end. The shared buffer will be used to track "
"inflight I/O by back-end. QEMU should retrieve a new one when vm reset."
msgstr ""

#: ../../../interop/vhost-user.rst:1310
msgid "``VHOST_USER_SET_INFLIGHT_FD``"
msgstr ""

#: ../../../interop/vhost-user.rst:1311
msgid "32"
msgstr ""

#: ../../../interop/vhost-user.rst:1316
msgid ""
"When ``VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD`` protocol feature has been "
"successfully negotiated, this message is submitted by the front-end to send "
"the shared inflight buffer back to the back-end so that the back-end could "
"get inflight I/O after a crash or restart."
msgstr ""

#: ../../../interop/vhost-user.rst:1321
msgid "``VHOST_USER_GPU_SET_SOCKET``"
msgstr ""

#: ../../../interop/vhost-user.rst:1322
msgid "33"
msgstr ""

#: ../../../interop/vhost-user.rst:1327
msgid ""
"Sets the GPU protocol socket file descriptor, which is passed as ancillary "
"data. The GPU protocol is used to inform the front-end of rendering state "
"and updates. See vhost-user-gpu.rst for details."
msgstr ""

#: ../../../interop/vhost-user.rst:1331
msgid "``VHOST_USER_RESET_DEVICE``"
msgstr ""

#: ../../../interop/vhost-user.rst:1332
msgid "34"
msgstr ""

#: ../../../interop/vhost-user.rst:1337
msgid ""
"Ask the vhost user back-end to disable all rings and reset all internal "
"device state to the initial state, ready to be reinitialized. The back-end "
"retains ownership of the device throughout the reset operation."
msgstr ""

#: ../../../interop/vhost-user.rst:1342
msgid ""
"Only valid if the ``VHOST_USER_PROTOCOL_F_RESET_DEVICE`` protocol feature is "
"set by the back-end."
msgstr ""

#: ../../../interop/vhost-user.rst:1345
msgid "``VHOST_USER_VRING_KICK``"
msgstr ""

#: ../../../interop/vhost-user.rst:1346
msgid "35"
msgstr ""

#: ../../../interop/vhost-user.rst:1351
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature has "
"been successfully negotiated, this message may be submitted by the front-end "
"to indicate that a buffer was added to the vring instead of signalling it "
"using the vring's kick file descriptor or having the back-end rely on "
"polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1357 ../../../interop/vhost-user.rst:1515
#: ../../../interop/vhost-user.rst:1529
msgid "The state.num field is currently reserved and must be set to 0."
msgstr ""

#: ../../../interop/vhost-user.rst:1359
msgid "``VHOST_USER_GET_MAX_MEM_SLOTS``"
msgstr ""

#: ../../../interop/vhost-user.rst:1360
msgid "36"
msgstr ""

#: ../../../interop/vhost-user.rst:1365
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has "
"been successfully negotiated, this message is submitted by the front-end to "
"the back-end. The back-end should return the message with a u64 payload "
"containing the maximum number of memory slots for QEMU to expose to the "
"guest. The value returned by the back-end will be capped at the maximum "
"number of ram slots which can be supported by the target platform."
msgstr ""

#: ../../../interop/vhost-user.rst:1374
msgid "37"
msgstr ""

#: ../../../interop/vhost-user.rst:1377 ../../../interop/vhost-user.rst:1401
msgid "single memory region description"
msgstr ""

#: ../../../interop/vhost-user.rst:1379
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has "
"been successfully negotiated, this message is submitted by the front-end to "
"the back-end. The message payload contains a memory region descriptor "
"struct, describing a region of guest memory which the back-end device must "
"map in. When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol "
"feature has been successfully negotiated, along with the "
"``VHOST_USER_REM_MEM_REG`` message, this message is used to set and update "
"the memory tables of the back-end device."
msgstr ""

#: ../../../interop/vhost-user.rst:1389
msgid ""
"Exactly one file descriptor from which the memory is mapped is passed in the "
"ancillary data."
msgstr ""

#: ../../../interop/vhost-user.rst:1392
msgid ""
"In postcopy mode (see ``VHOST_USER_POSTCOPY_LISTEN``), the back-end replies "
"with the bases of the memory mapped region to the front-end. For further "
"details on postcopy, see ``VHOST_USER_SET_MEM_TABLE``. They apply to "
"``VHOST_USER_ADD_MEM_REG`` accordingly."
msgstr ""

#: ../../../interop/vhost-user.rst:1397
msgid "``VHOST_USER_REM_MEM_REG``"
msgstr ""

#: ../../../interop/vhost-user.rst:1398
msgid "38"
msgstr ""

#: ../../../interop/vhost-user.rst:1403
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol feature has "
"been successfully negotiated, this message is submitted by the front-end to "
"the back-end. The message payload contains a memory region descriptor "
"struct, describing a region of guest memory which the back-end device must "
"unmap. When the ``VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS`` protocol "
"feature has been successfully negotiated, along with the "
"``VHOST_USER_ADD_MEM_REG`` message, this message is used to set and update "
"the memory tables of the back-end device."
msgstr ""

#: ../../../interop/vhost-user.rst:1413
msgid ""
"The memory region to be removed is identified by its guest address, user "
"address and size. The mmap offset is ignored."
msgstr ""

#: ../../../interop/vhost-user.rst:1416
msgid ""
"No file descriptors SHOULD be passed in the ancillary data. For "
"compatibility with existing incorrect implementations, the back-end MAY "
"accept messages with one file descriptor. If a file descriptor is passed, "
"the back-end MUST close it without using it otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1421
msgid "``VHOST_USER_SET_STATUS``"
msgstr ""

#: ../../../interop/vhost-user.rst:1422
msgid "39"
msgstr ""

#: ../../../interop/vhost-user.rst:1423
msgid "VHOST_VDPA_SET_STATUS"
msgstr ""

#: ../../../interop/vhost-user.rst:1427
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_STATUS`` protocol feature has been "
"successfully negotiated, this message is submitted by the front-end to "
"notify the back-end with updated device status as defined in the Virtio "
"specification."
msgstr ""

#: ../../../interop/vhost-user.rst:1432
msgid "``VHOST_USER_GET_STATUS``"
msgstr ""

#: ../../../interop/vhost-user.rst:1433
msgid "40"
msgstr ""

#: ../../../interop/vhost-user.rst:1434
msgid "VHOST_VDPA_GET_STATUS"
msgstr ""

#: ../../../interop/vhost-user.rst:1438
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_STATUS`` protocol feature has been "
"successfully negotiated, this message is submitted by the front-end to query "
"the back-end for its device status as defined in the Virtio specification."
msgstr ""

#: ../../../interop/vhost-user.rst:1445
msgid "Back-end message types"
msgstr ""

#: ../../../interop/vhost-user.rst:1447
msgid ""
"For this type of message, the request is sent by the back-end and the reply "
"is sent by the front-end."
msgstr ""

#: ../../../interop/vhost-user.rst:1450
msgid ""
"``VHOST_USER_BACKEND_IOTLB_MSG`` (previous name "
"``VHOST_USER_SLAVE_IOTLB_MSG``)"
msgstr ""

#: ../../../interop/vhost-user.rst:1456
msgid ""
"Send IOTLB messages with ``struct vhost_iotlb_msg`` as payload. The back-end "
"sends such requests to notify of an IOTLB miss, or an IOTLB access failure. "
"If ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, and back-end set the "
"``VHOST_USER_NEED_REPLY`` flag, the front-end must respond with zero when "
"operation is successfully completed, or non-zero otherwise.  This request "
"should be send only when ``VIRTIO_F_IOMMU_PLATFORM`` feature has been "
"successfully negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1465
msgid ""
"``VHOST_USER_BACKEND_CONFIG_CHANGE_MSG`` (previous name "
"``VHOST_USER_SLAVE_CONFIG_CHANGE_MSG``)"
msgstr ""

#: ../../../interop/vhost-user.rst:1471
msgid ""
"When ``VHOST_USER_PROTOCOL_F_CONFIG`` is negotiated, vhost-user back-end "
"sends such messages to notify that the virtio device's configuration space "
"has changed, for those host devices which can support such feature, host "
"driver can send ``VHOST_USER_GET_CONFIG`` message to the back-end to get the "
"latest content. If ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` is negotiated, and "
"the back-end sets the ``VHOST_USER_NEED_REPLY`` flag, the front-end must "
"respond with zero when operation is successfully completed, or non-zero "
"otherwise."
msgstr ""

#: ../../../interop/vhost-user.rst:1480
msgid ""
"``VHOST_USER_BACKEND_VRING_HOST_NOTIFIER_MSG`` (previous name "
"``VHOST_USER_SLAVE_VRING_HOST_NOTIFIER_MSG``)"
msgstr ""

#: ../../../interop/vhost-user.rst:1483
msgid "vring area description"
msgstr ""

#: ../../../interop/vhost-user.rst:1486
msgid ""
"Sets host notifier for a specified queue. The queue index is contained in "
"the ``u64`` field of the vring area description. The host notifier is "
"described by the file descriptor (typically it's a VFIO device fd) which is "
"passed as ancillary data and the size (which is mmap size and should be the "
"same as host page size) and offset (which is mmap offset) carried in the "
"vring area description. QEMU can mmap the file descriptor based on the size "
"and offset to get a memory range. Registering a host notifier means mapping "
"this memory range to the VM as the specified queue's notify MMIO region. The "
"back-end sends this request to tell QEMU to de-register the existing "
"notifier if any and register the new notifier if the request is sent with a "
"file descriptor."
msgstr ""

#: ../../../interop/vhost-user.rst:1499
msgid ""
"This request should be sent only when "
"``VHOST_USER_PROTOCOL_F_HOST_NOTIFIER`` protocol feature has been "
"successfully negotiated."
msgstr ""

#: ../../../interop/vhost-user.rst:1503
msgid ""
"``VHOST_USER_BACKEND_VRING_CALL`` (previous name "
"``VHOST_USER_SLAVE_VRING_CALL``)"
msgstr ""

#: ../../../interop/vhost-user.rst:1509
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature has "
"been successfully negotiated, this message may be submitted by the back-end "
"to indicate that a buffer was used from the vring instead of signalling this "
"using the vring's call file descriptor or having the front-end relying on "
"polling."
msgstr ""

#: ../../../interop/vhost-user.rst:1517
msgid ""
"``VHOST_USER_BACKEND_VRING_ERR`` (previous name "
"``VHOST_USER_SLAVE_VRING_ERR``)"
msgstr ""

#: ../../../interop/vhost-user.rst:1523
msgid ""
"When the ``VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS`` protocol feature has "
"been successfully negotiated, this message may be submitted by the back-end "
"to indicate that an error occurred on the specific vring, instead of "
"signalling the error file descriptor set by the front-end via "
"``VHOST_USER_SET_VRING_ERR``."
msgstr ""

#: ../../../interop/vhost-user.rst:1534
msgid "VHOST_USER_PROTOCOL_F_REPLY_ACK"
msgstr ""

#: ../../../interop/vhost-user.rst:1536
msgid ""
"The original vhost-user specification only demands replies for certain "
"commands. This differs from the vhost protocol implementation where commands "
"are sent over an ``ioctl()`` call and block until the back-end has completed."
msgstr ""

#: ../../../interop/vhost-user.rst:1541
msgid ""
"With this protocol extension negotiated, the sender (QEMU) can set the "
"``need_reply`` [Bit 3] flag to any command. This indicates that the back-end "
"MUST respond with a Payload ``VhostUserMsg`` indicating success or failure. "
"The payload should be set to zero on success or non-zero on failure, unless "
"the message already has an explicit reply body."
msgstr ""

#: ../../../interop/vhost-user.rst:1547
msgid ""
"The reply payload gives QEMU a deterministic indication of the result of the "
"command. Today, QEMU is expected to terminate the main vhost-user loop upon "
"receiving such errors. In future, qemu could be taught to be more resilient "
"for selective requests."
msgstr ""

#: ../../../interop/vhost-user.rst:1552
msgid ""
"For the message types that already solicit a reply from the back-end, the "
"presence of ``VHOST_USER_PROTOCOL_F_REPLY_ACK`` or need_reply bit being set "
"brings no behavioural change. (See the Communication_ section for details.)"
msgstr ""

#: ../../../interop/vhost-user.rst:1560
msgid "Backend program conventions"
msgstr ""

#: ../../../interop/vhost-user.rst:1562
msgid ""
"vhost-user back-ends can provide various devices & services and may need to "
"be configured manually depending on the use case. However, it is a good idea "
"to follow the conventions listed here when possible. Users, QEMU or libvirt, "
"can then rely on some common behaviour to avoid heterogeneous configuration "
"and management of the back-end programs and facilitate interoperability."
msgstr ""

#: ../../../interop/vhost-user.rst:1569
msgid ""
"Each back-end installed on a host system should come with at least one JSON "
"file that conforms to the vhost-user.json schema. Each file informs the "
"management applications about the back-end type, and binary location. In "
"addition, it defines rules for management apps for picking the highest "
"priority back-end when multiple match the search criteria (see "
"``@VhostUserBackend`` documentation in the schema file)."
msgstr ""

#: ../../../interop/vhost-user.rst:1576
msgid ""
"If the back-end is not capable of enabling a requested feature on the host "
"(such as 3D acceleration with virgl), or the initialization failed, the back-"
"end should fail to start early and exit with a status != 0. It may also "
"print a message to stderr for further details."
msgstr ""

#: ../../../interop/vhost-user.rst:1581
msgid ""
"The back-end program must not daemonize itself, but it may be daemonized by "
"the management layer. It may also have a restricted access to the system."
msgstr ""

#: ../../../interop/vhost-user.rst:1585
msgid ""
"File descriptors 0, 1 and 2 will exist, and have regular stdin/stdout/stderr "
"usage (they may have been redirected to /dev/null by the management layer, "
"or to a log handler)."
msgstr ""

#: ../../../interop/vhost-user.rst:1589
msgid ""
"The back-end program must end (as quickly and cleanly as possible) when the "
"SIGTERM signal is received. Eventually, it may receive SIGKILL by the "
"management layer after a few seconds."
msgstr ""

#: ../../../interop/vhost-user.rst:1593
msgid ""
"The following command line options have an expected behaviour. They are "
"mandatory, unless explicitly said differently:"
msgstr ""

#: ../../../interop/vhost-user.rst:1598
msgid ""
"This option specify the location of the vhost-user Unix domain socket. It is "
"incompatible with --fd."
msgstr ""

#: ../../../interop/vhost-user.rst:1603
msgid ""
"When this argument is given, the back-end program is started with the vhost-"
"user socket as file descriptor FDNUM. It is incompatible with --socket-path."
msgstr ""

#: ../../../interop/vhost-user.rst:1609
msgid ""
"Output to stdout the back-end capabilities in JSON format, and then exit "
"successfully. Other options and arguments should be ignored, and the back-"
"end program should not perform its normal function.  The capabilities can be "
"reported dynamically depending on the host capabilities."
msgstr ""

#: ../../../interop/vhost-user.rst:1615
msgid ""
"The JSON output is described in the ``vhost-user.json`` schema, by "
"```@VHostUserBackendCapabilities``.  Example:"
msgstr ""

#: ../../../interop/vhost-user.rst:1618
msgid ""
"{\n"
"  \"type\": \"foo\",\n"
"  \"features\": [\n"
"    \"feature-a\",\n"
"    \"feature-b\"\n"
"  ]\n"
"}"
msgstr ""

#: ../../../interop/vhost-user.rst:1629
msgid "vhost-user-input"
msgstr ""

#: ../../../interop/vhost-user.rst:1631 ../../../interop/vhost-user.rst:1648
#: ../../../interop/vhost-user.rst:1665
msgid "Command line options:"
msgstr ""

#: ../../../interop/vhost-user.rst:1635
msgid "Specify the linux input device."
msgstr ""

#: ../../../interop/vhost-user.rst:1637 ../../../interop/vhost-user.rst:1643
#: ../../../interop/vhost-user.rst:1654 ../../../interop/vhost-user.rst:1660
#: ../../../interop/vhost-user.rst:1671 ../../../interop/vhost-user.rst:1677
msgid "(optional)"
msgstr ""

#: ../../../interop/vhost-user.rst:1641
msgid "Do no request exclusive access to the input device."
msgstr ""

#: ../../../interop/vhost-user.rst:1646
msgid "vhost-user-gpu"
msgstr ""

#: ../../../interop/vhost-user.rst:1652
msgid "Specify the GPU DRM render node."
msgstr ""

#: ../../../interop/vhost-user.rst:1658
msgid "Enable virgl rendering support."
msgstr ""

#: ../../../interop/vhost-user.rst:1663
msgid "vhost-user-blk"
msgstr ""

#: ../../../interop/vhost-user.rst:1669
msgid "Specify block device or file path."
msgstr ""

#: ../../../interop/vhost-user.rst:1675
msgid "Enable read-only."
msgstr ""
