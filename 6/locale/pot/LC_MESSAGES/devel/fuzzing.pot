# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/fuzzing.rst:3
msgid "Fuzzing"
msgstr ""

#: ../../../devel/fuzzing.rst:5
msgid ""
"This document describes the virtual-device fuzzing infrastructure in QEMU "
"and how to use it to implement additional fuzzers."
msgstr ""

#: ../../../devel/fuzzing.rst:9
msgid "Basics"
msgstr ""

#: ../../../devel/fuzzing.rst:11
msgid ""
"Fuzzing operates by passing inputs to an entry point/target function. The "
"fuzzer tracks the code coverage triggered by the input. Based on these "
"findings, the fuzzer mutates the input and repeats the fuzzing."
msgstr ""

#: ../../../devel/fuzzing.rst:15
msgid ""
"To fuzz QEMU, we rely on libfuzzer. Unlike other fuzzers such as AFL, "
"libfuzzer is an *in-process* fuzzer. For the developer, this means that it "
"is their responsibility to ensure that state is reset between fuzzing-runs."
msgstr ""

#: ../../../devel/fuzzing.rst:20
msgid "Building the fuzzers"
msgstr ""

#: ../../../devel/fuzzing.rst:22
msgid ""
"*NOTE*: If possible, build a 32-bit binary. When forking, the 32-bit fuzzer "
"is much faster, since the page-map has a smaller size. This is due to the "
"fact that AddressSanitizer maps ~20TB of memory, as part of its detection. "
"This results in a large page-map, and a much slower ``fork()``."
msgstr ""

#: ../../../devel/fuzzing.rst:27
msgid ""
"To build the fuzzers, install a recent version of clang: Configure with "
"(substitute the clang binaries with the version you installed). Here, enable-"
"sanitizers, is optional but it allows us to reliably detect bugs such as out-"
"of-bounds accesses, use-after-frees, double-frees etc.::"
msgstr ""

#: ../../../devel/fuzzing.rst:32
msgid ""
"CC=clang-8 CXX=clang++-8 /path/to/configure --enable-fuzzing \\\n"
"                                            --enable-sanitizers"
msgstr ""

#: ../../../devel/fuzzing.rst:35
msgid "Fuzz targets are built similarly to system targets::"
msgstr ""

#: ../../../devel/fuzzing.rst:37
msgid "make qemu-fuzz-i386"
msgstr ""

#: ../../../devel/fuzzing.rst:39
msgid "This builds ``./qemu-fuzz-i386``"
msgstr ""

#: ../../../devel/fuzzing.rst:41
msgid ""
"The first option to this command is: ``--fuzz-target=FUZZ_NAME`` To list all "
"of the available fuzzers run ``qemu-fuzz-i386`` with no arguments."
msgstr ""

#: ../../../devel/fuzzing.rst:44
msgid "For example::"
msgstr ""

#: ../../../devel/fuzzing.rst:46
msgid "./qemu-fuzz-i386 --fuzz-target=virtio-scsi-fuzz"
msgstr ""

#: ../../../devel/fuzzing.rst:48
msgid ""
"Internally, libfuzzer parses all arguments that do not begin with ``\"--"
"\"``. Information about these is available by passing ``-help=1``"
msgstr ""

#: ../../../devel/fuzzing.rst:51
msgid ""
"Now the only thing left to do is wait for the fuzzer to trigger potential "
"crashes."
msgstr ""

#: ../../../devel/fuzzing.rst:55
msgid "Useful libFuzzer flags"
msgstr ""

#: ../../../devel/fuzzing.rst:57
msgid ""
"As mentioned above, libFuzzer accepts some arguments. Passing ``-help=1`` "
"will list the available arguments. In particular, these arguments might be "
"helpful:"
msgstr ""

#: ../../../devel/fuzzing.rst:60
msgid ""
"``CORPUS_DIR/`` : Specify a directory as the last argument to libFuzzer. "
"libFuzzer stores each \"interesting\" input in this corpus directory. The "
"next time you run libFuzzer, it will read all of the inputs from the corpus, "
"and continue fuzzing from there. You can also specify multiple directories. "
"libFuzzer loads existing inputs from all specified directories, but will "
"only write new ones to the first one specified."
msgstr ""

#: ../../../devel/fuzzing.rst:67
msgid ""
"``-max_len=4096`` : specify the maximum byte-length of the inputs libFuzzer "
"will generate."
msgstr ""

#: ../../../devel/fuzzing.rst:70
msgid ""
"``-close_fd_mask={1,2,3}`` : close, stderr, or both. Useful for targets that "
"trigger many debug/error messages, or create output on the serial console."
msgstr ""

#: ../../../devel/fuzzing.rst:73
msgid ""
"``-jobs=4 -workers=4`` : These arguments configure libFuzzer to run 4 "
"fuzzers in parallel (4 fuzzing jobs in 4 worker processes). Alternatively, "
"with only ``-jobs=N``, libFuzzer automatically spawns a number of workers "
"less than or equal to half the available CPU cores. Replace 4 with a number "
"appropriate for your machine. Make sure to specify a ``CORPUS_DIR``, which "
"will allow the parallel fuzzers to share information about the interesting "
"inputs they find."
msgstr ""

#: ../../../devel/fuzzing.rst:80
msgid ""
"``-use_value_profile=1`` : For each comparison operation, libFuzzer computes "
"``(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)`` and places this in the "
"coverage table. Useful for targets with \"magic\" constants. If Arg1 came "
"from the fuzzer's input and Arg2 is a magic constant, then each time the "
"Hamming distance between Arg1 and Arg2 decreases, libFuzzer adds the input "
"to the corpus."
msgstr ""

#: ../../../devel/fuzzing.rst:87
msgid ""
"``-shrink=1`` : Tries to make elements of the corpus \"smaller\". Might lead "
"to better coverage performance, depending on the target."
msgstr ""

#: ../../../devel/fuzzing.rst:90
msgid ""
"Note that libFuzzer's exact behavior will depend on the version of clang and "
"libFuzzer used to build the device fuzzers."
msgstr ""

#: ../../../devel/fuzzing.rst:94
msgid "Generating Coverage Reports"
msgstr ""

#: ../../../devel/fuzzing.rst:96
msgid ""
"Code coverage is a crucial metric for evaluating a fuzzer's performance. "
"libFuzzer's output provides a \"cov: \" column that provides a total number "
"of unique blocks/edges covered. To examine coverage on a line-by-line basis "
"we can use Clang coverage:"
msgstr ""

#: ../../../devel/fuzzing.rst:101
msgid ""
"Configure libFuzzer to store a corpus of all interesting inputs (see "
"CORPUS_DIR above)"
msgstr ""

#: ../../../devel/fuzzing.rst:103
msgid "``./configure`` the QEMU build with ::"
msgstr ""

#: ../../../devel/fuzzing.rst:105
msgid ""
"--enable-fuzzing \\\n"
"--extra-cflags=\"-fprofile-instr-generate -fcoverage-mapping\""
msgstr ""

#: ../../../devel/fuzzing.rst:108
msgid ""
"Re-run the fuzzer. Specify $CORPUS_DIR/* as an argument, telling libfuzzer "
"to execute all of the inputs in $CORPUS_DIR and exit. Once the process "
"exits, you should find a file, \"default.profraw\" in the working directory."
msgstr ""

#: ../../../devel/fuzzing.rst:111
msgid "Execute these commands to generate a detailed HTML coverage-report::"
msgstr ""

#: ../../../devel/fuzzing.rst:113
msgid ""
"llvm-profdata merge -output=default.profdata default.profraw\n"
"llvm-cov show ./path/to/qemu-fuzz-i386 -instr-profile=default.profdata \\\n"
"--format html -output-dir=/path/to/output/report"
msgstr ""

#: ../../../devel/fuzzing.rst:118
msgid "Adding a new fuzzer"
msgstr ""

#: ../../../devel/fuzzing.rst:120
msgid ""
"Coverage over virtual devices can be improved by adding additional fuzzers. "
"Fuzzers are kept in ``tests/qtest/fuzz/`` and should be added to ``tests/"
"qtest/fuzz/meson.build``"
msgstr ""

#: ../../../devel/fuzzing.rst:124
msgid ""
"Fuzzers can rely on both qtest and libqos to communicate with virtual "
"devices."
msgstr ""

#: ../../../devel/fuzzing.rst:126
msgid ""
"Create a new source file. For example ``tests/qtest/fuzz/foo-device-fuzz.c``."
msgstr ""

#: ../../../devel/fuzzing.rst:128
msgid ""
"Write the fuzzing code using the libqtest/libqos API. See existing fuzzers "
"for reference."
msgstr ""

#: ../../../devel/fuzzing.rst:131
msgid "Add the fuzzer to ``tests/qtest/fuzz/meson.build``."
msgstr ""

#: ../../../devel/fuzzing.rst:133
msgid ""
"Fuzzers can be more-or-less thought of as special qtest programs which can "
"modify the qtest commands and/or qtest command arguments based on inputs "
"provided by libfuzzer. Libfuzzer passes a byte array and length. Commonly "
"the fuzzer loops over the byte-array interpreting it as a list of qtest "
"commands, addresses, or values."
msgstr ""

#: ../../../devel/fuzzing.rst:140
msgid "The Generic Fuzzer"
msgstr ""

#: ../../../devel/fuzzing.rst:142
msgid ""
"Writing a fuzz target can be a lot of effort (especially if a device driver "
"has not be built-out within libqos). Many devices can be fuzzed to some "
"degree, without any device-specific code, using the generic-fuzz target."
msgstr ""

#: ../../../devel/fuzzing.rst:146
msgid ""
"The generic-fuzz target is capable of fuzzing devices over their PIO, MMIO, "
"and DMA input-spaces. To apply the generic-fuzz to a device, we need to "
"define two env-variables, at minimum:"
msgstr ""

#: ../../../devel/fuzzing.rst:150
msgid ""
"``QEMU_FUZZ_ARGS=`` is the set of QEMU arguments used to configure a "
"machine, with the device attached. For example, if we want to fuzz the "
"virtio-net device attached to a pc-i440fx machine, we can specify::"
msgstr ""

#: ../../../devel/fuzzing.rst:154
msgid ""
"QEMU_FUZZ_ARGS=\"-M pc -nodefaults -netdev user,id=user0 \\\n"
"-device virtio-net,netdev=user0\""
msgstr ""

#: ../../../devel/fuzzing.rst:157
msgid ""
"``QEMU_FUZZ_OBJECTS=`` is a set of space-delimited strings used to identify "
"the MemoryRegions that will be fuzzed. These strings are compared against "
"MemoryRegion names and MemoryRegion owner names, to decide whether each "
"MemoryRegion should be fuzzed. These strings support globbing. For the "
"virtio-net example, we could use one of ::"
msgstr ""

#: ../../../devel/fuzzing.rst:163
msgid ""
"QEMU_FUZZ_OBJECTS='virtio-net'\n"
"QEMU_FUZZ_OBJECTS='virtio*'\n"
"QEMU_FUZZ_OBJECTS='virtio* pcspk' # Fuzz the virtio devices and the speaker\n"
"QEMU_FUZZ_OBJECTS='*' # Fuzz the whole machine``"
msgstr ""

#: ../../../devel/fuzzing.rst:168
msgid ""
"The ``\"info mtree\"`` and ``\"info qom-tree\"`` monitor commands can be "
"especially useful for identifying the ``MemoryRegion`` and ``Object`` names "
"used for matching."
msgstr ""

#: ../../../devel/fuzzing.rst:172
msgid ""
"As a generic rule-of-thumb, the more ``MemoryRegions``/Devices we match, the "
"greater the input-space, and the smaller the probability of finding crashing "
"inputs for individual devices. As such, it is usually a good idea to limit "
"the fuzzer to only a few ``MemoryRegions``."
msgstr ""

#: ../../../devel/fuzzing.rst:177
msgid ""
"To ensure that these env variables have been configured correctly, we can "
"use::"
msgstr ""

#: ../../../devel/fuzzing.rst:179
msgid "./qemu-fuzz-i386 --fuzz-target=generic-fuzz -runs=0"
msgstr ""

#: ../../../devel/fuzzing.rst:181
msgid "The output should contain a complete list of matched MemoryRegions."
msgstr ""

#: ../../../devel/fuzzing.rst:184
msgid "OSS-Fuzz"
msgstr ""

#: ../../../devel/fuzzing.rst:185
msgid ""
"QEMU is continuously fuzzed on `OSS-Fuzz <https://github.com/google/oss-"
"fuzz>`_.  By default, the OSS-Fuzz build will try to fuzz every fuzz-target. "
"Since the generic-fuzz target requires additional information provided in "
"environment variables, we pre-define some generic-fuzz configs in ``tests/"
"qtest/fuzz/generic_fuzz_configs.h``. Each config must specify:"
msgstr ""

#: ../../../devel/fuzzing.rst:192
msgid "``.name``: To identify the fuzzer config"
msgstr ""

#: ../../../devel/fuzzing.rst:194
msgid ""
"``.args`` OR ``.argfunc``: A string or pointer to a function returning a "
"string.  These strings are used to specify the ``QEMU_FUZZ_ARGS`` "
"environment variable.  ``argfunc`` is useful when the config relies on e.g. "
"a dynamically created temp directory, or a free tcp/udp port."
msgstr ""

#: ../../../devel/fuzzing.rst:199
msgid ""
"``.objects``: A string that specifies the ``QEMU_FUZZ_OBJECTS`` environment "
"variable."
msgstr ""

#: ../../../devel/fuzzing.rst:202
msgid ""
"To fuzz additional devices/device configuration on OSS-Fuzz, send patches "
"for either a new device-specific fuzzer or a new generic-fuzz config."
msgstr ""

#: ../../../devel/fuzzing.rst:205
msgid "Build details:"
msgstr ""

#: ../../../devel/fuzzing.rst:207
msgid ""
"The Dockerfile that sets up the environment for building QEMU's fuzzers on "
"OSS-Fuzz can be fund in the OSS-Fuzz repository __(https://github.com/google/"
"oss-fuzz/blob/master/projects/qemu/Dockerfile)"
msgstr ""

#: ../../../devel/fuzzing.rst:211
msgid ""
"The script responsible for building the fuzzers can be found in the QEMU "
"source tree at ``scripts/oss-fuzz/build.sh``"
msgstr ""

#: ../../../devel/fuzzing.rst:215
msgid "Building Crash Reproducers"
msgstr ""

#: ../../../devel/fuzzing.rst:216
msgid ""
"When we find a crash, we should try to create an independent reproducer, "
"that can be used on a non-fuzzer build of QEMU. This filters out any "
"potential false-positives, and improves the debugging experience for "
"developers. Here are the steps for building a reproducer for a crash found "
"by the generic-fuzz target."
msgstr ""

#: ../../../devel/fuzzing.rst:222
msgid "Ensure the crash reproduces::"
msgstr ""

#: ../../../devel/fuzzing.rst:224
msgid "qemu-fuzz-i386 --fuzz-target... ./crash-..."
msgstr ""

#: ../../../devel/fuzzing.rst:226
msgid "Gather the QTest output for the crash::"
msgstr ""

#: ../../../devel/fuzzing.rst:228
msgid ""
"QEMU_FUZZ_TIMEOUT=0 QTEST_LOG=1 FUZZ_SERIALIZE_QTEST=1 \\\n"
"qemu-fuzz-i386 --fuzz-target... ./crash-... &> /tmp/trace"
msgstr ""

#: ../../../devel/fuzzing.rst:231
msgid "Reorder and clean-up the resulting trace::"
msgstr ""

#: ../../../devel/fuzzing.rst:233
msgid ""
"scripts/oss-fuzz/reorder_fuzzer_qtest_trace.py /tmp/trace > /tmp/reproducer"
msgstr ""

#: ../../../devel/fuzzing.rst:235
msgid "Get the arguments needed to start qemu, and provide a path to qemu::"
msgstr ""

#: ../../../devel/fuzzing.rst:237
msgid ""
"less /tmp/trace # The args should be logged at the top of this file\n"
"export QEMU_ARGS=\"-machine ...\"\n"
"export QEMU_PATH=\"path/to/qemu-system\""
msgstr ""

#: ../../../devel/fuzzing.rst:241
msgid "Ensure the crash reproduces in qemu-system::"
msgstr ""

#: ../../../devel/fuzzing.rst:243
msgid "$QEMU_PATH $QEMU_ARGS -qtest stdio < /tmp/reproducer"
msgstr ""

#: ../../../devel/fuzzing.rst:245
msgid ""
"From the crash output, obtain some string that identifies the crash. This "
"can be a line in the stack-trace, for example::"
msgstr ""

#: ../../../devel/fuzzing.rst:248
msgid "export CRASH_TOKEN=\"hw/usb/hcd-xhci.c:1865\""
msgstr ""

#: ../../../devel/fuzzing.rst:250
msgid "Minimize the reproducer::"
msgstr ""

#: ../../../devel/fuzzing.rst:252
msgid ""
"scripts/oss-fuzz/minimize_qtest_trace.py -M1 -M2 \\\n"
"  /tmp/reproducer /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/fuzzing.rst:255
msgid "Confirm that the minimized reproducer still crashes::"
msgstr ""

#: ../../../devel/fuzzing.rst:257
msgid "$QEMU_PATH $QEMU_ARGS -qtest stdio < /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/fuzzing.rst:259
msgid "Create a one-liner reproducer that can be sent over email::"
msgstr ""

#: ../../../devel/fuzzing.rst:261
msgid "./scripts/oss-fuzz/output_reproducer.py -bash /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/fuzzing.rst:263
msgid "Output the C source code for a test case that will reproduce the bug::"
msgstr ""

#: ../../../devel/fuzzing.rst:265
msgid ""
"./scripts/oss-fuzz/output_reproducer.py -owner \"John Smith <john@smith."
"com>\"\\\n"
"  -name \"test_function_name\" /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/fuzzing.rst:268
msgid "Report the bug and send a patch with the C reproducer upstream"
msgstr ""

#: ../../../devel/fuzzing.rst:271
msgid "Implementation Details / Fuzzer Lifecycle"
msgstr ""

#: ../../../devel/fuzzing.rst:273
msgid ""
"The fuzzer has two entrypoints that libfuzzer calls. libfuzzer provides it's "
"own ``main()``, which performs some setup, and calls the entrypoints:"
msgstr ""

#: ../../../devel/fuzzing.rst:276
msgid ""
"``LLVMFuzzerInitialize``: called prior to fuzzing. Used to initialize all of "
"the necessary state"
msgstr ""

#: ../../../devel/fuzzing.rst:279
msgid ""
"``LLVMFuzzerTestOneInput``: called for each fuzzing run. Processes the input "
"and resets the state at the end of each run."
msgstr ""

#: ../../../devel/fuzzing.rst:282
msgid "In more detail:"
msgstr ""

#: ../../../devel/fuzzing.rst:284
msgid ""
"``LLVMFuzzerInitialize`` parses the arguments to the fuzzer (must start with "
"two dashes, so they are ignored by libfuzzer ``main()``). Currently, the "
"arguments select the fuzz target. Then, the qtest client is initialized. If "
"the target requires qos, qgraph is set up and the QOM/LIBQOS modules are "
"initialized. Then the QGraph is walked and the QEMU cmd_line is determined "
"and saved."
msgstr ""

#: ../../../devel/fuzzing.rst:290
msgid ""
"After this, the ``vl.c:qemu_main`` is called to set up the guest. There are "
"target-specific hooks that can be called before and after qemu_main, for "
"additional setup(e.g. PCI setup, or VM snapshotting)."
msgstr ""

#: ../../../devel/fuzzing.rst:294
msgid ""
"``LLVMFuzzerTestOneInput``: Uses qtest/qos functions to act based on the "
"fuzz input. It is also responsible for manually calling ``main_loop_wait`` "
"to ensure that bottom halves are executed and any cleanup required before "
"the next input."
msgstr ""

#: ../../../devel/fuzzing.rst:298
msgid ""
"Since the same process is reused for many fuzzing runs, QEMU state needs to "
"be reset at the end of each run. There are currently two implemented options "
"for resetting state:"
msgstr ""

#: ../../../devel/fuzzing.rst:302
msgid ""
"Reboot the guest between runs. - *Pros*: Straightforward and fast for simple "
"fuzz targets."
msgstr ""

#: ../../../devel/fuzzing.rst:305
msgid ""
"*Cons*: Depending on the device, does not reset all device state. If the "
"device requires some initialization prior to being ready for fuzzing (common "
"for QOS-based targets), this initialization needs to be done after each "
"reboot."
msgstr ""

#: ../../../devel/fuzzing.rst:310
msgid "*Example target*: ``i440fx-qtest-reboot-fuzz``"
msgstr ""

#: ../../../devel/fuzzing.rst:312
msgid "Run each test case in a separate forked process and copy the coverage"
msgstr ""

#: ../../../devel/fuzzing.rst:313
msgid ""
"information back to the parent. This is fairly similar to AFL's \"deferred\" "
"fork-server mode [3]"
msgstr ""

#: ../../../devel/fuzzing.rst:316
msgid ""
"*Pros*: Relatively fast. Devices only need to be initialized once. No need "
"to do slow reboots or vmloads."
msgstr ""

#: ../../../devel/fuzzing.rst:319
msgid "*Cons*: Not officially supported by libfuzzer. Does not work well for"
msgstr ""

#: ../../../devel/fuzzing.rst:320
msgid "devices that rely on dedicated threads."
msgstr ""

#: ../../../devel/fuzzing.rst:322
msgid "*Example target*: ``virtio-net-fork-fuzz``"
msgstr ""
