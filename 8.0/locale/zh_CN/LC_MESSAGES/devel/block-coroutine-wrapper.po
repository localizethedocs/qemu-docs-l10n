# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/block-coroutine-wrapper.rst:3
msgid "block-coroutine-wrapper"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:5
msgid ""
"A lot of functions in QEMU block layer (see ``block/*``) can only be called "
"in coroutine context. Such functions are normally marked by the coroutine_fn "
"specifier. Still, sometimes we need to call them from non-coroutine context; "
"for this we need to start a coroutine, run the needed function from it and "
"wait for the coroutine to finish in a BDRV_POLL_WHILE() loop. To run a "
"coroutine we need a function with one void* argument. So for each "
"coroutine_fn function which needs a non-coroutine interface, we should "
"define a structure to pack the parameters, define a separate function to "
"unpack the parameters and call the original function and finally define a "
"new interface function with same list of arguments as original one, which "
"will pack the parameters into a struct, create a coroutine, run it and wait "
"in BDRV_POLL_WHILE() loop. It's boring to create such wrappers by hand, so "
"we have a script to generate them."
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:21
msgid "Usage"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:23
msgid ""
"Assume we have defined the ``coroutine_fn`` function ``bdrv_co_foo(<some "
"args>)`` and need a non-coroutine interface for it, called ``bdrv_foo(<same "
"args>)``. In this case the script can help. To trigger the generation:"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:28
msgid ""
"You need ``bdrv_foo`` declaration somewhere (for example, in ``block/"
"coroutines.h``) with the ``co_wrapper`` mark, like this:"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:32
msgid "int co_wrapper bdrv_foo(<some args>);"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:36
msgid ""
"You need to feed this declaration to block-coroutine-wrapper script. For "
"this, add the .h (or .c) file with the declaration to the ``input: "
"files(...)`` list of ``block_gen_c`` target declaration in ``block/meson."
"build``"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:41
msgid ""
"You are done. During the build, coroutine wrappers will be generated in "
"``<BUILD_DIR>/block/block-gen.c``."
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:45
msgid "Links"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:47
msgid "The script location is ``scripts/block-coroutine-wrapper.py``."
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:49
msgid ""
"Generic place for private ``co_wrapper`` declarations is ``block/coroutines."
"h``, for public declarations: ``include/block/block.h``"
msgstr ""

#: ../../../devel/block-coroutine-wrapper.rst:53
msgid ""
"The core API of generated coroutine wrappers is placed in (not generated) "
"``block/block-gen.h``"
msgstr ""
