# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/vfio-migration.rst:3
msgid "VFIO device Migration"
msgstr ""

#: ../../../devel/vfio-migration.rst:5
msgid ""
"Migration of virtual machine involves saving the state for each device that "
"the guest is running on source host and restoring this saved state on the "
"destination host. This document details how saving and restoring of VFIO "
"devices is done in QEMU."
msgstr ""

#: ../../../devel/vfio-migration.rst:10
msgid ""
"Migration of VFIO devices currently consists of a single stop-and-copy "
"phase. During the stop-and-copy phase the guest is stopped and the entire "
"VFIO device data is transferred to the destination."
msgstr ""

#: ../../../devel/vfio-migration.rst:14
msgid ""
"The pre-copy phase of migration is currently not supported for VFIO devices. "
"Support for VFIO pre-copy will be added later on."
msgstr ""

#: ../../../devel/vfio-migration.rst:17
msgid ""
"Note that currently VFIO migration is supported only for a single device. "
"This is due to VFIO migration's lack of P2P support. However, P2P support is "
"planned to be added later on."
msgstr ""

#: ../../../devel/vfio-migration.rst:21
msgid ""
"A detailed description of the UAPI for VFIO device migration can be found in "
"the comment for the ``vfio_device_mig_state`` structure in the header file "
"linux-headers/linux/vfio.h."
msgstr ""

#: ../../../devel/vfio-migration.rst:25
msgid "VFIO implements the device hooks for the iterative approach as follows:"
msgstr ""

#: ../../../devel/vfio-migration.rst:27
msgid "A ``save_setup`` function that sets up migration on the source."
msgstr ""

#: ../../../devel/vfio-migration.rst:29
msgid ""
"A ``load_setup`` function that sets the VFIO device on the destination in "
"_RESUMING state."
msgstr ""

#: ../../../devel/vfio-migration.rst:32
msgid ""
"A ``state_pending_exact`` function that reads pending_bytes from the vendor "
"driver, which indicates the amount of data that the vendor driver has yet to "
"save for the VFIO device."
msgstr ""

#: ../../../devel/vfio-migration.rst:36
msgid ""
"A ``save_state`` function to save the device config space if it is present."
msgstr ""

#: ../../../devel/vfio-migration.rst:38
msgid ""
"A ``save_live_complete_precopy`` function that sets the VFIO device in "
"_STOP_COPY state and iteratively copies the data for the VFIO device until "
"the vendor driver indicates that no data remains."
msgstr ""

#: ../../../devel/vfio-migration.rst:42
msgid ""
"A ``load_state`` function that loads the config section and the data "
"sections that are generated by the save functions above."
msgstr ""

#: ../../../devel/vfio-migration.rst:45
msgid ""
"``cleanup`` functions for both save and load that perform any migration "
"related cleanup."
msgstr ""

#: ../../../devel/vfio-migration.rst:49
msgid ""
"The VFIO migration code uses a VM state change handler to change the VFIO "
"device state when the VM state changes from running to not-running, and vice "
"versa."
msgstr ""

#: ../../../devel/vfio-migration.rst:53
msgid ""
"Similarly, a migration state change handler is used to trigger a transition "
"of the VFIO device state when certain changes of the migration state occur. "
"For example, the VFIO device state is transitioned back to _RUNNING in case "
"a migration failed or was canceled."
msgstr ""

#: ../../../devel/vfio-migration.rst:59
msgid "System memory dirty pages tracking"
msgstr ""

#: ../../../devel/vfio-migration.rst:61
msgid ""
"A ``log_global_start`` and ``log_global_stop`` memory listener callback "
"informs the VFIO dirty tracking module to start and stop dirty page "
"tracking. A ``log_sync`` memory listener callback queries the dirty page "
"bitmap from the dirty tracking module and marks system memory pages which "
"were DMA-ed by the VFIO device as dirty. The dirty page bitmap is queried "
"per container."
msgstr ""

#: ../../../devel/vfio-migration.rst:67
msgid ""
"Currently there are two ways dirty page tracking can be done: (1) Device "
"dirty tracking: In this method the device is responsible to log and report "
"its DMAs. This method can be used only if the device is capable of tracking "
"its DMAs. Discovering device capability, starting and stopping dirty "
"tracking, and syncing the dirty bitmaps from the device are done using the "
"DMA logging uAPI. More info about the uAPI can be found in the comments of "
"the ``vfio_device_feature_dma_logging_control`` and "
"``vfio_device_feature_dma_logging_report`` structures in the header file "
"linux-headers/linux/vfio.h."
msgstr ""

#: ../../../devel/vfio-migration.rst:78
msgid ""
"(2) VFIO IOMMU module: In this method dirty tracking is done by IOMMU. "
"However, there is currently no IOMMU support for dirty page tracking. For "
"this reason, all pages are perpetually marked dirty, unless the device "
"driver pins pages through external APIs in which case only those pinned "
"pages are perpetually marked dirty."
msgstr ""

#: ../../../devel/vfio-migration.rst:84
msgid ""
"If the above two methods are not supported, all pages are perpetually marked "
"dirty by QEMU."
msgstr ""

#: ../../../devel/vfio-migration.rst:87
msgid ""
"By default, dirty pages are tracked during pre-copy as well as stop-and-copy "
"phase. So, a page marked as dirty will be copied to the destination in both "
"phases. Copying dirty pages in pre-copy phase helps QEMU to predict if it "
"can achieve its downtime tolerances. If QEMU during pre-copy phase keeps "
"finding dirty pages continuously, then it understands that even in stop-and-"
"copy phase, it is likely to find dirty pages and can predict the downtime "
"accordingly."
msgstr ""

#: ../../../devel/vfio-migration.rst:94
msgid ""
"QEMU also provides a per device opt-out option ``pre-copy-dirty-page-"
"tracking`` which disables querying the dirty bitmap during pre-copy phase. "
"If it is set to off, all dirty pages will be copied to the destination in "
"stop-and-copy phase only."
msgstr ""

#: ../../../devel/vfio-migration.rst:100
msgid "System memory dirty pages tracking when vIOMMU is enabled"
msgstr ""

#: ../../../devel/vfio-migration.rst:102
msgid ""
"With vIOMMU, an IO virtual address range can get unmapped while in pre-copy "
"phase of migration. In that case, the unmap ioctl returns any dirty pages in "
"that range and QEMU reports corresponding guest physical pages dirty. During "
"stop-and-copy phase, an IOMMU notifier is used to get a callback for mapped "
"pages and then dirty pages bitmap is fetched from VFIO IOMMU modules for "
"those mapped ranges. If device dirty tracking is enabled with vIOMMU, live "
"migration will be blocked."
msgstr ""

#: ../../../devel/vfio-migration.rst:111
msgid "Flow of state changes during Live migration"
msgstr ""

#: ../../../devel/vfio-migration.rst:113
msgid ""
"Below is the flow of state change during live migration. The values in the "
"brackets represent the VM state, the migration state, and the VFIO device "
"state, respectively."
msgstr ""

#: ../../../devel/vfio-migration.rst:118
msgid "Live migration save path"
msgstr ""

#: ../../../devel/vfio-migration.rst:122
msgid ""
"                      QEMU normal running state\n"
"                      (RUNNING, _NONE, _RUNNING)\n"
"                                |\n"
"                   migrate_init spawns migration_thread\n"
"              Migration thread then calls each device's .save_setup()\n"
"                     (RUNNING, _SETUP, _RUNNING)\n"
"                                |\n"
"                    (RUNNING, _ACTIVE, _RUNNING)\n"
"           If device is active, get pending_bytes by .state_pending_exact()\n"
"        If total pending_bytes >= threshold_size, call .save_live_iterate()\n"
"      Iterate till total pending bytes converge and are less than threshold\n"
"                                |\n"
"On migration completion, vCPU stops and calls .save_live_complete_precopy "
"for\n"
"each active device. The VFIO device is then transitioned into _STOP_COPY "
"state\n"
"                (FINISH_MIGRATE, _DEVICE, _STOP_COPY)\n"
"                                |\n"
"   For the VFIO device, iterate in .save_live_complete_precopy until\n"
"                       pending data is 0\n"
"                 (FINISH_MIGRATE, _DEVICE, _STOP)\n"
"                                |\n"
"               (FINISH_MIGRATE, _COMPLETED, _STOP)\n"
"           Migraton thread schedules cleanup bottom half and exits"
msgstr ""

#: ../../../devel/vfio-migration.rst:146
msgid "Live migration resume path"
msgstr ""

#: ../../../devel/vfio-migration.rst:150
msgid ""
"          Incoming migration calls .load_setup for each device\n"
"                   (RESTORE_VM, _ACTIVE, _STOP)\n"
"                             |\n"
"   For each device, .load_state is called for that device section data\n"
"                   (RESTORE_VM, _ACTIVE, _RESUMING)\n"
"                             |\n"
"At the end, .load_cleanup is called for each device and vCPUs are started\n"
"                   (RUNNING, _NONE, _RUNNING)"
msgstr ""

#: ../../../devel/vfio-migration.rst:160
msgid "Postcopy"
msgstr ""

#: ../../../devel/vfio-migration.rst:162
msgid "Postcopy migration is currently not supported for VFIO devices."
msgstr ""
