# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../specs/rocker.rst:2
msgid "Rocker Network Switch Register Programming Guide"
msgstr ""

#: ../../../specs/rocker.rst:20
msgid "Introduction"
msgstr ""

#: ../../../specs/rocker.rst:23
msgid "Overview"
msgstr ""

#: ../../../specs/rocker.rst:25
msgid ""
"This document describes the hardware/software interface for the Rocker "
"switch device.  The intended audience is authors of OS drivers and device "
"emulation software."
msgstr ""

#: ../../../specs/rocker.rst:30
msgid "Notations and Conventions"
msgstr ""

#: ../../../specs/rocker.rst:32
msgid ""
"In register descriptions, [n:m] indicates a range from bit n to bit m, "
"inclusive."
msgstr ""

#: ../../../specs/rocker.rst:34
msgid "Use of leading 0x indicates a hexadecimal number."
msgstr ""

#: ../../../specs/rocker.rst:35
msgid "Use of leading 0b indicates a binary number."
msgstr ""

#: ../../../specs/rocker.rst:36
msgid ""
"The use of RSVD or Reserved indicates that a bit or field is reserved for "
"future use."
msgstr ""

#: ../../../specs/rocker.rst:38
msgid "Field width is in bytes, unless otherwise noted."
msgstr ""

#: ../../../specs/rocker.rst:39
msgid ""
"Register are (R) read-only, (R/W) read/write, (W) write-only, or (COR) clear "
"on read"
msgstr ""

#: ../../../specs/rocker.rst:41 ../../../specs/rocker.rst:315
msgid "TLV values in network-byte-order are designated with (N)."
msgstr ""

#: ../../../specs/rocker.rst:45
msgid "PCI Configuration Registers"
msgstr ""

#: ../../../specs/rocker.rst:48
msgid "PCI Configuration Space"
msgstr ""

#: ../../../specs/rocker.rst:50
msgid ""
"Each switch instance registers as a PCI device with PCI configuration space::"
msgstr ""

#: ../../../specs/rocker.rst:52
msgid ""
"offset  width   description             value\n"
"---------------------------------------------\n"
"0x0     2       Vendor ID               0x1b36\n"
"0x2     2       Device ID               0x0006\n"
"0x4     4       Command/Status\n"
"0x8     1       Revision ID             0x01\n"
"0x9     3       Class code              0x2800\n"
"0xC     1       Cache line size\n"
"0xD     1       Latency timer\n"
"0xE     1       Header type\n"
"0xF     1       Built-in self test\n"
"0x10    4       Base address low\n"
"0x14    4       Base address high\n"
"0x18-28         Reserved\n"
"0x2C    2       Subsystem vendor ID     *\n"
"0x2E    2       Subsystem ID            *\n"
"0x30-38         Reserved\n"
"0x3C    1       Interrupt line\n"
"0x3D    1       Interrupt pin           0x00\n"
"0x3E    1       Min grant               0x00\n"
"0x3D    1       Max latency             0x00\n"
"0x40    1       TRDY timeout\n"
"0x41    1       Retry count\n"
"0x42    2       Reserved\n"
"\n"
"* Assigned by sub-system implementation"
msgstr ""

#: ../../../specs/rocker.rst:80
msgid "Memory-Mapped Register Space"
msgstr ""

#: ../../../specs/rocker.rst:82
msgid ""
"There are two memory-mapped BARs.  BAR0 maps device register space and is "
"0x2000 in size.  BAR1 maps MSI-X vector and PBA tables and is also 0x2000 in "
"size, allowing for 256 MSI-X vectors."
msgstr ""

#: ../../../specs/rocker.rst:86
msgid ""
"All registers are 4 or 8 bytes long.  It is assumed host software will "
"access 4 byte registers with one 4-byte access, and 8 byte registers with "
"either two 4-byte accesses or a single 8-byte access.  In the case of two 4-"
"byte accesses, access must be lower and then upper 4-bytes, in that order."
msgstr ""

#: ../../../specs/rocker.rst:91
msgid "BAR0 device register space is organized as follows::"
msgstr ""

#: ../../../specs/rocker.rst:93
msgid ""
"offset          description\n"
"------------------------------------------------------\n"
"0x0000-0x000f   Bogus registers to catch misbehaving\n"
"                drivers.  Writes do nothing.  Reads\n"
"                back as 0xDEADBABE.\n"
"0x0010-0x00ff   Test registers\n"
"0x0300-0x03ff   General purpose registers\n"
"0x1000-0x1fff   Descriptor control"
msgstr ""

#: ../../../specs/rocker.rst:102
msgid ""
"Holes in register space are reserved.  Writes to reserved registers do "
"nothing. Reads to reserved registers read back as 0."
msgstr ""

#: ../../../specs/rocker.rst:105
msgid "No fancy stuff like write-combining is enabled on any of the registers."
msgstr ""

#: ../../../specs/rocker.rst:107
msgid "BAR1 MSI-X register space is organized as follows::"
msgstr ""

#: ../../../specs/rocker.rst:109
msgid ""
"offset          description\n"
"------------------------------------------------------\n"
"0x0000-0x0fff   MSI-X vector table (256 vectors total)\n"
"0x1000-0x1fff   MSI-X PBA table"
msgstr ""

#: ../../../specs/rocker.rst:116
msgid "Interrupts, DMA, and Endianness"
msgstr ""

#: ../../../specs/rocker.rst:119
msgid "PCI Interrupts"
msgstr ""

#: ../../../specs/rocker.rst:121
msgid ""
"The device supports only MSI-X interrupts.  BAR1 memory-mapped region "
"contains the MSI-X vector and PBA tables, with support for up to 256 MSI-X "
"vectors."
msgstr ""

#: ../../../specs/rocker.rst:124
msgid "The vector assignment is::"
msgstr ""

#: ../../../specs/rocker.rst:126
msgid ""
"vector          description\n"
"-----------------------------------------------------\n"
"0               Command descriptor ring completion\n"
"1               Event descriptor ring completion\n"
"2               Test operation completion\n"
"3               RSVD\n"
"4-255           Tx and Rx descriptor ring completion\n"
"                  Tx vector is even\n"
"                  Rx vector is odd"
msgstr ""

#: ../../../specs/rocker.rst:136
msgid "A MSI-X vector table entry is 16 bytes::"
msgstr ""

#: ../../../specs/rocker.rst:138
msgid ""
"field           offset  width   description\n"
"-------------------------------------------------------------\n"
"lower_addr      0x0     4       [31:2] message address[31:2]\n"
"                                [1:0] Rsvd (4 byte alignment\n"
"                                            required)\n"
"upper_addr      0x4     4       [31:19] Rsvd\n"
"                                [14:0] message address[46:32]\n"
"data            0x8     4       message data[31:0]\n"
"control         0xc     4       [31:1] Rsvd\n"
"                                [0] mask (0 = enable,\n"
"                                          1 = masked)"
msgstr ""

#: ../../../specs/rocker.rst:150
msgid ""
"Software should install the Interrupt Service Routine (ISR) before any ports "
"are enabled or any commands are issued on the command ring."
msgstr ""

#: ../../../specs/rocker.rst:154
msgid "DMA Operations"
msgstr ""

#: ../../../specs/rocker.rst:156
msgid ""
"DMA operations are used for packet DMA to/from the CPU, command and event "
"processing.  Command processing includes statistical counters and table "
"dumps, table insertion/deletion, and more.  Event processing provides an "
"async notification method for device-originating events.  Each DMA operation "
"has a set of control registers to manage a descriptor ring.  The descriptor "
"rings are allocated from contiguous host DMA-able memory and registers "
"specify the rings base address, size and current head and tail indices.  "
"Software always writes the head, and hardware always writes the tail."
msgstr ""

#: ../../../specs/rocker.rst:165
msgid ""
"The higher-order bit of DMA_DESC_COMP_ERR is used to mark hardware "
"completion of a descriptor.  Software will clear this bit when posting a "
"descriptor to the ring, and hardware will set this bit when the descriptor "
"is complete."
msgstr ""

#: ../../../specs/rocker.rst:169
msgid ""
"Descriptor ring sizes must be a power of 2 and range from 2 to 64K entries. "
"Descriptor rings' base address must be 8-byte aligned.  Descriptors must be "
"packed within ring.  Each descriptor in each ring must also be aligned on an "
"8 byte boundary.  Each descriptor ring will have these registers::"
msgstr ""

#: ../../../specs/rocker.rst:174
msgid ""
"DMA_DESC_xxx_BASE_ADDR, offset 0x1000 + (x * 32), 64-bit, (R/W)\n"
"DMA_DESC_xxx_SIZE, offset 0x1008 + (x * 32), 32-bit, (R/W)\n"
"DMA_DESC_xxx_HEAD, offset 0x100c + (x * 32), 32-bit, (R/W)\n"
"DMA_DESC_xxx_TAIL, offset 0x1010 + (x * 32), 32-bit, (R)\n"
"DMA_DESC_xxx_CTRL, offset 0x1014 + (x * 32), 32-bit, (W)\n"
"DMA_DESC_xxx_CREDITS, offset 0x1018 + (x * 32), 32-bit, (R/W)\n"
"DMA_DESC_xxx_RSVD1, offset 0x101c + (x * 32), 32-bit, (R/W)"
msgstr ""

#: ../../../specs/rocker.rst:182
msgid "Where x is descriptor ring index::"
msgstr ""

#: ../../../specs/rocker.rst:184
msgid ""
"index           ring\n"
"--------------------\n"
"0               CMD\n"
"1               EVENT\n"
"2               TX (port 0)\n"
"3               RX (port 0)\n"
"4               TX (port 1)\n"
"5               RX (port 1)\n"
".\n"
".\n"
".\n"
"124             TX (port 61)\n"
"125             RX (port 61)\n"
"126             Resv\n"
"127             Resv"
msgstr ""

#: ../../../specs/rocker.rst:200
msgid ""
"Writing BASE_ADDR or SIZE will reset HEAD and TAIL to zero.  HEAD cannot be "
"written past TAIL.  To do so would wrap the ring.  An empty ring is when "
"HEAD == TAIL.  A full ring is when HEAD is one position behind TAIL.  Both "
"HEAD and TAIL increment and modulo wrap at the ring size."
msgstr ""

#: ../../../specs/rocker.rst:205
msgid "CTRL register bits::"
msgstr ""

#: ../../../specs/rocker.rst:207
msgid ""
"bit     name            description\n"
"------------------------------------------------------------------------\n"
"[0]     CTRL_RESET      Reset the descriptor ring\n"
"[1:31]  Reserved"
msgstr ""

#: ../../../specs/rocker.rst:212
msgid "All descriptor types share some common fields::"
msgstr ""

#: ../../../specs/rocker.rst:214
msgid ""
"field                   width   description\n"
"-------------------------------------------------------------------\n"
"DMA_DESC_BUF_ADDR       8       Phys addr of desc payload, 8-byte\n"
"                                aligned\n"
"DMA_DESC_COOKIE         8       Desc cookie for completion matching,\n"
"                                upper-most bit is reserved\n"
"DMA_DESC_BUF_SIZE       2       Desc payload size in bytes\n"
"DMA_DESC_TLV_SIZE       2       Desc payload total size in bytes\n"
"                                used for TLVs.  Must be <=\n"
"                                DMA_DESC_BUF_SIZE.\n"
"DMA_DESC_COMP_ERR       2       Completion status of associated\n"
"                                desc payload.  High order bit is\n"
"                                clear on new descs, toggled by\n"
"                                hw for completed items."
msgstr ""

#: ../../../specs/rocker.rst:229
msgid ""
"To support forward- and backward-compatibility, descriptor and completion "
"payloads are specified in TLV format.  Fields are packed with Type=field "
"name, Length=field length, and Value=field value.  Software will ignore "
"unknown fields filled in by the switch.  Likewise, the switch will ignore "
"unknown fields filled in by software."
msgstr ""

#: ../../../specs/rocker.rst:235
msgid ""
"Descriptor payload buffer is 8-byte aligned and TLVs are 8-byte aligned.  "
"The value within a TLV is also 8-byte aligned.  The (packed, 8 byte) TLV "
"header is::"
msgstr ""

#: ../../../specs/rocker.rst:238
msgid ""
"field   width   description\n"
"-----------------------------\n"
"type    4       TLV type\n"
"len     2       TLV value length\n"
"pad     2       Reserved"
msgstr ""

#: ../../../specs/rocker.rst:244
msgid ""
"The alignment requirements for descriptors and TLVs are to avoid unaligned "
"access exceptions in software.  Note that the payload for each TLV is also 8 "
"byte aligned."
msgstr ""

#: ../../../specs/rocker.rst:248
msgid "Figure 1 shows an example descriptor buffer with two TLVs::"
msgstr ""

#: ../../../specs/rocker.rst:250
msgid ""
"                <------- 8 bytes ------->\n"
"\n"
"8-byte  +––––+  +–––––––––––+–––––+–––––+                     +–+\n"
"align           |   type    | len | pad |    TLV#1 hdr          |\n"
"                +–––––––––––+–––––+–––––+    (len=22)           |\n"
"                |                       |                       |\n"
"                |  value                |    TVL#1 value        |\n"
"                |                       |    (padded to 8-byte  |\n"
"                |                 +–––––+     alignment)        |\n"
"                |                 |/////|                       |\n"
" 8-byte +––––+  +–––––––––––+–––––––––––+                       |\n"
" align          |   type    | len | pad |    TLV#2 hdr    DESC_BUF_SIZE\n"
"                +–––––+–––––+–––––+–––––+    (len=2)            |\n"
"                |value|/////////////////|    TLV#2 value        |\n"
"                +–––––+/////////////////|                       |\n"
"                |///////////////////////|                       |\n"
"                |///////////////////////|                       |\n"
"                |///////////////////////|                       |\n"
"                |////////unused/////////|                       |\n"
"                |////////space//////////|                       |\n"
"                |///////////////////////|                       |\n"
"                |///////////////////////|                       |\n"
"                |///////////////////////|                       |\n"
"                +–––––––––––––––––––––––+                     +–+\n"
"\n"
"                              fig. 1"
msgstr ""

#: ../../../specs/rocker.rst:277
msgid "TLVs can be nested within the NEST TLV type."
msgstr ""

#: ../../../specs/rocker.rst:280
msgid "Interrupt credits"
msgstr ""

#: ../../../specs/rocker.rst:282
msgid ""
"MSI-X vectors used for descriptor ring completions use a credit mechanism "
"for efficient device, PCIe bus, OS and driver operations.  Each descriptor "
"ring has a credit count which represents the number of outstanding "
"descriptors to be processed by the driver.  As the device marks descriptors "
"complete, the credit count is incremented.  As the driver processes those "
"outstanding descriptors, it returns credits back to the device.  This way, "
"the device knows the driver's progress and can make decisions about when to "
"fire the next interrupt or not. When the credit count is zero, and the first "
"descriptors are posted for the driver, a single interrupt is fired.  Once "
"the interrupt is fired, the interrupt is disabled (auto-masked*).  In "
"response to the interrupt, the driver will process descriptors and PIO write "
"a returned credit value for that descriptor ring.  If the driver returns all "
"credits (the driver caught up with the device and there is no outstanding "
"work), then the interrupt is unmasked, but not fired.  If only partial "
"credits are returned, the interrupt remains masked but the device generates "
"an interrupt, signaling the driver that more outstanding work is available."
msgstr ""

#: ../../../specs/rocker.rst:299
msgid "(* this masking is unrelated to the MSI-X interrupt mask register)"
msgstr ""

#: ../../../specs/rocker.rst:302
msgid "Endianness"
msgstr ""

#: ../../../specs/rocker.rst:304
msgid ""
"Device registers are hard-coded to little-endian (LE).  The driver should "
"convert to/from host endianness to LE for device register accesses."
msgstr ""

#: ../../../specs/rocker.rst:307
msgid ""
"Descriptors are LE.  Descriptor buffer TLVs will have LE type and length "
"fields, but the value field can either be LE or network-byte-order, "
"depending on context.  TLV values containing network packet data will be in "
"network-byte order.  A TLV value containing a field or mask used to compare "
"against network packet data is network-byte order.  For example, flow match "
"fields (and masks) are network-byte-order since they're matched directly, "
"byte-by-byte, against network packet data.  All non-network-packet TLV multi-"
"byte values will be LE."
msgstr ""

#: ../../../specs/rocker.rst:319
msgid "Test Registers"
msgstr ""

#: ../../../specs/rocker.rst:321
msgid ""
"Rocker has several test registers to support troubleshooting register "
"access, interrupt generation, and DMA operations::"
msgstr ""

#: ../../../specs/rocker.rst:324
msgid ""
"TEST_REG, offset 0x0010, 32-bit (R/W)\n"
"TEST_REG64, offset 0x0018, 64-bit (R/W)\n"
"TEST_IRQ, offset 0x0020, 32-bit (R/W)\n"
"TEST_DMA_ADDR, offset 0x0028, 64-bit (R/W)\n"
"TEST_DMA_SIZE, offset 0x0030, 32-bit (R/W)\n"
"TEST_DMA_CTRL, offset 0x0034, 32-bit (R/W)"
msgstr ""

#: ../../../specs/rocker.rst:331
msgid ""
"Reads to TEST_REG and TEST_REG64 will read a value equal to twice the last "
"value written to the register.  The 32-bit and 64-bit versions are for "
"testing 32-bit and 64-bit host accesses."
msgstr ""

#: ../../../specs/rocker.rst:335
msgid ""
"A vector can be written to TEST_IRQ and the device will generate an "
"interrupt for that vector."
msgstr ""

#: ../../../specs/rocker.rst:338
msgid ""
"To test basic DMA operations, allocate a DMA-able host buffer and put the "
"buffer address into TEST_DMA_ADDR and size into TEST_DMA_SIZE.  Then, write "
"to TEST_DMA_CTRL to manipulate the buffer contents.  TEST_DMA_CTRL "
"operations are::"
msgstr ""

#: ../../../specs/rocker.rst:342
msgid ""
"operation               value   description\n"
"-----------------------------------------------------------\n"
"TEST_DMA_CTRL_CLEAR     1       clear buffer\n"
"TEST_DMA_CTRL_FILL      2       fill buffer bytes with 0x96\n"
"TEST_DMA_CTRL_INVERT    4       invert bytes in buffer"
msgstr ""

#: ../../../specs/rocker.rst:348
msgid ""
"Various buffer address and sizes should be tested to verify no address "
"boundary issue exists.  In particular, buffers that start on odd-8-byte "
"boundary and/or span multiple PAGE sizes should be tested."
msgstr ""

#: ../../../specs/rocker.rst:354
msgid "Ports"
msgstr ""

#: ../../../specs/rocker.rst:357
msgid "Physical and Logical Ports"
msgstr ""

#: ../../../specs/rocker.rst:359
msgid ""
"The switch supports up to 62 physical (front-panel) ports.  Register "
"PORT_PHYS_COUNT returns the actual number of physical ports available::"
msgstr ""

#: ../../../specs/rocker.rst:362
msgid "PORT_PHYS_COUNT, offset 0x0304, 32-bit, (R)"
msgstr ""

#: ../../../specs/rocker.rst:364
msgid ""
"In addition to front-panel ports, the switch supports logical ports for "
"tunnels."
msgstr ""

#: ../../../specs/rocker.rst:367
msgid ""
"Front-panel ports and logical tunnel ports are mapped into a single 32-bit "
"port space.  A special CPU port is assigned port 0.  The front-panel ports "
"are mapped to ports 1-62.  A special loopback port is assigned port 63.  "
"Logical tunnel ports are assigned ports 0x0001000-0x0001ffff. To summarize "
"the port assignments::"
msgstr ""

#: ../../../specs/rocker.rst:373
msgid ""
"port                    mapping\n"
"-------------------------------------------------------\n"
"0                       CPU port (for packets to/from host CPU)\n"
"1-62                    front-panel physical ports\n"
"63                      loopback port\n"
"64-0x0000ffff           RSVD\n"
"0x00010000-0x0001ffff   logical tunnel ports\n"
"0x00020000-0xffffffff   RSVD"
msgstr ""

#: ../../../specs/rocker.rst:383
msgid "Physical Port Mode"
msgstr ""

#: ../../../specs/rocker.rst:385
msgid ""
"Switch front-panel ports operate in a mode.  Currently, the only mode is OF-"
"DPA.  OF-DPA[1] mode is based on OpenFlow Data Plane Abstraction (OF-DPA) "
"Abstract Switch Specification, Version 1.0, from Broadcom Corporation.  To "
"set/get the mode for front-panel ports, see port settings, below."
msgstr ""

#: ../../../specs/rocker.rst:391
msgid "Port Settings"
msgstr ""

#: ../../../specs/rocker.rst:393
msgid ""
"Link status for all front-panel ports is available via "
"PORT_PHYS_LINK_STATUS::"
msgstr ""

#: ../../../specs/rocker.rst:395
msgid ""
"PORT_PHYS_LINK_STATUS, offset 0x0310, 64-bit, (R)\n"
"\n"
"Value is port bitmap.  Bits 0 and 63 always read 0.  Bits 1-62\n"
"read 1 for link UP and 0 for link DOWN for respective front-panel ports."
msgstr ""

#: ../../../specs/rocker.rst:400
msgid ""
"Other properties for front-panel ports are available via DMA CMD "
"descriptors::"
msgstr ""

#: ../../../specs/rocker.rst:402
msgid ""
"Get PORT_SETTINGS descriptor:\n"
"\n"
"        field           width   description\n"
"        ----------------------------------------------\n"
"        PORT_SETTINGS   2       CMD_GET\n"
"        PPORT           4       Physical port #\n"
"\n"
"Get PORT_SETTINGS completion:\n"
"\n"
"        field           width   description\n"
"        ----------------------------------------------\n"
"        PPORT           4       Physical port #\n"
"        SPEED           4       Current port interface speed, in Mbps\n"
"        DUPLEX          1       1 = Full, 0 = Half\n"
"        AUTONEG         1       1 = enabled, 0 = disabled\n"
"        MACADDR         6       Port MAC address\n"
"        MODE            1       0 = OF-DPA\n"
"        LEARNING        1       MAC address learning on port\n"
"                                        1 = enabled\n"
"                                        0 = disabled\n"
"        PHYS_NAME       <var>   Physical port name (string)\n"
"\n"
"Set PORT_SETTINGS descriptor:\n"
"\n"
"        field           width   description\n"
"        ----------------------------------------------\n"
"        PORT_SETTINGS   2       CMD_SET\n"
"        PPORT           4       Physical port #\n"
"        SPEED           4       Port interface speed, in Mbps\n"
"        DUPLEX          1       1 = Full, 0 = Half\n"
"        AUTONEG         1       1 = enabled, 0 = disabled\n"
"        MACADDR         6       Port MAC address\n"
"        MODE            1       0 = OF-DPA"
msgstr ""

#: ../../../specs/rocker.rst:437
msgid "Port Enable"
msgstr ""

#: ../../../specs/rocker.rst:439
msgid ""
"Front-panel ports are initially disabled, which means port ingress and "
"egress packets will be dropped.  To enable or disable a port, use "
"PORT_PHYS_ENABLE::"
msgstr ""

#: ../../../specs/rocker.rst:442
msgid ""
"PORT_PHYS_ENABLE: offset 0x0318, 64-bit, (R/W)\n"
"\n"
"Value is bitmap of first 64 ports.  Bits 0 and 63 are ignored\n"
"and always read as 0.  Write 1 to enable port; write 0 to disable it.\n"
"Default is 0."
msgstr ""

#: ../../../specs/rocker.rst:450
msgid "Switch Control"
msgstr ""

#: ../../../specs/rocker.rst:452
msgid "This section covers switch-wide register settings."
msgstr ""

#: ../../../specs/rocker.rst:455
msgid "Control"
msgstr ""

#: ../../../specs/rocker.rst:457
msgid "This register is used for low level control of the switch::"
msgstr ""

#: ../../../specs/rocker.rst:459
msgid ""
"CONTROL: offset 0x0300, 32-bit, (W)\n"
"\n"
"bit     name            description\n"
"------------------------------------------------------------------------\n"
"[0]     CONTROL_RESET   If set, device will perform reset\n"
"[1:31]  Reserved"
msgstr ""

#: ../../../specs/rocker.rst:467
msgid "Switch ID"
msgstr ""

#: ../../../specs/rocker.rst:469
msgid ""
"The switch has a SWITCH_ID to be used by software to uniquely identify the "
"switch::"
msgstr ""

#: ../../../specs/rocker.rst:472
msgid ""
"SWITCH_ID: offset 0x0320, 64-bit, (R)\n"
"\n"
"Value is opaque to switch software and no special encoding is implied."
msgstr ""

#: ../../../specs/rocker.rst:478
msgid "Events"
msgstr ""

#: ../../../specs/rocker.rst:480
msgid ""
"Non-I/O asynchronous events from the device are notified to the host using "
"the event ring.  The TLV structure for events is::"
msgstr ""

#: ../../../specs/rocker.rst:483
msgid ""
"field           width   description\n"
"---------------------------------------------------\n"
"TYPE            4       Event type, one of:\n"
"                                1: LINK_CHANGED\n"
"                                2: MAC_VLAN_SEEN\n"
"INFO            <nest>  Event info (details below)"
msgstr ""

#: ../../../specs/rocker.rst:491
msgid "Link Changed Event"
msgstr ""

#: ../../../specs/rocker.rst:493
msgid "When link status changes on a physical port, this event is generated::"
msgstr ""

#: ../../../specs/rocker.rst:495
msgid ""
"field           width   description\n"
"---------------------------------------------------\n"
"INFO            <nest>\n"
"  PPORT         4       Physical port\n"
"  LINKUP        1       Link status:\n"
"                                0: down\n"
"                                1: up"
msgstr ""

#: ../../../specs/rocker.rst:504
msgid "MAC VLAN Seen Event"
msgstr ""

#: ../../../specs/rocker.rst:506
msgid ""
"When a packet ingresses on a port and the source MAC/VLAN isn't known to the "
"device, the device will generate this event.  In response to the event, the "
"driver should install to the device the MAC/VLAN on the port into the bridge "
"table.  Once installed, the MAC/VLAN is known on the port and this event "
"will no longer be generated."
msgstr ""

#: ../../../specs/rocker.rst:514
msgid ""
"field           width   description\n"
"---------------------------------------------------\n"
"INFO            <nest>\n"
"  PPORT         4       Physical port\n"
"  MAC           6       MAC address\n"
"  VLAN          2       VLAN ID"
msgstr ""

#: ../../../specs/rocker.rst:523
msgid "CPU Packet Processing"
msgstr ""

#: ../../../specs/rocker.rst:525
msgid ""
"Ingress packets directed to the host CPU for further processing are "
"delivered in the DMA RX ring.  Likewise, host CPU originating packets "
"destined to egress on switch ports are scheduled by software using the DMA "
"TX ring."
msgstr ""

#: ../../../specs/rocker.rst:530
msgid "Tx Packet Processing"
msgstr ""

#: ../../../specs/rocker.rst:532
msgid ""
"Software schedules packets for egress on switch ports using the DMA TX "
"ring.  A TX descriptor buffer describes the packet location and size in host "
"DMA-able memory, the destination port, and any hardware-offload functions "
"(such as L3 payload checksum offload).  Software then bumps the descriptor "
"head to signal hardware of new Tx work.  In response, hardware will DMA read "
"Tx descriptors up to head, DMA read descriptor buffer and packet data, "
"perform offloading functions, and finally frame packet on wire (network).  "
"Once packet processing is complete, hardware will writeback status to "
"descriptor(s) to signal to software that Tx is complete and software "
"resources (e.g. skb) backing packet can be released."
msgstr ""

#: ../../../specs/rocker.rst:543
msgid ""
"Figure 2 shows an example 3-fragment packet queued with one Tx descriptor.  "
"A TLV is used for each packet fragment::"
msgstr ""

#: ../../../specs/rocker.rst:546
msgid ""
"                                           pkt frag 1\n"
"                                           +–––––––+  +–+\n"
"                                       +–––+       |    |\n"
"                         desc buf      |   |       |    |\n"
"                        +––––––––+     |   |       |    |\n"
"        Tx ring     +–––+        +–––––+   |       |    |\n"
"      +–––––––––+   |   |  TLVs  |         +–––––––+    |\n"
"      |         +–––+   +––––––––+         pkt frag 2   |\n"
"      | desc 0  |       |        +–––––+   +–––––––+    |\n"
"      +–––––––––+       |  TLVs  |     +–––+       |    |\n"
"head+–+         |       +––––––––+         |       |    |\n"
"      | desc 1  |       |        +–––––+   +–––––––+    |pkt\n"
"      +–––––––––+       |  TLVs  |     |                |\n"
"      |         |       +––––––––+     |   pkt frag 3   |\n"
"      |         |                      |   +–––––––+    |\n"
"      +–––––––––+                      +–––+       |    |\n"
"      |         |                          |       |    |\n"
"      |         |                          |       |    |\n"
"      +–––––––––+                          |       |    |\n"
"      |         |                          |       |    |\n"
"      |         |                          |       |    |\n"
"      +–––––––––+                          |       |    |\n"
"      |         |                          +–––––––+  +–+\n"
"      |         |\n"
"      +–––––––––+\n"
"\n"
"                        fig 2."
msgstr ""

#: ../../../specs/rocker.rst:574
msgid "The TLVs for Tx descriptor buffer are::"
msgstr ""

#: ../../../specs/rocker.rst:576
msgid ""
"field                   width   description\n"
"---------------------------------------------------------------------\n"
"PPORT                   4       Destination physical port #\n"
"TX_OFFLOAD              1       Hardware offload modes:\n"
"                                  0: no offload\n"
"                                  1: insert IP csum (ipv4 only)\n"
"                                  2: insert TCP/UDP csum\n"
"                                  3: L3 csum calc and insert\n"
"                                     into csum offset (TX_L3_CSUM_OFF)\n"
"                                    16-bit 1's complement csum value.\n"
"                                     IPv4 pseudo-header and IP\n"
"                                     already calculated by OS\n"
"                                   and inserted.\n"
"                                  4: TSO (TCP Segmentation Offload)\n"
"TX_L3_CSUM_OFF          2       For L3 csum offload mode, the offset,\n"
"                                from the beginning of the packet,\n"
"                                of the csum field in the L3 header\n"
"TX_TSO_MSS              2       For TSO offload mode, the\n"
"                                Maximum Segment Size in bytes\n"
"TX_TSO_HDR_LEN          2       For TSO offload mode, the\n"
"                                length of ethernet, IP, and\n"
"                                TCP/UDP headers, including IP\n"
"                                and TCP options.\n"
"TX_FRAGS                <array> Packet fragments\n"
"  TX_FRAG               <nest>  Packet fragment\n"
"    TX_FRAG_ADDR        8       DMA address of packet fragment\n"
"    TX_FRAG_LEN         2       Packet fragment length"
msgstr ""

#: ../../../specs/rocker.rst:604 ../../../specs/rocker.rst:653
#: ../../../specs/rocker.rst:910 ../../../specs/rocker.rst:990
msgid "Possible status return codes in descriptor on completion are::"
msgstr ""

#: ../../../specs/rocker.rst:606
msgid ""
"DESC_COMP_ERR   reason\n"
"--------------------------------------------------------------------\n"
"0               OK\n"
"-ROCKER_ENXIO   address or data read err on desc buf or packet\n"
"                fragment\n"
"-ROCKER_EINVAL  bad pport or TSO or csum offloading error\n"
"-ROCKER_ENOMEM  no memory for internal staging tx fragment"
msgstr ""

#: ../../../specs/rocker.rst:615
msgid "Rx Packet Processing"
msgstr ""

#: ../../../specs/rocker.rst:617
msgid ""
"For packets ingressing on switch ports that are not forwarded by the switch "
"but rather directed to the host CPU for further processing are delivered in "
"the DMA RX ring.  Rx descriptor buffers are allocated by software and placed "
"on the ring.  Hardware will fill Rx descriptor buffers with packet data, "
"write the completion, and signal to software that a new packet is ready.  "
"Since Rx packet size is not known a-priori, the Rx descriptor buffer must be "
"allocated for worst-case packet size.  A single Rx descriptor will contain "
"the entire Rx packet data in one RX_FRAG.  Other Rx TLVs describe and "
"hardware offloads performed on the packet, such as checksum validation."
msgstr ""

#: ../../../specs/rocker.rst:627
msgid "The TLVs for Rx descriptor buffer are::"
msgstr ""

#: ../../../specs/rocker.rst:629
msgid ""
"field           width   description\n"
"---------------------------------------------------\n"
"PPORT           4       Source physical port #\n"
"RX_FLAGS        2       Packet parsing flags:\n"
"                          (1 << 0): IPv4 packet\n"
"                          (1 << 1): IPv6 packet\n"
"                          (1 << 2): csum calculated\n"
"                          (1 << 3): IPv4 csum good\n"
"                          (1 << 4): IP fragment\n"
"                          (1 << 5): TCP packet\n"
"                          (1 << 6): UDP packet\n"
"                          (1 << 7): TCP/UDP csum good\n"
"                          (1 << 8): Offload forward\n"
"RX_CSUM         2       IP calculated checksum:\n"
"                          IPv4: IP payload csum\n"
"                          IPv6: header and payload csum\n"
"                        (Only valid is RX_FLAGS:csum calc is set)\n"
"RX_FRAG_ADDR    8       DMA address of packet fragment\n"
"RX_FRAG_MAX_LEN 2       Packet maximum fragment length\n"
"RX_FRAG_LEN     2       Actual packet fragment length after receive"
msgstr ""

#: ../../../specs/rocker.rst:650
msgid ""
"Offload forward RX_FLAG indicates the device has already forwarded the "
"packet so the host CPU should not also forward the packet."
msgstr ""

#: ../../../specs/rocker.rst:655
msgid ""
"DESC_COMP_ERR   reason\n"
"--------------------------------------------------------------------\n"
"0               OK\n"
"-ROCKER_ENXIO   address or data read err on desc buf\n"
"-ROCKER_ENOMEM  no memory for internal staging desc buf\n"
"-ROCKER_EMSGSIZE Rx descriptor buffer wasn't big enough to contain\n"
"                packet data TLV and other TLVs."
msgstr ""

#: ../../../specs/rocker.rst:665
msgid "OF-DPA Mode"
msgstr ""

#: ../../../specs/rocker.rst:667
msgid ""
"OF-DPA mode allows the switch to offload flow packet processing functions to "
"hardware.  An OpenFlow controller would communicate with an OpenFlow agent "
"installed on the switch.  The OpenFlow agent would (directly or indirectly) "
"communicate with the Rocker switch driver, which in turn would program "
"switch hardware with flow functionality, as defined in OF-DPA.  The block "
"diagram is::"
msgstr ""

#: ../../../specs/rocker.rst:673
msgid ""
"+–––––––––––––––----–––+\n"
"|        OF            |\n"
"|  Remote Controller   |\n"
"+––––––––+––----–––––––+\n"
"         |\n"
"         |\n"
"+––––––––+–––––––––+\n"
"|       OF         |\n"
"|   Local Agent    |\n"
"+––––––––––––––––––+\n"
"|                  |\n"
"|   Rocker Driver  |\n"
"+––––––––––––––––––+\n"
"    <this spec>\n"
"+––––––––––––––––––+\n"
"|                  |\n"
"|   Rocker Switch  |\n"
"+––––––––––––––––––+"
msgstr ""

#: ../../../specs/rocker.rst:692
msgid ""
"To participate in flow functions, ports must be configure for OF-DPA mode "
"during switch initialization."
msgstr ""

#: ../../../specs/rocker.rst:696
msgid "OF-DPA Flow Table Interface"
msgstr ""

#: ../../../specs/rocker.rst:698
msgid ""
"There are commands to add, modify, delete, and get stats of flow table "
"entries. The commands are issued using the DMA CMD descriptor ring.  The "
"following commands are defined::"
msgstr ""

#: ../../../specs/rocker.rst:702
msgid ""
"CMD_ADD:                add an entry to flow table\n"
"CMD_MOD:                modify an entry in flow table\n"
"CMD_DEL:                delete an entry from flow table\n"
"CMD_GET_STATS:          get stats for flow entry"
msgstr ""

#: ../../../specs/rocker.rst:707 ../../../specs/rocker.rst:939
msgid "TLVs for add and modify commands are::"
msgstr ""

#: ../../../specs/rocker.rst:709
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_CMD              2       CMD_[ADD|MOD]\n"
"OF_DPA_TBL              2       Flow table ID\n"
"                                  0: ingress port\n"
"                                  10: vlan\n"
"                                  20: termination mac\n"
"                                  30: unicast routing\n"
"                                  40: multicast routing\n"
"                                  50: bridging\n"
"                                  60: ACL policy\n"
"OF_DPA_PRIORITY         4       Flow priority\n"
"OF_DPA_HARDTIME         4       Hard timeout for flow\n"
"OF_DPA_IDLETIME         4       Idle timeout for flow\n"
"OF_DPA_COOKIE           8       Cookie"
msgstr ""

#: ../../../specs/rocker.rst:725
msgid "Additional TLVs based on flow table ID:"
msgstr ""

#: ../../../specs/rocker.rst:727
msgid "Table ID 0: ingress port::"
msgstr ""

#: ../../../specs/rocker.rst:729
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_IN_PPORT         4       ingress physical port number\n"
"OF_DPA_GOTO_TBL         2       goto table ID; zero to drop"
msgstr ""

#: ../../../specs/rocker.rst:734
msgid "Table ID 10: vlan::"
msgstr ""

#: ../../../specs/rocker.rst:736
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_IN_PPORT         4       ingress physical port number\n"
"OF_DPA_VLAN_ID          2 (N)   vlan ID\n"
"OF_DPA_VLAN_ID_MASK     2 (N)   vlan ID mask\n"
"OF_DPA_GOTO_TBL         2       goto table ID; zero to drop\n"
"OF_DPA_NEW_VLAN_ID      2 (N)   new vlan ID"
msgstr ""

#: ../../../specs/rocker.rst:744
msgid "Table ID 20: termination mac::"
msgstr ""

#: ../../../specs/rocker.rst:746
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_IN_PPORT         4       ingress physical port number\n"
"OF_DPA_IN_PPORT_MASK    4       ingress physical port number mask\n"
"OF_DPA_ETHERTYPE        2 (N)   must be either 0x0800 or 0x86dd\n"
"OF_DPA_DST_MAC          6 (N)   destination MAC\n"
"OF_DPA_DST_MAC_MASK     6 (N)   destination MAC mask\n"
"OF_DPA_VLAN_ID          2 (N)   vlan ID\n"
"OF_DPA_VLAN_ID_MASK     2 (N)   vlan ID mask\n"
"OF_DPA_GOTO_TBL         2       only acceptable values are\n"
"                                unicast or multicast routing\n"
"                                table IDs\n"
"OF_DPA_OUT_PPORT        2       if specified, must be\n"
"                                controller, set zero otherwise"
msgstr ""

#: ../../../specs/rocker.rst:761
msgid "Table ID 30: unicast routing::"
msgstr ""

#: ../../../specs/rocker.rst:763
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_ETHERTYPE        2 (N)   must be either 0x0800 or 0x86dd\n"
"OF_DPA_DST_IP           4 (N)   destination IPv4 address.\n"
"                                Must be unicast address\n"
"OF_DPA_DST_IP_MASK      4 (N)   IP mask.  Must be prefix mask\n"
"OF_DPA_DST_IPV6         16 (N)  destination IPv6 address.\n"
"                                Must be unicast address\n"
"OF_DPA_DST_IPV6_MASK    16 (N)  IPv6 mask. Must be prefix mask\n"
"OF_DPA_GOTO_TBL         2       goto table ID; zero to drop\n"
"OF_DPA_GROUP_ID         4       data for GROUP action must\n"
"                                be an L3 Unicast group entry"
msgstr ""

#: ../../../specs/rocker.rst:776
msgid "Table ID 40: multicast routing::"
msgstr ""

#: ../../../specs/rocker.rst:778
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_ETHERTYPE        2 (N)   must be either 0x0800 or 0x86dd\n"
"OF_DPA_VLAN_ID          2 (N)   vlan ID\n"
"OF_DPA_SRC_IP           4 (N)   source IPv4. Optional,\n"
"                                can contain IPv4 address,\n"
"                                must be completely masked\n"
"                                if not used\n"
"OF_DPA_SRC_IP_MASK      4 (N)   IP Mask\n"
"OF_DPA_DST_IP           4 (N)   destination IPv4 address.\n"
"                                Must be multicast address\n"
"OF_DPA_SRC_IPV6         16 (N)  source IPv6 Address. Optional.\n"
"                                Can contain IPv6 address,\n"
"                                must be completely masked\n"
"                                if not used\n"
"OF_DPA_SRC_IPV6_MASK    16 (N)  IPv6 mask.\n"
"OF_DPA_DST_IPV6         16 (N)  destination IPv6 Address. Must\n"
"                                be multicast address\n"
"                                Must be multicast address\n"
"OF_DPA_GOTO_TBL         2       goto table ID; zero to drop\n"
"OF_DPA_GROUP_ID         4       data for GROUP action must\n"
"                                be an L3 multicast group entry"
msgstr ""

#: ../../../specs/rocker.rst:801
msgid "Table ID 50: bridging::"
msgstr ""

#: ../../../specs/rocker.rst:803
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_VLAN_ID          2 (N)   vlan ID\n"
"OF_DPA_TUNNEL_ID        4       tunnel ID\n"
"OF_DPA_DST_MAC          6 (N)   destination MAC\n"
"OF_DPA_DST_MAC_MASK     6 (N)   destination MAC mask\n"
"OF_DPA_GOTO_TBL         2       goto table ID; zero to drop\n"
"OF_DPA_GROUP_ID         4       data for GROUP action must\n"
"                                be a L2 Interface, L2\n"
"                                Multicast, L2 Flood,\n"
"                                or L2 Overlay group entry\n"
"                                as appropriate\n"
"OF_DPA_TUNNEL_LPORT     4       unicast Tenant Bridging\n"
"                                flows specify a tunnel\n"
"                                logical port ID\n"
"OF_DPA_OUT_PPORT        2       data for OUTPUT action,\n"
"                                restricted to CONTROLLER,\n"
"                                set to 0 otherwise"
msgstr ""

#: ../../../specs/rocker.rst:822
msgid "Table ID 60: acl policy::"
msgstr ""

#: ../../../specs/rocker.rst:824
msgid ""
"field                   width   description\n"
"----------------------------------------------------\n"
"OF_DPA_IN_PPORT         4       ingress physical port number\n"
"OF_DPA_IN_PPORT_MASK    4       ingress physical port number mask\n"
"OF_DPA_ETHERTYPE        2 (N)   ethertype\n"
"OF_DPA_VLAN_ID          2 (N)   vlan ID\n"
"OF_DPA_VLAN_ID_MASK     2 (N)   vlan ID mask\n"
"OF_DPA_VLAN_PCP         2 (N)   vlan Priority Code Point\n"
"OF_DPA_VLAN_PCP_MASK    2 (N)   vlan Priority Code Point mask\n"
"OF_DPA_SRC_MAC          6 (N)   source MAC\n"
"OF_DPA_SRC_MAC_MASK     6 (N)   source MAC mask\n"
"OF_DPA_DST_MAC          6 (N)   destination MAC\n"
"OF_DPA_DST_MAC_MASK     6 (N)   destination MAC mask\n"
"OF_DPA_TUNNEL_ID        4       tunnel ID\n"
"OF_DPA_SRC_IP           4 (N)   source IPv4. Optional,\n"
"                                can contain IPv4 address,\n"
"                                must be completely masked\n"
"                                if not used\n"
"OF_DPA_SRC_IP_MASK      4 (N)   IP Mask\n"
"OF_DPA_DST_IP           4 (N)   destination IPv4 address.\n"
"                                Must be multicast address\n"
"OF_DPA_DST_IP_MASK      4 (N)   IP Mask\n"
"OF_DPA_SRC_IPV6         16 (N)  source IPv6 Address. Optional.\n"
"                                Can contain IPv6 address,\n"
"                                must be completely masked\n"
"                                if not used\n"
"OF_DPA_SRC_IPV6_MASK    16 (N)  IPv6 mask\n"
"OF_DPA_DST_IPV6         16 (N)  destination IPv6 Address. Must\n"
"                                be multicast address.\n"
"OF_DPA_DST_IPV6_MASK    16 (N)  IPv6 mask\n"
"OF_DPA_SRC_ARP_IP       4 (N)   source IPv4 address in the ARP\n"
"                                payload.  Only used if ethertype\n"
"                                == 0x0806.\n"
"OF_DPA_SRC_ARP_IP_MASK  4 (N)   IP Mask\n"
"OF_DPA_IP_PROTO         1       IP protocol\n"
"OF_DPA_IP_PROTO_MASK    1       IP protocol mask\n"
"OF_DPA_IP_DSCP          1       DSCP\n"
"OF_DPA_IP_DSCP_MASK     1       DSCP mask\n"
"OF_DPA_IP_ECN           1       ECN\n"
"OF_DPA_IP_ECN_MASK              1       ECN mask\n"
"OF_DPA_L4_SRC_PORT      2 (N)   L4 source port, only for\n"
"                                TCP, UDP, or SCTP\n"
"OF_DPA_L4_SRC_PORT_MASK 2 (N)   L4 source port mask\n"
"OF_DPA_L4_DST_PORT      2 (N)   L4 source port, only for\n"
"                                TCP, UDP, or SCTP\n"
"OF_DPA_L4_DST_PORT_MASK 2 (N)   L4 source port mask\n"
"OF_DPA_ICMP_TYPE        1       ICMP type, only if IP\n"
"                                protocol is 1\n"
"OF_DPA_ICMP_TYPE_MASK   1       ICMP type mask\n"
"OF_DPA_ICMP_CODE        1       ICMP code\n"
"OF_DPA_ICMP_CODE_MASK   1       ICMP code mask\n"
"OF_DPA_IPV6_LABEL       4 (N)   IPv6 flow label\n"
"OF_DPA_IPV6_LABEL_MASK  4 (N)   IPv6 flow label mask\n"
"OF_DPA_GROUP_ID         4       data for GROUP action\n"
"OF_DPA_QUEUE_ID_ACTION  1       write the queue ID\n"
"OF_DPA_NEW_QUEUE_ID     1       queue ID\n"
"OF_DPA_VLAN_PCP_ACTION  1       write the VLAN priority\n"
"OF_DPA_NEW_VLAN_PCP     1       VLAN priority\n"
"OF_DPA_IP_DSCP_ACTION   1       write the DSCP\n"
"OF_DPA_NEW_IP_DSCP      1       new DSCP\n"
"OF_DPA_TUNNEL_LPORT     4       restrct to valid tunnel\n"
"                                logical port, set to 0\n"
"                                otherwise.\n"
"OF_DPA_OUT_PPORT        2       data for OUTPUT action,\n"
"                                restricted to CONTROLLER,\n"
"                                set to 0 otherwise\n"
"OF_DPA_CLEAR_ACTIONS    4       if 1 packets matching flow are\n"
"                                dropped (all other instructions\n"
"                                ignored)"
msgstr ""

#: ../../../specs/rocker.rst:894 ../../../specs/rocker.rst:973
msgid "TLVs for flow delete and get stats command are::"
msgstr ""

#: ../../../specs/rocker.rst:896
msgid ""
"field                   width   description\n"
"---------------------------------------------------\n"
"OF_DPA_CMD              2       CMD_[DEL|GET_STATS]\n"
"OF_DPA_COOKIE           8       Cookie"
msgstr ""

#: ../../../specs/rocker.rst:901 ../../../specs/rocker.rst:980
msgid ""
"On completion of get stats command, the descriptor buffer is written back "
"with the following TLVs::"
msgstr ""

#: ../../../specs/rocker.rst:904
msgid ""
"field                   width   description\n"
"---------------------------------------------------\n"
"OF_DPA_STAT_DURATION    4       Flow duration\n"
"OF_DPA_STAT_RX_PKTS     8       Received packets\n"
"OF_DPA_STAT_TX_PKTS     8       Transmit packets"
msgstr ""

#: ../../../specs/rocker.rst:912
msgid ""
"DESC_COMP_ERR   command                 reason\n"
"--------------------------------------------------------------------\n"
"0               all                     OK\n"
"-ROCKER_EFAULT  all                     head or tail index outside\n"
"                                        of ring\n"
"-ROCKER_ENXIO   all                     address or data read err on\n"
"                                        desc buf\n"
"-ROCKER_EMSGSIZE GET_STATS              cmd descriptor buffer wasn't\n"
"                                        big enough to contain write-back\n"
"                                        TLVs\n"
"-ROCKER_EINVAL  all                     invalid parameters passed in\n"
"-ROCKER_EEXIST  ADD                     entry already exists\n"
"-ROCKER_ENOSPC  ADD                     no space left in flow table\n"
"-ROCKER_ENOENT  MOD|DEL|GET_STATS       cookie invalid"
msgstr ""

#: ../../../specs/rocker.rst:928
msgid "Group Table Interface"
msgstr ""

#: ../../../specs/rocker.rst:930
msgid ""
"There are commands to add, modify, delete, and get stats of group table "
"entries.  The commands are issued using the DMA CMD descriptor ring.  The "
"following commands are defined::"
msgstr ""

#: ../../../specs/rocker.rst:934
msgid ""
"CMD_ADD:                add an entry to group table\n"
"CMD_MOD:                modify an entry in group table\n"
"CMD_DEL:                delete an entry from group table\n"
"CMD_GET_STATS:          get stats for group entry"
msgstr ""

#: ../../../specs/rocker.rst:941
msgid ""
"field                   width   description\n"
"-----------------------------------------------------------\n"
"FLOW_GROUP_CMD          2       CMD_[ADD|MOD]\n"
"FLOW_GROUP_ID           2       Flow group ID\n"
"FLOW_GROUP_TYPE         1       Group type:\n"
"                                  0: L2 interface\n"
"                                  1: L2 rewrite\n"
"                                  2: L3 unicast\n"
"                                  3: L2 multicast\n"
"                                  4: L2 flood\n"
"                                  5: L3 interface\n"
"                                  6: L3 multicast\n"
"                                  7: L3 ECMP\n"
"                                  8: L2 overlay\n"
"FLOW_VLAN_ID            2       Vlan ID (types 0, 3, 4, 6)\n"
"FLOW_L2_PORT            2       Port (types 0)\n"
"FLOW_INDEX              4       Index (all types but 0)\n"
"FLOW_OVERLAY_TYPE       1       Overlay sub-type (type 8):\n"
"                                  0: Flood unicast tunnel\n"
"                                  1: Flood multicast tunnel\n"
"                                  2: Multicast unicast tunnel\n"
"                                  3: Multicast multicast tunnel\n"
"FLOW_GROUP_ACTION               nest\n"
"  FLOW_GROUP_ID         2       next group ID in chain (all\n"
"                                types except 0)\n"
"  FLOW_OUT_PORT         4       egress port (types 0, 8)\n"
"  FLOW_POP_VLAN_TAG     1       strip outer VLAN tag (type 1\n"
"                                only)\n"
"  FLOW_VLAN_ID          2       (types 1, 5)\n"
"  FLOW_SRC_MAC          6       (types 1, 2, 5)\n"
"  FLOW_DST_MAC          6       (types 1, 2)"
msgstr ""

#: ../../../specs/rocker.rst:975
msgid ""
"field                   width   description\n"
"-----------------------------------------------------------\n"
"FLOW_GROUP_CMD          2       CMD_[DEL|GET_STATS]\n"
"FLOW_GROUP_ID           2       Flow group ID"
msgstr ""

#: ../../../specs/rocker.rst:983
msgid ""
"field                   width   description\n"
"---------------------------------------------------\n"
"FLOW_GROUP_ID           2       Flow group ID\n"
"FLOW_STAT_DURATION      4       Flow duration\n"
"FLOW_STAT_REF_COUNT     4       Flow reference count\n"
"FLOW_STAT_BUCKET_COUNT  4       Flow bucket count"
msgstr ""

#: ../../../specs/rocker.rst:992
msgid ""
"DESC_COMP_ERR   command                 reason\n"
"--------------------------------------------------------------------\n"
"0               all                     OK\n"
"-ROCKER_EFAULT  all                     head or tail index outside\n"
"                                        of ring\n"
"-ROCKER_ENXIO   all                     address or data read err on\n"
"                                        desc buf\n"
"-ROCKER_ENOSPC  GET_STATS               cmd descriptor buffer wasn't\n"
"                                        big enough to contain write-back\n"
"                                        TLVs\n"
"-ROCKER_EINVAL  ADD|MOD                 invalid parameters passed in\n"
"-ROCKER_EEXIST  ADD                     entry already exists\n"
"-ROCKER_ENOSPC  ADD                     no space left in flow table\n"
"-ROCKER_ENOENT  MOD|DEL|GET_STATS       group ID invalid\n"
"-ROCKER_EBUSY   DEL                     group reference count non-zero\n"
"-ROCKER_ENODEV  ADD                     next group ID doesn't exist"
msgstr ""

#: ../../../specs/rocker.rst:1012
msgid "References"
msgstr ""

#: ../../../specs/rocker.rst:1014
msgid ""
"[1] OpenFlow Data Plane Abstraction (OF-DPA) Abstract Switch Specification, "
"Version 1.0, from Broadcom Corporation, February 21, 2014."
msgstr ""
