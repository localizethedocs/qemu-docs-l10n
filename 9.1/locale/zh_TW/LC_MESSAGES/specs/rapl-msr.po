# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../specs/rapl-msr.rst:3
msgid "RAPL MSR support"
msgstr ""

#: ../../../specs/rapl-msr.rst:5
msgid ""
"The RAPL interface (Running Average Power Limit) is advertising the "
"accumulated energy consumption of various power domains (e.g. CPU packages, "
"DRAM, etc.)."
msgstr ""

#: ../../../specs/rapl-msr.rst:8
msgid ""
"The consumption is reported via MSRs (model specific registers) like "
"MSR_PKG_ENERGY_STATUS for the CPU package power domain. These MSRs are 64 "
"bits registers that represent the accumulated energy consumption in micro "
"Joules."
msgstr ""

#: ../../../specs/rapl-msr.rst:12
msgid ""
"Thanks to the MSR Filtering patch [#a]_ not all MSRs are handled by KVM. "
"Some of them can now be handled by the userspace (QEMU). It uses a mechanism "
"called \"MSR filtering\" where a list of MSRs is given at init time of a VM "
"to KVM so that a callback is put in place. The design of this patch uses "
"only this mechanism for handling the MSRs between guest/host."
msgstr ""

#: ../../../specs/rapl-msr.rst:18
msgid "At the moment the following MSRs are involved:"
msgstr ""

#: ../../../specs/rapl-msr.rst:20
msgid ""
"#define MSR_RAPL_POWER_UNIT             0x00000606\n"
"#define MSR_PKG_POWER_LIMIT             0x00000610\n"
"#define MSR_PKG_ENERGY_STATUS           0x00000611\n"
"#define MSR_PKG_POWER_INFO              0x00000614"
msgstr ""

#: ../../../specs/rapl-msr.rst:27
msgid ""
"The ``*_POWER_UNIT``, ``*_POWER_LIMIT``, ``*_POWER INFO`` are part of the "
"RAPL spec and specify the power limit of the package, provide range of "
"parameter(min power, max power,..) and also the information of the "
"multiplier for the energy counter to calculate the power. Those MSRs are "
"populated once at the beginning by reading the host CPU MSRs and are given "
"back to the guest 1:1 when requested."
msgstr ""

#: ../../../specs/rapl-msr.rst:34
msgid ""
"The MSR_PKG_ENERGY_STATUS is a counter; it represents the total amount of "
"energy consumed since the last time the register was cleared. If you "
"multiply it with the UNIT provided above you'll get the power in micro-"
"joules. This counter is always increasing and it increases more or less "
"faster depending on the consumption of the package. This counter is supposed "
"to overflow at some point."
msgstr ""

#: ../../../specs/rapl-msr.rst:41
msgid ""
"Each core belonging to the same Package reading the MSR_PKG_ENERGY_STATUS (i."
"e \"rdmsr 0x611\") will retrieve the same value. The value represents the "
"energy for the whole package. Whatever Core reading it will get the same "
"value and a core that belongs to PKG-0 will not be able to get the value of "
"PKG-1 and vice-versa."
msgstr ""

#: ../../../specs/rapl-msr.rst:48
msgid "High level implementation"
msgstr ""

#: ../../../specs/rapl-msr.rst:50
msgid ""
"In order to update the value of the virtual MSR, a QEMU thread is created. "
"The thread is basically just an infinity loop that does:"
msgstr ""

#: ../../../specs/rapl-msr.rst:53
msgid ""
"Snapshot of the time metrics of all QEMU threads (Time spent scheduled in "
"Userspace and System)"
msgstr ""

#: ../../../specs/rapl-msr.rst:56
msgid ""
"Snapshot of the actual MSR_PKG_ENERGY_STATUS counter of all packages where "
"the QEMU threads are running on."
msgstr ""

#: ../../../specs/rapl-msr.rst:59
msgid ""
"Sleep for 1 second - During this pause the vcpu and other non-vcpu threads "
"will do what they have to do and so the energy counter will increase."
msgstr ""

#: ../../../specs/rapl-msr.rst:62
msgid ""
"Repeat 2. and 3. and calculate the delta of every metrics representing the "
"time spent scheduled for each QEMU thread *and* the energy spent by the "
"packages during the pause."
msgstr ""

#: ../../../specs/rapl-msr.rst:66
msgid "Filter the vcpu threads and the non-vcpu threads."
msgstr ""

#: ../../../specs/rapl-msr.rst:68
msgid ""
"Retrieve the topology of the Virtual Machine. This helps identify which vCPU "
"is running on which virtual package."
msgstr ""

#: ../../../specs/rapl-msr.rst:71
msgid ""
"The total energy spent by the non-vcpu threads is divided by the number of "
"vcpu threads so that each vcpu thread will get an equal part of the energy "
"spent by the QEMU workers."
msgstr ""

#: ../../../specs/rapl-msr.rst:75
msgid "Calculate the ratio of energy spent per vcpu threads."
msgstr ""

#: ../../../specs/rapl-msr.rst:77
msgid "Calculate the energy for each virtual package."
msgstr ""

#: ../../../specs/rapl-msr.rst:79
msgid ""
"The virtual MSRs are updated for each virtual package. Each vCPU that "
"belongs to the same package will return the same value when accessing the "
"the MSR."
msgstr ""

#: ../../../specs/rapl-msr.rst:83
msgid "Loop back to 1."
msgstr ""

#: ../../../specs/rapl-msr.rst:86
msgid "Ratio calculation"
msgstr ""

#: ../../../specs/rapl-msr.rst:88
msgid ""
"In Linux, a process has an execution time associated with it. The scheduler "
"is dividing the time in clock ticks. The number of clock ticks per second "
"can be found by the sysconf system call. A typical value of clock ticks per "
"second is 100. So a core can run a process at the maximum of 100 ticks per "
"second. If a package has 4 cores, 400 ticks maximum can be scheduled on all "
"the cores of the package for a period of 1 second."
msgstr ""

#: ../../../specs/rapl-msr.rst:95
msgid ""
"The /proc/[pid]/stat [#b]_ is a sysfs file that can give the executed time "
"of a process with the [pid] as the process ID. It gives the amount of ticks "
"the process has been scheduled in userspace (utime) and kernel space (stime)."
msgstr ""

#: ../../../specs/rapl-msr.rst:99
msgid ""
"By reading those metrics for a thread, one can calculate the ratio of time "
"the package has spent executing the thread."
msgstr ""

#: ../../../specs/rapl-msr.rst:102
msgid "Example:"
msgstr ""

#: ../../../specs/rapl-msr.rst:104
msgid ""
"A 4 cores package can schedule a maximum of 400 ticks per second with 100 "
"ticks per second per core. If a thread was scheduled for 100 ticks between a "
"second on this package, that means my thread has been scheduled for 1/4 of "
"the whole package. With that, the calculation of the energy spent by the "
"thread on this package during this whole second is 1/4 of the total energy "
"spent by the package."
msgstr ""

#: ../../../specs/rapl-msr.rst:112
msgid "Usage"
msgstr ""

#: ../../../specs/rapl-msr.rst:114
msgid ""
"Currently this feature is only working on an Intel CPU that has the RAPL "
"driver mounted and available in the sysfs. if not, QEMU fails at start-up."
msgstr ""

#: ../../../specs/rapl-msr.rst:117
msgid ""
"This feature is activated with -accel kvm,rapl=true,rapl-helper-socket=/path/"
"sock.sock"
msgstr ""

#: ../../../specs/rapl-msr.rst:120
msgid ""
"It is important that the socket path is the same as the one :program:`qemu-"
"vmsr-helper` is listening to."
msgstr ""

#: ../../../specs/rapl-msr.rst:124
msgid "qemu-vmsr-helper"
msgstr ""

#: ../../../specs/rapl-msr.rst:126
msgid ""
"The qemu-vmsr-helper is working very much like the qemu-pr-helper. Instead "
"of making persistent reservation, qemu-vmsr-helper is here to overcome the "
"CVE-2020-8694 which remove user access to the rapl msr attributes."
msgstr ""

#: ../../../specs/rapl-msr.rst:130
msgid ""
"A socket communication is established between QEMU processes that has the "
"RAPL MSR support activated and the qemu-vmsr-helper. A systemd service and "
"socket activation is provided in contrib/systemd/qemu-vmsr-helper.(service/"
"socket)."
msgstr ""

#: ../../../specs/rapl-msr.rst:134
msgid ""
"The systemd socket uses 600, like contrib/systemd/qemu-pr-helper.socket. The "
"socket can be passed via SCM_RIGHTS by libvirt, or its permissions can be "
"changed (e.g. 660 and root:kvm for a Debian system for example). Libvirt "
"could also start a separate helper if needed. All in all, the policy is left "
"to the user."
msgstr ""

#: ../../../specs/rapl-msr.rst:140
msgid "See the qemu-pr-helper documentation or manpage for further details."
msgstr ""

#: ../../../specs/rapl-msr.rst:143
msgid "Current Limitations"
msgstr ""

#: ../../../specs/rapl-msr.rst:145
msgid ""
"Works only on Intel host CPUs because AMD CPUs are using different MSR "
"addresses."
msgstr ""

#: ../../../specs/rapl-msr.rst:148
msgid ""
"Only the Package Power-Plane (MSR_PKG_ENERGY_STATUS) is reported at the "
"moment."
msgstr ""

#: ../../../specs/rapl-msr.rst:152
msgid "References"
msgstr ""

#: ../../../specs/rapl-msr.rst:154
msgid ""
"https://patchwork.kernel.org/project/kvm/patch/20200916202951.23760-7-"
"graf@amazon.com/"
msgstr ""

#: ../../../specs/rapl-msr.rst:155
msgid "https://man7.org/linux/man-pages/man5/proc.5.html"
msgstr ""
