# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:38+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/writing-monitor-commands.rst:2
msgid "How to write monitor commands"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:4
msgid ""
"This document is a step-by-step guide on how to write new QMP commands using "
"the QAPI framework and HMP commands."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:7
msgid ""
"This document doesn't discuss QMP protocol level details, nor does it dive "
"into the QAPI framework implementation."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:10
msgid ""
"For an in-depth introduction to the QAPI framework, please refer to docs/"
"devel/qapi-code-gen.txt. For documentation about the QMP protocol, start "
"with docs/interop/qmp-intro.txt."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:14
msgid ""
"New commands may be implemented in QMP only.  New HMP commands should be "
"implemented on top of QMP.  The typical HMP command wraps around an "
"equivalent QMP command, but HMP convenience commands built from QMP building "
"blocks are also fine.  The long term goal is to make all existing HMP "
"commands conform to this, to fully isolate HMP from the internals of QEMU. "
"Refer to the `Writing a debugging aid returning unstructured text`_ section "
"for further guidance on commands that would have traditionally been HMP only."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:24
msgid "Overview"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:26
msgid ""
"Generally speaking, the following steps should be taken in order to write a "
"new QMP command."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:29
msgid ""
"Define the command and any types it needs in the appropriate QAPI schema "
"module."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:32
msgid ""
"Write the QMP command itself, which is a regular C function. Preferably, the "
"command should be exported by some QEMU subsystem. But it can also be added "
"to the monitor/qmp-cmds.c file"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:36
msgid "At this point the command can be tested under the QMP protocol"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:38
msgid ""
"Write the HMP command equivalent. This is not required and should only be "
"done if it does make sense to have the functionality in HMP. The HMP command "
"is implemented in terms of the QMP command"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:42
msgid ""
"The following sections will demonstrate each of the steps above. We will "
"start very simple and get more complex as we progress."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:47
msgid "Testing"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:49
msgid ""
"For all the examples in the next sections, the test setup is the same and is "
"shown here."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:52
msgid "First, QEMU should be started like this::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:54
msgid ""
"# qemu-system-TARGET [...] \\\n"
"    -chardev socket,id=qmp,port=4444,host=localhost,server=on \\\n"
"    -mon chardev=qmp,mode=control,pretty=on"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:58
msgid "Then, in a different terminal::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:60
msgid ""
"$ telnet localhost 4444\n"
"Trying 127.0.0.1...\n"
"Connected to localhost.\n"
"Escape character is '^]'.\n"
"{\n"
"    \"QMP\": {\n"
"        \"version\": {\n"
"            \"qemu\": {\n"
"                \"micro\": 50,\n"
"                \"minor\": 15,\n"
"                \"major\": 0\n"
"            },\n"
"            \"package\": \"\"\n"
"        },\n"
"        \"capabilities\": [\n"
"        ]\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:79
msgid ""
"The above output is the QMP server saying you're connected. The server is "
"actually in capabilities negotiation mode. To enter in command mode type::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:82
msgid "{ \"execute\": \"qmp_capabilities\" }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:84
msgid "Then the server should respond::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:86
msgid ""
"{\n"
"    \"return\": {\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:91
msgid ""
"Which is QMP's way of saying \"the latest command executed OK and didn't "
"return any data\". Now you're ready to enter the QMP example commands as "
"explained in the following sections."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:97
msgid "Writing a simple command: hello-world"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:99
msgid ""
"That's the most simple QMP command that can be written. Usually, this kind "
"of command carries some meaningful action in QEMU but here it will just "
"print \"Hello, world\" to the standard output."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:103
msgid ""
"Our command will be called \"hello-world\". It takes no arguments, nor does "
"it return any data."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:106
msgid ""
"The first step is defining the command in the appropriate QAPI schema "
"module.  We pick module qapi/misc.json, and add the following line at the "
"bottom::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:110
msgid "{ 'command': 'hello-world' }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:112
msgid ""
"The \"command\" keyword defines a new QMP command. It's an JSON object. All "
"schema entries are JSON objects. The line above will instruct the QAPI to "
"generate any prototypes and the necessary code to marshal and unmarshal "
"protocol data."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:117
msgid ""
"The next step is to write the \"hello-world\" implementation. As explained "
"earlier, it's preferable for commands to live in QEMU subsystems. But "
"\"hello-world\" doesn't pertain to any, so we put its implementation in "
"monitor/qmp-cmds.c::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:122
msgid ""
"void qmp_hello_world(Error **errp)\n"
"{\n"
"    printf(\"Hello, world!\\n\");\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:127
msgid "There are a few things to be noticed:"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:129
msgid "QMP command implementation functions must be prefixed with \"qmp\\_\""
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:130
msgid ""
"qmp_hello_world() returns void, this is in accordance with the fact that the "
"command doesn't return any data"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:132
msgid ""
"It takes an \"Error \\*\\*\" argument. This is required. Later we will see "
"how to return errors and take additional arguments. The Error argument "
"should not be touched if the command doesn't return errors"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:135
msgid ""
"We won't add the function's prototype. That's automatically done by the QAPI"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:136
msgid ""
"Printing to the terminal is discouraged for QMP commands, we do it here "
"because it's the easiest way to demonstrate a QMP command"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:139
msgid ""
"You're done. Now build qemu, run it as suggested in the \"Testing\" section, "
"and then type the following QMP command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:142
msgid "{ \"execute\": \"hello-world\" }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:144
msgid ""
"Then check the terminal running qemu and look for the \"Hello, world\" "
"string. If you don't see it then something went wrong."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:149
msgid "Arguments"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:151
msgid ""
"Let's add an argument called \"message\" to our \"hello-world\" command. The "
"new argument will contain the string to be printed to stdout. It's an "
"optional argument, if it's not present we print our default \"Hello, World\" "
"string."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:155
msgid ""
"The first change we have to do is to modify the command specification in the "
"schema file to the following::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:158
msgid "{ 'command': 'hello-world', 'data': { '*message': 'str' } }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:160
msgid ""
"Notice the new 'data' member in the schema. It's an JSON object whose each "
"element is an argument to the command in question. Also notice the asterisk, "
"it's used to mark the argument optional (that means that you shouldn't use "
"it for mandatory arguments). Finally, 'str' is the argument's type, which "
"stands for \"string\". The QAPI also supports integers, booleans, "
"enumerations and user defined types."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:167
msgid "Now, let's update our C implementation in monitor/qmp-cmds.c::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:169
msgid ""
"void qmp_hello_world(bool has_message, const char *message, Error **errp)\n"
"{\n"
"    if (has_message) {\n"
"        printf(\"%s\\n\", message);\n"
"    } else {\n"
"        printf(\"Hello, world\\n\");\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:178
msgid "There are two important details to be noticed:"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:180
msgid ""
"All optional arguments are accompanied by a 'has\\_' boolean, which is set "
"if the optional argument is present or false otherwise"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:182
msgid ""
"The C implementation signature must follow the schema's argument ordering, "
"which is defined by the \"data\" member"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:185
msgid ""
"Time to test our new version of the \"hello-world\" command. Build qemu, run "
"it as described in the \"Testing\" section and then send two commands::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:188
msgid ""
"{ \"execute\": \"hello-world\" }\n"
"{\n"
"    \"return\": {\n"
"    }\n"
"}\n"
"\n"
"{ \"execute\": \"hello-world\", \"arguments\": { \"message\": \"We love "
"qemu\" } }\n"
"{\n"
"    \"return\": {\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:200
msgid ""
"You should see \"Hello, world\" and \"We love qemu\" in the terminal running "
"qemu, if you don't see these strings, then something went wrong."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:205
msgid "Errors"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:207
msgid ""
"QMP commands should use the error interface exported by the error.h header "
"file. Basically, most errors are set by calling the error_setg() function."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:210
msgid ""
"Let's say we don't accept the string \"message\" to contain the word "
"\"love\". If it does contain it, we want the \"hello-world\" command to "
"return an error::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:213
msgid ""
"void qmp_hello_world(bool has_message, const char *message, Error **errp)\n"
"{\n"
"    if (has_message) {\n"
"        if (strstr(message, \"love\")) {\n"
"            error_setg(errp, \"the word 'love' is not allowed\");\n"
"            return;\n"
"        }\n"
"        printf(\"%s\\n\", message);\n"
"    } else {\n"
"        printf(\"Hello, world\\n\");\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:226
msgid ""
"The first argument to the error_setg() function is the Error pointer to "
"pointer, which is passed to all QMP functions. The next argument is a human "
"description of the error, this is a free-form printf-like string."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:230
msgid ""
"Let's test the example above. Build qemu, run it as defined in the "
"\"Testing\" section, and then issue the following command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:233
msgid ""
"{ \"execute\": \"hello-world\", \"arguments\": { \"message\": \"all you need "
"is love\" } }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:235
msgid "The QMP server's response should be::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:237
msgid ""
"{\n"
"    \"error\": {\n"
"        \"class\": \"GenericError\",\n"
"        \"desc\": \"the word 'love' is not allowed\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:244
msgid ""
"Note that error_setg() produces a \"GenericError\" class.  In general, all "
"QMP errors should have that error class.  There are two exceptions to this "
"rule:"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:248
msgid ""
"To support a management application's need to recognize a specific error for "
"special handling"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:251
msgid "Backward compatibility"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:253
msgid ""
"If the failure you want to report falls into one of the two cases above, use "
"error_set() with a second argument of an ErrorClass value."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:258
msgid "Command Documentation"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:260
msgid ""
"There's only one step missing to make \"hello-world\"'s implementation "
"complete, and that's its documentation in the schema file."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:263
msgid ""
"There are many examples of such documentation in the schema file already, "
"but here goes \"hello-world\"'s new entry for qapi/misc.json::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:266
msgid ""
"##\n"
"# @hello-world:\n"
"#\n"
"# Print a client provided string to the standard output stream.\n"
"#\n"
"# @message: string to be printed\n"
"#\n"
"# Returns: Nothing on success.\n"
"#\n"
"# Notes: if @message is not provided, the \"Hello, world\" string will\n"
"#        be printed instead\n"
"#\n"
"# Since: <next qemu stable release, eg. 1.0>\n"
"##\n"
"{ 'command': 'hello-world', 'data': { '*message': 'str' } }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:282
msgid ""
"Please, note that the \"Returns\" clause is optional if a command doesn't "
"return any data nor any errors."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:287
#: ../../../devel/writing-monitor-commands.rst:703
msgid "Implementing the HMP command"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:289
msgid ""
"Now that the QMP command is in place, we can also make it available in the "
"human monitor (HMP)."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:292
msgid ""
"With the introduction of the QAPI, HMP commands make QMP calls. Most of the "
"time HMP commands are simple wrappers. All HMP commands implementation exist "
"in the monitor/hmp-cmds.c file."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:296
msgid "Here's the implementation of the \"hello-world\" HMP command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:298
msgid ""
"void hmp_hello_world(Monitor *mon, const QDict *qdict)\n"
"{\n"
"    const char *message = qdict_get_try_str(qdict, \"message\");\n"
"    Error *err = NULL;\n"
"\n"
"    qmp_hello_world(!!message, message, &err);\n"
"    if (hmp_handle_error(mon, err)) {\n"
"        return;\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:309
#: ../../../devel/writing-monitor-commands.rst:722
msgid "Also, you have to add the function's prototype to the hmp.h file."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:311
msgid "There are three important points to be noticed:"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:313
msgid ""
"The \"mon\" and \"qdict\" arguments are mandatory for all HMP functions. The "
"former is the monitor object. The latter is how the monitor passes arguments "
"entered by the user to the command implementation"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:316
msgid ""
"hmp_hello_world() performs error checking. In this example we just call "
"hmp_handle_error() which prints a message to the user, but we could do more, "
"like taking different actions depending on the error qmp_hello_world() "
"returns"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:320
msgid ""
"The \"err\" variable must be initialized to NULL before performing the QMP "
"call"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:323
msgid ""
"There's one last step to actually make the command available to monitor "
"users, we should add it to the hmp-commands.hx file::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:326
msgid ""
"   {\n"
"       .name       = \"hello-world\",\n"
"       .args_type  = \"message:s?\",\n"
"       .params     = \"hello-world [message]\",\n"
"       .help       = \"Print message to the standard output\",\n"
"       .cmd        = hmp_hello_world,\n"
"   },\n"
"\n"
"SRST\n"
"``hello_world`` *message*\n"
"  Print message to the standard output\n"
"ERST"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:339
msgid ""
"To test this you have to open a user monitor and issue the \"hello-world\" "
"command. It might be instructive to check the command's documentation with "
"HMP's \"help\" command."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:343
msgid ""
"Please, check the \"-monitor\" command-line option to know how to open a "
"user monitor."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:348
msgid "Writing more complex commands"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:350
msgid ""
"A QMP command is capable of returning any data the QAPI supports like "
"integers, strings, booleans, enumerations and user defined types."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:353
msgid ""
"In this section we will focus on user defined types. Please, check the QAPI "
"documentation for information about the other types."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:358
msgid "Modelling data in QAPI"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:360
msgid ""
"For a QMP command that to be considered stable and supported long term, "
"there is a requirement returned data should be explicitly modelled using "
"fine-grained QAPI types. As a general guide, a caller of the QMP command "
"should never need to parse individual returned data fields. If a field "
"appears to need parsing, then it should be split into separate fields "
"corresponding to each distinct data item. This should be the common case for "
"any new QMP command that is intended to be used by machines, as opposed to "
"exclusively human operators."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:369
msgid ""
"Some QMP commands, however, are only intended as ad hoc debugging aids for "
"human operators. While they may return large amounts of formatted data, it "
"is not expected that machines will need to parse the result. The overhead of "
"defining a fine grained QAPI type for the data may not be justified by the "
"potential benefit. In such cases, it is permitted to have a command return a "
"simple string that contains formatted data, however, it is mandatory for the "
"command to use the 'x-' name prefix. This indicates that the command is not "
"guaranteed to be long term stable / liable to change in future and is not "
"following QAPI design best practices. An example where this approach is "
"taken is the QMP command \"x-query-registers\". This returns a formatted "
"dump of the architecture specific CPU state. The way the data is formatted "
"varies across QEMU targets, is liable to change over time, and is only "
"intended to be consumed as an opaque string by machines. Refer to the "
"`Writing a debugging aid returning unstructured text`_ section for an "
"illustration."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:387
msgid "User Defined Types"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:389
msgid "FIXME This example needs to be redone after commit 6d32717"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:391
msgid ""
"For this example we will write the query-alarm-clock command, which returns "
"information about QEMU's timer alarm. For more information about it, please "
"check the \"-clock\" command-line option."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:395
msgid ""
"We want to return two pieces of information. The first one is the alarm "
"clock's name. The second one is when the next alarm will fire. The former "
"information is returned as a string, the latter is an integer in nanoseconds "
"(which is not very useful in practice, as the timer has probably already "
"fired when the information reaches the client)."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:401
msgid ""
"The best way to return that data is to create a new QAPI type, as shown "
"below::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:403
msgid ""
"##\n"
"# @QemuAlarmClock\n"
"#\n"
"# QEMU alarm clock information.\n"
"#\n"
"# @clock-name: The alarm clock method's name.\n"
"#\n"
"# @next-deadline: The time (in nanoseconds) the next alarm will fire.\n"
"#\n"
"# Since: 1.0\n"
"##\n"
"{ 'type': 'QemuAlarmClock',\n"
"  'data': { 'clock-name': 'str', '*next-deadline': 'int' } }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:417
msgid ""
"The \"type\" keyword defines a new QAPI type. Its \"data\" member contains "
"the type's members. In this example our members are the \"clock-name\" and "
"the \"next-deadline\" one, which is optional."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:421
msgid "Now let's define the query-alarm-clock command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:423
msgid ""
"##\n"
"# @query-alarm-clock\n"
"#\n"
"# Return information about QEMU's alarm clock.\n"
"#\n"
"# Returns a @QemuAlarmClock instance describing the alarm clock method\n"
"# being currently used by QEMU (this is usually set by the '-clock'\n"
"# command-line option).\n"
"#\n"
"# Since: 1.0\n"
"##\n"
"{ 'command': 'query-alarm-clock', 'returns': 'QemuAlarmClock' }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:436
msgid ""
"Notice the \"returns\" keyword. As its name suggests, it's used to define "
"the data returned by a command."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:439
msgid ""
"It's time to implement the qmp_query_alarm_clock() function, you can put it "
"in the qemu-timer.c file::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:442
msgid ""
"QemuAlarmClock *qmp_query_alarm_clock(Error **errp)\n"
"{\n"
"    QemuAlarmClock *clock;\n"
"    int64_t deadline;\n"
"\n"
"    clock = g_malloc0(sizeof(*clock));\n"
"\n"
"    deadline = qemu_next_alarm_deadline();\n"
"    if (deadline > 0) {\n"
"        clock->has_next_deadline = true;\n"
"        clock->next_deadline = deadline;\n"
"    }\n"
"    clock->clock_name = g_strdup(alarm_timer->name);\n"
"\n"
"    return clock;\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:459
msgid "There are a number of things to be noticed:"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:461
msgid ""
"The QemuAlarmClock type is automatically generated by the QAPI framework, "
"its members correspond to the type's specification in the schema file"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:463
msgid ""
"As specified in the schema file, the function returns a QemuAlarmClock "
"instance and takes no arguments (besides the \"errp\" one, which is "
"mandatory for all QMP functions)"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:466
msgid ""
"The \"clock\" variable (which will point to our QAPI type instance) is "
"allocated by the regular g_malloc0() function. Note that we chose to "
"initialize the memory to zero. This is recommended for all QAPI types, as it "
"helps avoiding bad surprises (specially with booleans)"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:470
msgid ""
"Remember that \"next_deadline\" is optional? All optional members have a "
"'has_TYPE_NAME' member that should be properly set by the implementation, as "
"shown above"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:473
msgid ""
"Even static strings, such as \"alarm_timer->name\", should be dynamically "
"allocated by the implementation. This is so because the QAPI also generates "
"a function to free its types and it cannot distinguish between dynamically "
"or statically allocated strings"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:477
msgid "You have to include \"qapi/qapi-commands-misc.h\" in qemu-timer.c"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:479
msgid ""
"Time to test the new command. Build qemu, run it as described in the "
"\"Testing\" section and try this::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:482
msgid ""
"{ \"execute\": \"query-alarm-clock\" }\n"
"{\n"
"    \"return\": {\n"
"        \"next-deadline\": 2368219,\n"
"        \"clock-name\": \"dynticks\"\n"
"    }\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:492
msgid "The HMP command"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:494
msgid "Here's the HMP counterpart of the query-alarm-clock command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:496
msgid ""
"void hmp_info_alarm_clock(Monitor *mon)\n"
"{\n"
"    QemuAlarmClock *clock;\n"
"    Error *err = NULL;\n"
"\n"
"    clock = qmp_query_alarm_clock(&err);\n"
"    if (hmp_handle_error(mon, err)) {\n"
"        return;\n"
"    }\n"
"\n"
"    monitor_printf(mon, \"Alarm clock method in use: '%s'\\n\", clock-"
">clock_name);\n"
"    if (clock->has_next_deadline) {\n"
"        monitor_printf(mon, \"Next alarm will fire in %\" PRId64 \" "
"nanoseconds\\n\",\n"
"                       clock->next_deadline);\n"
"    }\n"
"\n"
"   qapi_free_QemuAlarmClock(clock);\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:515
msgid ""
"It's important to notice that hmp_info_alarm_clock() calls "
"qapi_free_QemuAlarmClock() to free the data returned by "
"qmp_query_alarm_clock(). For user defined types, the QAPI will generate a "
"qapi_free_QAPI_TYPE_NAME() function and that's what you have to use to free "
"the types you define and qapi_free_QAPI_TYPE_NAMEList() for list types "
"(explained in the next section). If the QMP call returns a string, then you "
"should g_free() to free it."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:522
msgid ""
"Also note that hmp_info_alarm_clock() performs error handling. That's not "
"strictly required if you're sure the QMP function doesn't return errors, but "
"it's good practice to always check for errors."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:526
msgid ""
"Another important detail is that HMP's \"info\" commands don't go into the "
"hmp-commands.hx. Instead, they go into the info_cmds[] table, which is "
"defined in the monitor/misc.c file. The entry for the \"info alarmclock\" "
"follows::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:530
msgid ""
"{\n"
"    .name       = \"alarmclock\",\n"
"    .args_type  = \"\",\n"
"    .params     = \"\",\n"
"    .help       = \"show information about the alarm clock\",\n"
"    .cmd        = hmp_info_alarm_clock,\n"
"},"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:538
msgid ""
"To test this, run qemu and type \"info alarmclock\" in the user monitor."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:542
msgid "Returning Lists"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:544
msgid ""
"For this example, we're going to return all available methods for the timer "
"alarm, which is pretty much what the command-line option \"-clock ?\" does, "
"except that we're also going to inform which method is in use."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:548
msgid "This first step is to define a new type::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:550
msgid ""
"##\n"
"# @TimerAlarmMethod\n"
"#\n"
"# Timer alarm method information.\n"
"#\n"
"# @method-name: The method's name.\n"
"#\n"
"# @current: true if this alarm method is currently in use, false otherwise\n"
"#\n"
"# Since: 1.0\n"
"##\n"
"{ 'type': 'TimerAlarmMethod',\n"
"  'data': { 'method-name': 'str', 'current': 'bool' } }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:564
msgid ""
"The command will be called \"query-alarm-methods\", here is its schema "
"specification::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:567
msgid ""
"##\n"
"# @query-alarm-methods\n"
"#\n"
"# Returns information about available alarm methods.\n"
"#\n"
"# Returns: a list of @TimerAlarmMethod for each method\n"
"#\n"
"# Since: 1.0\n"
"##\n"
"{ 'command': 'query-alarm-methods', 'returns': ['TimerAlarmMethod'] }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:578
msgid ""
"Notice the syntax for returning lists \"'returns': ['TimerAlarmMethod']\", "
"this should be read as \"returns a list of TimerAlarmMethod instances\"."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:581
msgid "The C implementation follows::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:583
msgid ""
"TimerAlarmMethodList *qmp_query_alarm_methods(Error **errp)\n"
"{\n"
"    TimerAlarmMethodList *method_list = NULL;\n"
"    const struct qemu_alarm_timer *p;\n"
"    bool current = true;\n"
"\n"
"    for (p = alarm_timers; p->name; p++) {\n"
"        TimerAlarmMethod *value = g_malloc0(*value);\n"
"        value->method_name = g_strdup(p->name);\n"
"        value->current = current;\n"
"        QAPI_LIST_PREPEND(method_list, value);\n"
"        current = false;\n"
"    }\n"
"\n"
"    return method_list;\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:600
msgid ""
"The most important difference from the previous examples is the "
"TimerAlarmMethodList type, which is automatically generated by the QAPI from "
"the TimerAlarmMethod type."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:604
msgid ""
"Each list node is represented by a TimerAlarmMethodList instance. We have to "
"allocate it, and that's done inside the for loop: the \"info\" pointer "
"points to an allocated node. We also have to allocate the node's contents, "
"which is stored in its \"value\" member. In our example, the \"value\" "
"member is a pointer to an TimerAlarmMethod instance."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:610
msgid ""
"Notice that the \"current\" variable is used as \"true\" only in the first "
"iteration of the loop. That's because the alarm timer method in use is the "
"first element of the alarm_timers array. Also notice that QAPI lists are "
"handled by hand and we return the head of the list."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:615
msgid ""
"Now Build qemu, run it as explained in the \"Testing\" section and try our "
"new command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:618
msgid ""
"{ \"execute\": \"query-alarm-methods\" }\n"
"{\n"
"    \"return\": [\n"
"        {\n"
"            \"current\": false,\n"
"            \"method-name\": \"unix\"\n"
"        },\n"
"        {\n"
"            \"current\": true,\n"
"            \"method-name\": \"dynticks\"\n"
"        }\n"
"    ]\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:632
msgid ""
"The HMP counterpart is a bit more complex than previous examples because it "
"has to traverse the list, it's shown below for reference::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:635
msgid ""
"void hmp_info_alarm_methods(Monitor *mon)\n"
"{\n"
"    TimerAlarmMethodList *method_list, *method;\n"
"    Error *err = NULL;\n"
"\n"
"    method_list = qmp_query_alarm_methods(&err);\n"
"    if (hmp_handle_error(mon, err)) {\n"
"        return;\n"
"    }\n"
"\n"
"    for (method = method_list; method; method = method->next) {\n"
"        monitor_printf(mon, \"%c %s\\n\", method->value->current ? '*' : ' "
"',\n"
"                                       method->value->method_name);\n"
"    }\n"
"\n"
"    qapi_free_TimerAlarmMethodList(method_list);\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:654
msgid "Writing a debugging aid returning unstructured text"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:656
msgid ""
"As discussed in section `Modelling data in QAPI`_, it is required that "
"commands expecting machine usage be using fine-grained QAPI data types. The "
"exception to this rule applies when the command is solely intended as a "
"debugging aid and allows for returning unstructured text. This is commonly "
"needed for query commands that report aspects of QEMU's internal state that "
"are useful to human operators."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:663
msgid ""
"In this example we will consider a simplified variant of the HMP command "
"``info roms``. Following the earlier rules, this command will need to live "
"under the ``x-`` name prefix, so its QMP implementation will be called ``x-"
"query-roms``. It will have no parameters and will return a single text "
"string::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:669
msgid ""
"{ 'struct': 'HumanReadableText',\n"
"  'data': { 'human-readable-text': 'str' } }\n"
"\n"
"{ 'command': 'x-query-roms',\n"
"  'returns': 'HumanReadableText' }"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:675
msgid ""
"The ``HumanReadableText`` struct is intended to be used for all commands, "
"under the ``x-`` name prefix that are returning unstructured text targeted "
"at humans. It should never be used for commands outside the ``x-`` name "
"prefix, as those should be using structured QAPI types."
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:681
msgid "Implementing the QMP command"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:683
msgid ""
"The QMP implementation will typically involve creating a ``GString`` object "
"and printing formatted data into it::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:686
msgid ""
"HumanReadableText *qmp_x_query_roms(Error **errp)\n"
"{\n"
"    g_autoptr(GString) buf = g_string_new(\"\");\n"
"    Rom *rom;\n"
"\n"
"    QTAILQ_FOREACH(rom, &roms, next) {\n"
"       g_string_append_printf(\"%s size=0x%06zx name=\\\"%s\\\"\\n\",\n"
"                              memory_region_name(rom->mr),\n"
"                              rom->romsize,\n"
"                              rom->name);\n"
"    }\n"
"\n"
"    return human_readable_text_from_str(buf);\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:705
msgid ""
"Now that the QMP command is in place, we can also make it available in the "
"human monitor (HMP) as shown in previous examples. The HMP implementations "
"will all look fairly similar, as all they need do is invoke the QMP command "
"and then print the resulting text or error message. Here's the "
"implementation of the \"info roms\" HMP command::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:711
msgid ""
"void hmp_info_roms(Monitor *mon, const QDict *qdict)\n"
"{\n"
"    Error err = NULL;\n"
"    g_autoptr(HumanReadableText) info = qmp_x_query_roms(&err);\n"
"\n"
"    if (hmp_handle_error(mon, err)) {\n"
"        return;\n"
"    }\n"
"    monitor_puts(mon, info->human_readable_text);\n"
"}"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:724
msgid ""
"There's one last step to actually make the command available to monitor "
"users, we should add it to the hmp-commands-info.hx file::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:727
msgid ""
"{\n"
"    .name       = \"roms\",\n"
"    .args_type  = \"\",\n"
"    .params     = \"\",\n"
"    .help       = \"show roms\",\n"
"    .cmd        = hmp_info_roms,\n"
"},"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:735
msgid ""
"The case of writing a HMP info handler that calls a no-parameter QMP query "
"command is quite common. To simplify the implementation there is a general "
"purpose HMP info handler for this scenario. All that is required to expose a "
"no-parameter QMP query command via HMP is to declare it using the '."
"cmd_info_hrt' field to point to the QMP handler, and leave the '.cmd' field "
"NULL::"
msgstr ""

#: ../../../devel/writing-monitor-commands.rst:742
msgid ""
"{\n"
"    .name         = \"roms\",\n"
"    .args_type    = \"\",\n"
"    .params       = \"\",\n"
"    .help         = \"show roms\",\n"
"    .cmd_info_hrt = qmp_x_query_roms,\n"
"},"
msgstr ""
