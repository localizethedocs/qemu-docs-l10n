# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:38+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/loads-stores.rst:7
msgid "Load and Store APIs"
msgstr ""

#: ../../../devel/loads-stores.rst:9
msgid ""
"QEMU internally has multiple families of functions for performing loads and "
"stores. This document attempts to enumerate them all and indicate when to "
"use them. It does not provide detailed documentation of each API -- for that "
"you should look at the documentation comments in the relevant header files."
msgstr ""

#: ../../../devel/loads-stores.rst:17
msgid "``ld*_p and st*_p``"
msgstr ""

#: ../../../devel/loads-stores.rst:19
msgid ""
"These functions operate on a host pointer, and should be used when you "
"already have a pointer into host memory (corresponding to guest ram or a "
"local buffer). They deal with doing accesses with the desired endianness and "
"with correctly handling potentially unaligned pointer values."
msgstr ""

#: ../../../devel/loads-stores.rst:25 ../../../devel/loads-stores.rst:104
#: ../../../devel/loads-stores.rst:133 ../../../devel/loads-stores.rst:171
#: ../../../devel/loads-stores.rst:210 ../../../devel/loads-stores.rst:251
#: ../../../devel/loads-stores.rst:280
msgid "Function names follow the pattern:"
msgstr ""

#: ../../../devel/loads-stores.rst:27
msgid "load: ``ld{sign}{size}_{endian}_p(ptr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:29
msgid "store: ``st{size}_{endian}_p(ptr, val)``"
msgstr ""

#: ../../../devel/loads-stores.rst:31 ../../../devel/loads-stores.rst:139
#: ../../../devel/loads-stores.rst:177 ../../../devel/loads-stores.rst:216
#: ../../../devel/loads-stores.rst:255 ../../../devel/loads-stores.rst:286
#: ../../../devel/loads-stores.rst:326 ../../../devel/loads-stores.rst:381
#: ../../../devel/loads-stores.rst:437 ../../../devel/loads-stores.rst:537
msgid "``sign``"
msgstr ""

#: ../../../devel/loads-stores.rst:32 ../../../devel/loads-stores.rst:140
#: ../../../devel/loads-stores.rst:178 ../../../devel/loads-stores.rst:217
#: ../../../devel/loads-stores.rst:256 ../../../devel/loads-stores.rst:287
#: ../../../devel/loads-stores.rst:327 ../../../devel/loads-stores.rst:382
#: ../../../devel/loads-stores.rst:438 ../../../devel/loads-stores.rst:538
msgid "(empty) : for 32 or 64 bit sizes"
msgstr ""

#: ../../../devel/loads-stores.rst:33 ../../../devel/loads-stores.rst:141
#: ../../../devel/loads-stores.rst:179 ../../../devel/loads-stores.rst:218
#: ../../../devel/loads-stores.rst:257 ../../../devel/loads-stores.rst:288
#: ../../../devel/loads-stores.rst:328 ../../../devel/loads-stores.rst:383
#: ../../../devel/loads-stores.rst:439 ../../../devel/loads-stores.rst:539
msgid "``u`` : unsigned"
msgstr ""

#: ../../../devel/loads-stores.rst:34 ../../../devel/loads-stores.rst:142
#: ../../../devel/loads-stores.rst:180 ../../../devel/loads-stores.rst:219
#: ../../../devel/loads-stores.rst:258 ../../../devel/loads-stores.rst:289
#: ../../../devel/loads-stores.rst:329
msgid "``s`` : signed"
msgstr ""

#: ../../../devel/loads-stores.rst:36 ../../../devel/loads-stores.rst:110
#: ../../../devel/loads-stores.rst:144 ../../../devel/loads-stores.rst:182
#: ../../../devel/loads-stores.rst:221 ../../../devel/loads-stores.rst:260
#: ../../../devel/loads-stores.rst:291 ../../../devel/loads-stores.rst:331
#: ../../../devel/loads-stores.rst:387 ../../../devel/loads-stores.rst:443
#: ../../../devel/loads-stores.rst:543
msgid "``size``"
msgstr ""

#: ../../../devel/loads-stores.rst:37 ../../../devel/loads-stores.rst:111
#: ../../../devel/loads-stores.rst:145 ../../../devel/loads-stores.rst:183
#: ../../../devel/loads-stores.rst:222 ../../../devel/loads-stores.rst:261
#: ../../../devel/loads-stores.rst:292 ../../../devel/loads-stores.rst:332
#: ../../../devel/loads-stores.rst:388 ../../../devel/loads-stores.rst:444
#: ../../../devel/loads-stores.rst:544
msgid "``b`` : 8 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:38 ../../../devel/loads-stores.rst:112
#: ../../../devel/loads-stores.rst:146 ../../../devel/loads-stores.rst:184
#: ../../../devel/loads-stores.rst:223 ../../../devel/loads-stores.rst:262
#: ../../../devel/loads-stores.rst:293 ../../../devel/loads-stores.rst:333
#: ../../../devel/loads-stores.rst:389 ../../../devel/loads-stores.rst:445
#: ../../../devel/loads-stores.rst:545
msgid "``w`` : 16 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:39 ../../../devel/loads-stores.rst:113
#: ../../../devel/loads-stores.rst:147 ../../../devel/loads-stores.rst:185
#: ../../../devel/loads-stores.rst:224 ../../../devel/loads-stores.rst:263
#: ../../../devel/loads-stores.rst:294 ../../../devel/loads-stores.rst:334
#: ../../../devel/loads-stores.rst:390 ../../../devel/loads-stores.rst:446
#: ../../../devel/loads-stores.rst:546
msgid "``l`` : 32 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:40 ../../../devel/loads-stores.rst:114
#: ../../../devel/loads-stores.rst:148 ../../../devel/loads-stores.rst:186
#: ../../../devel/loads-stores.rst:225 ../../../devel/loads-stores.rst:264
#: ../../../devel/loads-stores.rst:295 ../../../devel/loads-stores.rst:335
#: ../../../devel/loads-stores.rst:391 ../../../devel/loads-stores.rst:447
#: ../../../devel/loads-stores.rst:547
msgid "``q`` : 64 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:42 ../../../devel/loads-stores.rst:337
#: ../../../devel/loads-stores.rst:393 ../../../devel/loads-stores.rst:449
#: ../../../devel/loads-stores.rst:549
msgid "``endian``"
msgstr ""

#: ../../../devel/loads-stores.rst:43
msgid "``he`` : host endian"
msgstr ""

#: ../../../devel/loads-stores.rst:44 ../../../devel/loads-stores.rst:339
#: ../../../devel/loads-stores.rst:395 ../../../devel/loads-stores.rst:451
#: ../../../devel/loads-stores.rst:551
msgid "``be`` : big endian"
msgstr ""

#: ../../../devel/loads-stores.rst:45 ../../../devel/loads-stores.rst:338
#: ../../../devel/loads-stores.rst:394 ../../../devel/loads-stores.rst:450
#: ../../../devel/loads-stores.rst:550
msgid "``le`` : little endian"
msgstr ""

#: ../../../devel/loads-stores.rst:47
msgid "The ``_{endian}`` infix is omitted for target-endian accesses."
msgstr ""

#: ../../../devel/loads-stores.rst:49
msgid ""
"The target endian accessors are only available to source files which are "
"built per-target."
msgstr ""

#: ../../../devel/loads-stores.rst:52
msgid "There are also functions which take the size as an argument:"
msgstr ""

#: ../../../devel/loads-stores.rst:54
msgid "load: ``ldn{endian}_p(ptr, sz)``"
msgstr ""

#: ../../../devel/loads-stores.rst:56
msgid ""
"which performs an unsigned load of ``sz`` bytes from ``ptr`` as an ``{endian}"
"`` order value and returns it in a uint64_t."
msgstr ""

#: ../../../devel/loads-stores.rst:59
msgid "store: ``stn{endian}_p(ptr, sz, val)``"
msgstr ""

#: ../../../devel/loads-stores.rst:61
msgid ""
"which stores ``val`` to ``ptr`` as an ``{endian}`` order value of size "
"``sz`` bytes."
msgstr ""

#: ../../../devel/loads-stores.rst:65 ../../../devel/loads-stores.rst:232
#: ../../../devel/loads-stores.rst:297 ../../../devel/loads-stores.rst:342
#: ../../../devel/loads-stores.rst:399 ../../../devel/loads-stores.rst:417
#: ../../../devel/loads-stores.rst:455 ../../../devel/loads-stores.rst:479
#: ../../../devel/loads-stores.rst:514 ../../../devel/loads-stores.rst:555
msgid "Regexes for git grep"
msgstr ""

#: ../../../devel/loads-stores.rst:66
msgid "``\\<ld[us]\\?[bwlq]\\(_[hbl]e\\)\\?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:67
msgid "``\\<st[bwlq]\\(_[hbl]e\\)\\?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:68
msgid "``\\<ldn_\\([hbl]e\\)?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:69
msgid "``\\<stn_\\([hbl]e\\)?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:72
msgid "``cpu_{ld,st}*_mmu``"
msgstr ""

#: ../../../devel/loads-stores.rst:74
msgid ""
"These functions operate on a guest virtual address, plus a context known as "
"a \"mmu index\" which controls how that virtual address is translated, plus "
"a ``MemOp`` which contains alignment requirements among other things.  The "
"``MemOp`` and mmu index are combined into a single argument of type "
"``MemOpIdx``."
msgstr ""

#: ../../../devel/loads-stores.rst:80
msgid ""
"The meaning of the indexes are target specific, but specifying a particular "
"index might be necessary if, for instance, the helper requires a \"always as "
"non-privileged\" access rather than the default access for the current state "
"of the guest CPU."
msgstr ""

#: ../../../devel/loads-stores.rst:85
msgid ""
"These functions may cause a guest CPU exception to be taken (e.g. for an "
"alignment fault or MMU fault) which will result in guest CPU state being "
"updated and control longjmp'ing out of the function call.  They should "
"therefore only be used in code that is implementing emulation of the guest "
"CPU."
msgstr ""

#: ../../../devel/loads-stores.rst:91
msgid ""
"The ``retaddr`` parameter is used to control unwinding of the guest CPU "
"state in case of a guest CPU exception.  This is passed to "
"``cpu_restore_state()``.  Therefore the value should either be 0, to "
"indicate that the guest CPU state is already synchronized, or the result of "
"``GETPC()`` from the top level ``HELPER(foo)`` function, which is a return "
"address into the generated code [#gpc]_."
msgstr ""

#: ../../../devel/loads-stores.rst:98
msgid ""
"Note that ``GETPC()`` should be used with great care: calling it in other "
"functions that are *not* the top level ``HELPER(foo)`` will cause unexpected "
"behavior. Instead, the value of ``GETPC()`` should be read from the helper "
"and passed if needed to the functions that the helper calls."
msgstr ""

#: ../../../devel/loads-stores.rst:106
msgid "load: ``cpu_ld{size}{end}_mmu(env, ptr, oi, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:108
msgid "store: ``cpu_st{size}{end}_mmu(env, ptr, val, oi, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:116 ../../../devel/loads-stores.rst:150
#: ../../../devel/loads-stores.rst:188 ../../../devel/loads-stores.rst:227
msgid "``end``"
msgstr ""

#: ../../../devel/loads-stores.rst:117 ../../../devel/loads-stores.rst:151
#: ../../../devel/loads-stores.rst:189 ../../../devel/loads-stores.rst:228
msgid "(empty) : for target endian, or 8 bit sizes"
msgstr ""

#: ../../../devel/loads-stores.rst:118 ../../../devel/loads-stores.rst:152
#: ../../../devel/loads-stores.rst:190 ../../../devel/loads-stores.rst:229
msgid "``_be`` : big endian"
msgstr ""

#: ../../../devel/loads-stores.rst:119 ../../../devel/loads-stores.rst:153
#: ../../../devel/loads-stores.rst:191 ../../../devel/loads-stores.rst:230
msgid "``_le`` : little endian"
msgstr ""

#: ../../../devel/loads-stores.rst:121 ../../../devel/loads-stores.rst:155
#: ../../../devel/loads-stores.rst:193 ../../../devel/loads-stores.rst:266
msgid "Regexes for git grep:"
msgstr ""

#: ../../../devel/loads-stores.rst:122
msgid "``\\<cpu_ld[bwlq](_[bl]e)\\?_mmu\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:123
msgid "``\\<cpu_st[bwlq](_[bl]e)\\?_mmu\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:127
msgid "``cpu_{ld,st}*_mmuidx_ra``"
msgstr ""

#: ../../../devel/loads-stores.rst:129
msgid ""
"These functions work like the ``cpu_{ld,st}_mmu`` functions except that the "
"``mmuidx`` parameter is not combined with a ``MemOp``, and therefore there "
"is no required alignment supplied or enforced."
msgstr ""

#: ../../../devel/loads-stores.rst:135
msgid "load: ``cpu_ld{sign}{size}{end}_mmuidx_ra(env, ptr, mmuidx, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:137
msgid "store: ``cpu_st{size}{end}_mmuidx_ra(env, ptr, val, mmuidx, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:156
msgid "``\\<cpu_ld[us]\\?[bwlq](_[bl]e)\\?_mmuidx_ra\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:157
msgid "``\\<cpu_st[bwlq](_[bl]e)\\?_mmuidx_ra\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:160
msgid "``cpu_{ld,st}*_data_ra``"
msgstr ""

#: ../../../devel/loads-stores.rst:162
msgid ""
"These functions work like the ``cpu_{ld,st}_mmuidx_ra`` functions except "
"that the ``mmuidx`` parameter is taken from the current mode of the guest "
"CPU, as determined by ``cpu_mmu_index(env, false)``."
msgstr ""

#: ../../../devel/loads-stores.rst:166
msgid ""
"These are generally the preferred way to do accesses by guest virtual "
"address from helper functions, unless the access should be performed with a "
"context other than the default, or alignment should be enforced for the "
"access."
msgstr ""

#: ../../../devel/loads-stores.rst:173
msgid "load: ``cpu_ld{sign}{size}{end}_data_ra(env, ptr, ra)``"
msgstr ""

#: ../../../devel/loads-stores.rst:175
msgid "store: ``cpu_st{size}{end}_data_ra(env, ptr, val, ra)``"
msgstr ""

#: ../../../devel/loads-stores.rst:194
msgid "``\\<cpu_ld[us]\\?[bwlq](_[bl]e)\\?_data_ra\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:195
msgid "``\\<cpu_st[bwlq](_[bl]e)\\?_data_ra\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:198
msgid "``cpu_{ld,st}*_data``"
msgstr ""

#: ../../../devel/loads-stores.rst:200
msgid ""
"These functions work like the ``cpu_{ld,st}_data_ra`` functions except that "
"the ``retaddr`` parameter is 0, and thus does not unwind guest CPU state."
msgstr ""

#: ../../../devel/loads-stores.rst:204
msgid ""
"This means they must only be used from helper functions where the translator "
"has saved all necessary CPU state.  These functions are the right choice for "
"calls made from hooks like the CPU ``do_interrupt`` hook or when you know "
"for certain that the translator had to save all the CPU state anyway."
msgstr ""

#: ../../../devel/loads-stores.rst:212
msgid "load: ``cpu_ld{sign}{size}{end}_data(env, ptr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:214
msgid "store: ``cpu_st{size}{end}_data(env, ptr, val)``"
msgstr ""

#: ../../../devel/loads-stores.rst:233
msgid "``\\<cpu_ld[us]\\?[bwlq](_[bl]e)\\?_data\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:234
msgid "``\\<cpu_st[bwlq](_[bl]e)\\?_data\\+\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:237
msgid "``cpu_ld*_code``"
msgstr ""

#: ../../../devel/loads-stores.rst:239
msgid ""
"These functions perform a read for instruction execution.  The ``mmuidx`` "
"parameter is taken from the current mode of the guest CPU, as determined by "
"``cpu_mmu_index(env, true)``.  The ``retaddr`` parameter is 0, and thus does "
"not unwind guest CPU state, because CPU state is always synchronized while "
"translating instructions.  Any guest CPU exception that is raised will "
"indicate an instruction execution fault rather than a data read fault."
msgstr ""

#: ../../../devel/loads-stores.rst:247
msgid ""
"In general these functions should not be used directly during translation. "
"There are wrapper functions that are to be used which also take care of "
"plugins for tracing."
msgstr ""

#: ../../../devel/loads-stores.rst:253
msgid "load: ``cpu_ld{sign}{size}_code(env, ptr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:267
msgid "``\\<cpu_ld[us]\\?[bwlq]_code\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:270
msgid "``translator_ld*``"
msgstr ""

#: ../../../devel/loads-stores.rst:272
msgid ""
"These functions are a wrapper for ``cpu_ld*_code`` which also perform any "
"actions required by any tracing plugins.  They are only to be called during "
"the translator callback ``translate_insn``."
msgstr ""

#: ../../../devel/loads-stores.rst:276
msgid ""
"There is a set of functions ending in ``_swap`` which, if the parameter is "
"true, returns the value in the endianness that is the reverse of the guest "
"native endianness, as determined by ``TARGET_BIG_ENDIAN``."
msgstr ""

#: ../../../devel/loads-stores.rst:282
msgid "load: ``translator_ld{sign}{size}(env, ptr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:284
msgid "swap: ``translator_ld{sign}{size}_swap(env, ptr, swap)``"
msgstr ""

#: ../../../devel/loads-stores.rst:298
msgid "``\\<translator_ld[us]\\?[bwlq]\\(_swap\\)\\?\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:301
msgid "``helper_*_{ld,st}*_mmu``"
msgstr ""

#: ../../../devel/loads-stores.rst:303
msgid ""
"These functions are intended primarily to be called by the code generated by "
"the TCG backend. They may also be called by target CPU helper function code. "
"Like the ``cpu_{ld,st}_mmuidx_ra`` functions they perform accesses by guest "
"virtual address, with a given ``mmuidx``."
msgstr ""

#: ../../../devel/loads-stores.rst:308
msgid ""
"These functions specify an ``opindex`` parameter which encodes (among other "
"things) the mmu index to use for the access.  This parameter should be "
"created by calling ``make_memop_idx()``."
msgstr ""

#: ../../../devel/loads-stores.rst:312
msgid ""
"The ``retaddr`` parameter should be the result of GETPC() called directly "
"from the top level HELPER(foo) function (or 0 if no guest CPU state "
"unwinding is required)."
msgstr ""

#: ../../../devel/loads-stores.rst:316
msgid ""
"**TODO** The names of these functions are a bit odd for historical reasons "
"because they were originally expected to be called only from within "
"generated code. We should rename them to bring them more in line with the "
"other memory access functions. The explicit endianness is the only feature "
"they have beyond ``*_mmuidx_ra``."
msgstr ""

#: ../../../devel/loads-stores.rst:322
msgid ""
"load: ``helper_{endian}_ld{sign}{size}_mmu(env, addr, opindex, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:324
msgid ""
"store: ``helper_{endian}_st{size}_mmu(env, addr, val, opindex, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:340
msgid "``ret`` : target endianness"
msgstr ""

#: ../../../devel/loads-stores.rst:343
msgid "``\\<helper_\\(le\\|be\\|ret\\)_ld[us]\\?[bwlq]_mmu\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:344
msgid "``\\<helper_\\(le\\|be\\|ret\\)_st[bwlq]_mmu\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:347
msgid "``address_space_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:349
msgid ""
"These functions are the primary ones to use when emulating CPU or device "
"memory accesses. They take an AddressSpace, which is the way QEMU defines "
"the view of memory that a device or CPU has. (They generally correspond to "
"being the \"master\" end of a hardware bus or bus fabric.)"
msgstr ""

#: ../../../devel/loads-stores.rst:355
msgid ""
"Each CPU has an AddressSpace. Some kinds of CPU have more than one "
"AddressSpace (for instance Arm guest CPUs have an AddressSpace for the "
"Secure world and one for NonSecure if they implement TrustZone). Devices "
"which can do DMA-type operations should generally have an AddressSpace. "
"There is also a \"system address space\" which typically has all the devices "
"and memory that all CPUs can see. (Some older device models use the \"system "
"address space\" rather than properly modelling that they have an "
"AddressSpace of their own.)"
msgstr ""

#: ../../../devel/loads-stores.rst:364
msgid ""
"Functions are provided for doing byte-buffer reads and writes, and also for "
"doing one-data-item loads and stores."
msgstr ""

#: ../../../devel/loads-stores.rst:367
msgid ""
"In all cases the caller provides a MemTxAttrs to specify bus transaction "
"attributes, and can check whether the memory transaction succeeded using a "
"MemTxResult return code."
msgstr ""

#: ../../../devel/loads-stores.rst:371
msgid "``address_space_read(address_space, addr, attrs, buf, len)``"
msgstr ""

#: ../../../devel/loads-stores.rst:373
msgid "``address_space_write(address_space, addr, attrs, buf, len)``"
msgstr ""

#: ../../../devel/loads-stores.rst:375
msgid "``address_space_rw(address_space, addr, attrs, buf, len, is_write)``"
msgstr ""

#: ../../../devel/loads-stores.rst:377
msgid ""
"``address_space_ld{sign}{size}_{endian}(address_space, addr, attrs, "
"txresult)``"
msgstr ""

#: ../../../devel/loads-stores.rst:379
msgid ""
"``address_space_st{size}_{endian}(address_space, addr, val, attrs, "
"txresult)``"
msgstr ""

#: ../../../devel/loads-stores.rst:385 ../../../devel/loads-stores.rst:441
#: ../../../devel/loads-stores.rst:541
msgid "(No signed load operations are provided.)"
msgstr ""

#: ../../../devel/loads-stores.rst:397
msgid "The ``_{endian}`` suffix is omitted for byte accesses."
msgstr ""

#: ../../../devel/loads-stores.rst:400
msgid "``\\<address_space_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:401
msgid "``\\<address_space_ldu\\?[bwql]\\(_[lb]e\\)\\?\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:402
msgid "``\\<address_space_st[bwql]\\(_[lb]e\\)\\?\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:405 ../../../devel/loads-stores.rst:418
msgid "``address_space_write_rom``"
msgstr ""

#: ../../../devel/loads-stores.rst:407
msgid ""
"This function performs a write by physical address like "
"``address_space_write``, except that if the write is to a ROM then the ROM "
"contents will be modified, even though a write by the guest CPU to the ROM "
"would be ignored. This is used for non-guest writes like writes from the gdb "
"debug stub or initial loading of ROM contents."
msgstr ""

#: ../../../devel/loads-stores.rst:413
msgid ""
"Note that portions of the write which attempt to write data to a device will "
"be silently ignored -- only real RAM and ROM will be written to."
msgstr ""

#: ../../../devel/loads-stores.rst:421
msgid "``{ld,st}*_phys``"
msgstr ""

#: ../../../devel/loads-stores.rst:423
msgid ""
"These are functions which are identical to ``address_space_{ld,st}*``, "
"except that they always pass ``MEMTXATTRS_UNSPECIFIED`` for the transaction "
"attributes, and ignore whether the transaction succeeded or failed."
msgstr ""

#: ../../../devel/loads-stores.rst:428
msgid ""
"The fact that they ignore whether the transaction succeeded means they "
"should not be used in new code, unless you know for certain that your code "
"will only be used in a context where the CPU or device doing the access has "
"no way to report such an error."
msgstr ""

#: ../../../devel/loads-stores.rst:433
msgid "``load: ld{sign}{size}_{endian}_phys``"
msgstr ""

#: ../../../devel/loads-stores.rst:435
msgid "``store: st{size}_{endian}_phys``"
msgstr ""

#: ../../../devel/loads-stores.rst:453 ../../../devel/loads-stores.rst:553
msgid "The ``_{endian}_`` infix is omitted for byte accesses."
msgstr ""

#: ../../../devel/loads-stores.rst:456
msgid "``\\<ldu\\?[bwlq]\\(_[bl]e\\)\\?_phys\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:457
msgid "``\\<st[bwlq]\\(_[bl]e\\)\\?_phys\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:460
msgid "``cpu_physical_memory_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:462
msgid ""
"These are convenience functions which are identical to ``address_space_*`` "
"but operate specifically on the system address space, always pass a "
"``MEMTXATTRS_UNSPECIFIED`` set of memory attributes and ignore whether the "
"memory transaction succeeded or failed. For new code they are better avoided:"
msgstr ""

#: ../../../devel/loads-stores.rst:468
msgid ""
"there is likely to be behaviour you need to model correctly for a failed "
"read or write operation"
msgstr ""

#: ../../../devel/loads-stores.rst:470
msgid ""
"a device should usually perform operations on its own AddressSpace rather "
"than using the system address space"
msgstr ""

#: ../../../devel/loads-stores.rst:473
msgid "``cpu_physical_memory_read``"
msgstr ""

#: ../../../devel/loads-stores.rst:475
msgid "``cpu_physical_memory_write``"
msgstr ""

#: ../../../devel/loads-stores.rst:477
msgid "``cpu_physical_memory_rw``"
msgstr ""

#: ../../../devel/loads-stores.rst:480
msgid "``\\<cpu_physical_memory_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:483 ../../../devel/loads-stores.rst:496
msgid "``cpu_memory_rw_debug``"
msgstr ""

#: ../../../devel/loads-stores.rst:485
msgid "Access CPU memory by virtual address for debug purposes."
msgstr ""

#: ../../../devel/loads-stores.rst:487
msgid ""
"This function is intended for use by the GDB stub and similar code. It takes "
"a virtual address, converts it to a physical address via an MMU lookup using "
"the current settings of the specified CPU, and then performs the access "
"(using ``address_space_rw`` for reads or ``cpu_physical_memory_write_rom`` "
"for writes). This means that if the access is a write to a ROM then this "
"function will modify the contents (whereas a normal guest CPU access would "
"ignore the write attempt)."
msgstr ""

#: ../../../devel/loads-stores.rst:499
msgid "``dma_memory_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:501
msgid ""
"These behave like ``address_space_*``, except that they perform a DMA "
"barrier operation first."
msgstr ""

#: ../../../devel/loads-stores.rst:504
msgid ""
"**TODO**: We should provide guidance on when you need the DMA barrier "
"operation and when it's OK to use ``address_space_*``, and make sure our "
"existing code is doing things correctly."
msgstr ""

#: ../../../devel/loads-stores.rst:508
msgid "``dma_memory_read``"
msgstr ""

#: ../../../devel/loads-stores.rst:510
msgid "``dma_memory_write``"
msgstr ""

#: ../../../devel/loads-stores.rst:512
msgid "``dma_memory_rw``"
msgstr ""

#: ../../../devel/loads-stores.rst:515
msgid "``\\<dma_memory_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:516
msgid "``\\<ldu\\?[bwlq]\\(_[bl]e\\)\\?_dma\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:517
msgid "``\\<st[bwlq]\\(_[bl]e\\)\\?_dma\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:520
msgid "``pci_dma_*`` and ``{ld,st}*_pci_dma``"
msgstr ""

#: ../../../devel/loads-stores.rst:522
msgid ""
"These functions are specifically for PCI device models which need to perform "
"accesses where the PCI device is a bus master. You pass them a ``PCIDevice "
"*`` and they will do ``dma_memory_*`` operations on the correct address "
"space for that device."
msgstr ""

#: ../../../devel/loads-stores.rst:527
msgid "``pci_dma_read``"
msgstr ""

#: ../../../devel/loads-stores.rst:529
msgid "``pci_dma_write``"
msgstr ""

#: ../../../devel/loads-stores.rst:531
msgid "``pci_dma_rw``"
msgstr ""

#: ../../../devel/loads-stores.rst:533
msgid "``load: ld{sign}{size}_{endian}_pci_dma``"
msgstr ""

#: ../../../devel/loads-stores.rst:535
msgid "``store: st{size}_{endian}_pci_dma``"
msgstr ""

#: ../../../devel/loads-stores.rst:556
msgid "``\\<pci_dma_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:557
msgid "``\\<ldu\\?[bwlq]\\(_[bl]e\\)\\?_pci_dma\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:558
msgid "``\\<st[bwlq]\\(_[bl]e\\)\\?_pci_dma\\>``"
msgstr ""
