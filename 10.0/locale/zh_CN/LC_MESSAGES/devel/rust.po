# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 10.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-23 10:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/rust.rst:4
msgid "Rust in QEMU"
msgstr ""

#: ../../../devel/rust.rst:6
msgid ""
"Rust in QEMU is a project to enable using the Rust programming language to "
"add new functionality to QEMU."
msgstr ""

#: ../../../devel/rust.rst:9
msgid ""
"Right now, the focus is on making it possible to write devices that inherit "
"from ``SysBusDevice`` in `*safe*`__ Rust.  Later, it may become possible to "
"write other kinds of devices (e.g. PCI devices that can do DMA), complete "
"boards, or backends (e.g. block device formats)."
msgstr ""

#: ../../../devel/rust.rst:17
msgid "Building the Rust in QEMU code"
msgstr ""

#: ../../../devel/rust.rst:19
msgid ""
"The Rust in QEMU code is included in the emulators via Meson.  Meson invokes "
"rustc directly, building static libraries that are then linked together with "
"the C code.  This is completely automatic when you run ``make`` or ``ninja``."
msgstr ""

#: ../../../devel/rust.rst:24
msgid ""
"However, QEMU's build system also tries to be easy to use for people who are "
"accustomed to the more \"normal\" Cargo-based development workflow. In "
"particular:"
msgstr ""

#: ../../../devel/rust.rst:28
msgid ""
"the set of warnings and lints that are used to build QEMU always comes from "
"the ``rust/Cargo.toml`` workspace file"
msgstr ""

#: ../../../devel/rust.rst:31
msgid ""
"it is also possible to use ``cargo`` for common Rust-specific coding tasks, "
"in particular to invoke ``clippy``, ``rustfmt`` and ``rustdoc``."
msgstr ""

#: ../../../devel/rust.rst:34
msgid ""
"To this end, QEMU includes a ``build.rs`` build script that picks up "
"generated sources from QEMU's build directory and puts it in Cargo's output "
"directory (typically ``rust/target/``).  A vanilla invocation of Cargo will "
"complain that it cannot find the generated sources, which can be fixed in "
"different ways:"
msgstr ""

#: ../../../devel/rust.rst:40
msgid "by using special shorthand targets in the QEMU build directory::"
msgstr ""

#: ../../../devel/rust.rst:42
msgid ""
"make clippy\n"
"make rustfmt\n"
"make rustdoc"
msgstr ""

#: ../../../devel/rust.rst:46
msgid ""
"by invoking ``cargo`` through the Meson `development environment`__ feature::"
msgstr ""

#: ../../../devel/rust.rst:49
msgid ""
"pyvenv/bin/meson devenv -w ../rust cargo clippy --tests\n"
"pyvenv/bin/meson devenv -w ../rust cargo fmt"
msgstr ""

#: ../../../devel/rust.rst:52
msgid ""
"If you are going to use ``cargo`` repeatedly, ``pyvenv/bin/meson devenv`` "
"will enter a shell where commands like ``cargo clippy`` just work."
msgstr ""

#: ../../../devel/rust.rst:57
msgid ""
"by pointing the ``MESON_BUILD_ROOT`` to the top of your QEMU build tree.  "
"This third method is useful if you are using ``rust-analyzer``; you can set "
"the environment variable through the ``rust-analyzer.cargo.extraEnv`` "
"setting."
msgstr ""

#: ../../../devel/rust.rst:62
msgid ""
"As shown above, you can use the ``--tests`` option as usual to operate on "
"test code.  Note however that you cannot *build* or run tests via ``cargo``, "
"because they need support C code from QEMU that Cargo does not know about.  "
"Tests can be run via ``meson test`` or ``make``::"
msgstr ""

#: ../../../devel/rust.rst:67
msgid "make check-rust"
msgstr ""

#: ../../../devel/rust.rst:69
msgid "Building Rust code with ``--enable-modules`` is not supported yet."
msgstr ""

#: ../../../devel/rust.rst:72
msgid "Supported tools"
msgstr ""

#: ../../../devel/rust.rst:74
msgid ""
"QEMU supports rustc version 1.63.0 and newer.  Notably, the following "
"features are missing:"
msgstr ""

#: ../../../devel/rust.rst:77
msgid "``core::ffi`` (1.64.0).  Use ``std::os::raw`` and ``std::ffi`` instead."
msgstr ""

#: ../../../devel/rust.rst:79
msgid "``cast_mut()``/``cast_const()`` (1.65.0).  Use ``as`` instead."
msgstr ""

#: ../../../devel/rust.rst:81
msgid ""
"\"let ... else\" (1.65.0).  Use ``if let`` instead.  This is currently "
"patched in QEMU's vendored copy of the bilge crate."
msgstr ""

#: ../../../devel/rust.rst:84
msgid "Generic Associated Types (1.65.0)"
msgstr ""

#: ../../../devel/rust.rst:86
msgid "``CStr::from_bytes_with_nul()`` as a ``const`` function (1.72.0)."
msgstr ""

#: ../../../devel/rust.rst:88
msgid ""
"\"Return position ``impl Trait`` in Traits\" (1.75.0, blocker for including "
"the pinned-init create)."
msgstr ""

#: ../../../devel/rust.rst:91
msgid ""
"``MaybeUninit::zeroed()`` as a ``const`` function (1.75.0).  QEMU's "
"``Zeroable`` trait can be implemented without ``MaybeUninit::zeroed()``, so "
"this would be just a cleanup."
msgstr ""

#: ../../../devel/rust.rst:95
msgid ""
"``c\"\" literals`` (stable in 1.77.0).  QEMU provides a ``c_str!()`` macro "
"to define ``CStr`` constants easily"
msgstr ""

#: ../../../devel/rust.rst:98
msgid ""
"``offset_of!`` (stable in 1.77.0).  QEMU uses ``offset_of!()`` heavily; it "
"provides a replacement in the ``qemu_api`` crate, but it does not support "
"lifetime parameters and therefore ``&'a Something`` fields in the struct may "
"have to be replaced by ``NonNull<Something>``.  *Nested* ``offset_of!`` was "
"only stabilized in Rust 1.82.0, but it is not used."
msgstr ""

#: ../../../devel/rust.rst:104
msgid ""
"inline const expression (stable in 1.79.0), currently worked around with "
"associated constants in the ``FnCall`` trait."
msgstr ""

#: ../../../devel/rust.rst:107
msgid ""
"associated constants have to be explicitly marked ``'static`` (`changed in "
"1.81.0`__)"
msgstr ""

#: ../../../devel/rust.rst:110
msgid ""
"``&raw`` (stable in 1.82.0).  Use ``addr_of!`` and ``addr_of_mut!`` instead, "
"though hopefully the need for raw pointers will go down over time."
msgstr ""

#: ../../../devel/rust.rst:113
msgid ""
"``new_uninit`` (stable in 1.82.0).  This is used internally by the "
"``pinned_init`` crate, which is planned for inclusion in QEMU, but it can be "
"easily patched out."
msgstr ""

#: ../../../devel/rust.rst:117
msgid ""
"referencing statics in constants (stable in 1.83.0).  For now use a const "
"function; this is an important limitation for QEMU's migration stream "
"architecture (VMState).  Right now, VMState lacks type safety because it is "
"hard to place the ``VMStateField`` definitions in traits."
msgstr ""

#: ../../../devel/rust.rst:122
msgid ""
"associated const equality would be nice to have for some users of "
"``callbacks::FnCall``, but is still experimental.  ``ASSERT_IS_SOME`` "
"replaces it."
msgstr ""

#: ../../../devel/rust.rst:128
msgid ""
"It is expected that QEMU will advance its minimum supported version of rustc "
"to 1.77.0 as soon as possible; as of January 2025, blockers for that right "
"now are Debian bookworm and 32-bit MIPS processors. This unfortunately means "
"that references to statics in constants will remain an issue."
msgstr ""

#: ../../../devel/rust.rst:134
msgid ""
"QEMU also supports version 0.60.x of bindgen, which is missing option ``--"
"generate-cstr``.  This option requires version 0.66.x and will be adopted as "
"soon as supporting these older versions is not necessary anymore."
msgstr ""

#: ../../../devel/rust.rst:140
msgid "Writing Rust code in QEMU"
msgstr ""

#: ../../../devel/rust.rst:142
msgid "QEMU includes four crates:"
msgstr ""

#: ../../../devel/rust.rst:144
msgid "``qemu_api`` for bindings to C code and useful functionality"
msgstr ""

#: ../../../devel/rust.rst:146
msgid ""
"``qemu_api_macros`` defines several procedural macros that are useful when "
"writing C code"
msgstr ""

#: ../../../devel/rust.rst:149
msgid ""
"``pl011`` (under ``rust/hw/char/pl011``) and ``hpet`` (under ``rust/hw/timer/"
"hpet``) are sample devices that demonstrate ``qemu_api`` and "
"``qemu_api_macros``, and are used to further develop them.  These two crates "
"are functional\\ [#issues]_ replacements for the ``hw/char/pl011.c`` and "
"``hw/timer/hpet.c`` files."
msgstr ""

#: ../../../devel/rust.rst:154
msgid ""
"The ``pl011`` crate is synchronized with ``hw/char/pl011.c`` as of commit "
"02b1f7f61928.  The ``hpet`` crate is synchronized as of commit f32352ff9e.  "
"Both are lacking tracing functionality; ``hpet`` is also lacking support for "
"migration."
msgstr ""

#: ../../../devel/rust.rst:159
msgid "This section explains how to work with them."
msgstr ""

#: ../../../devel/rust.rst:162
msgid "Status"
msgstr ""

#: ../../../devel/rust.rst:164
msgid "Modules of ``qemu_api`` can be defined as:"
msgstr ""

#: ../../../devel/rust.rst:166
msgid ""
"*complete*: ready for use in new devices; if applicable, the API supports "
"the full functionality available in C"
msgstr ""

#: ../../../devel/rust.rst:169
msgid ""
"*stable*: ready for production use, the API is safe and should not undergo "
"major changes"
msgstr ""

#: ../../../devel/rust.rst:172
msgid ""
"*proof of concept*: the API is subject to change but allows working with "
"safe Rust"
msgstr ""

#: ../../../devel/rust.rst:175
msgid ""
"*initial*: the API is in its initial stages; it requires large amount of "
"unsafe code; it might have soundness or type-safety issues"
msgstr ""

#: ../../../devel/rust.rst:178
msgid "The status of the modules is as follows:"
msgstr ""

#: ../../../devel/rust.rst:181
msgid "module"
msgstr ""

#: ../../../devel/rust.rst:181
msgid "status"
msgstr ""

#: ../../../devel/rust.rst:183
msgid "``assertions``"
msgstr ""

#: ../../../devel/rust.rst:183 ../../../devel/rust.rst:186
#: ../../../devel/rust.rst:190 ../../../devel/rust.rst:192
#: ../../../devel/rust.rst:193 ../../../devel/rust.rst:194
#: ../../../devel/rust.rst:195 ../../../devel/rust.rst:196
#: ../../../devel/rust.rst:198
msgid "stable"
msgstr ""

#: ../../../devel/rust.rst:184
msgid "``bitops``"
msgstr ""

#: ../../../devel/rust.rst:184 ../../../devel/rust.rst:185
#: ../../../devel/rust.rst:187 ../../../devel/rust.rst:188
#: ../../../devel/rust.rst:189 ../../../devel/rust.rst:191
msgid "complete"
msgstr ""

#: ../../../devel/rust.rst:185
msgid "``callbacks``"
msgstr ""

#: ../../../devel/rust.rst:186
msgid "``cell``"
msgstr ""

#: ../../../devel/rust.rst:187
msgid "``c_str``"
msgstr ""

#: ../../../devel/rust.rst:188
msgid "``errno``"
msgstr ""

#: ../../../devel/rust.rst:189
msgid "``irq``"
msgstr ""

#: ../../../devel/rust.rst:190
msgid "``memory``"
msgstr ""

#: ../../../devel/rust.rst:191
msgid "``module``"
msgstr ""

#: ../../../devel/rust.rst:192
msgid "``offset_of``"
msgstr ""

#: ../../../devel/rust.rst:193
msgid "``qdev``"
msgstr ""

#: ../../../devel/rust.rst:194
msgid "``qom``"
msgstr ""

#: ../../../devel/rust.rst:195
msgid "``sysbus``"
msgstr ""

#: ../../../devel/rust.rst:196
msgid "``timer``"
msgstr ""

#: ../../../devel/rust.rst:197
msgid "``vmstate``"
msgstr ""

#: ../../../devel/rust.rst:197
msgid "proof of concept"
msgstr ""

#: ../../../devel/rust.rst:198
msgid "``zeroable``"
msgstr ""

#: ../../../devel/rust.rst:202
msgid ""
"API stability is not a promise, if anything because the C APIs are not a "
"stable interface either.  Also, ``unsafe`` interfaces may be replaced by "
"safe interfaces later."
msgstr ""

#: ../../../devel/rust.rst:207
msgid "Naming convention"
msgstr ""

#: ../../../devel/rust.rst:209
msgid ""
"C function names usually are prefixed according to the data type that they "
"apply to, for example ``timer_mod`` or ``sysbus_connect_irq``.  Furthermore, "
"both function and structs sometimes have a ``qemu_`` or ``QEMU`` prefix. "
"Generally speaking, these are all removed in the corresponding Rust "
"functions: ``QEMUTimer`` becomes ``timer::Timer``, ``timer_mod`` becomes "
"``Timer::modify``, ``sysbus_connect_irq`` becomes ``SysBusDeviceMethods::"
"connect_irq``."
msgstr ""

#: ../../../devel/rust.rst:216
msgid ""
"Sometimes however a name appears multiple times in the QOM class hierarchy, "
"and the only difference is in the prefix.  An example is ``qdev_realize`` "
"and ``sysbus_realize``.  In such cases, whenever a name is not unique in the "
"hierarchy, always add the prefix to the classes that are lower in the "
"hierarchy; for the top class, decide on a case by case basis."
msgstr ""

#: ../../../devel/rust.rst:222
msgid "For example:"
msgstr ""

#: ../../../devel/rust.rst:225
msgid "``device_cold_reset()``"
msgstr ""

#: ../../../devel/rust.rst:225
msgid "``DeviceMethods::cold_reset()``"
msgstr ""

#: ../../../devel/rust.rst:226
msgid "``pci_device_reset()``"
msgstr ""

#: ../../../devel/rust.rst:226
msgid "``PciDeviceMethods::pci_device_reset()``"
msgstr ""

#: ../../../devel/rust.rst:227
msgid "``pci_bridge_reset()``"
msgstr ""

#: ../../../devel/rust.rst:227
msgid "``PciBridgeMethods::pci_bridge_reset()``"
msgstr ""

#: ../../../devel/rust.rst:230
msgid ""
"Here, the name is not exactly the same, but nevertheless "
"``PciDeviceMethods`` adds the prefix to avoid confusion, because the "
"functionality of ``device_cold_reset()`` and ``pci_device_reset()`` is "
"subtly different."
msgstr ""

#: ../../../devel/rust.rst:234
msgid "In this case, however, no prefix is needed:"
msgstr ""

#: ../../../devel/rust.rst:237
msgid "``device_realize()``"
msgstr ""

#: ../../../devel/rust.rst:237
msgid "``DeviceMethods::realize()``"
msgstr ""

#: ../../../devel/rust.rst:238
msgid "``sysbus_realize()``"
msgstr ""

#: ../../../devel/rust.rst:238
msgid "``SysbusDeviceMethods::sysbus_realize()``"
msgstr ""

#: ../../../devel/rust.rst:239
msgid "``pci_realize()``"
msgstr ""

#: ../../../devel/rust.rst:239
msgid "``PciDeviceMethods::pci_realize()``"
msgstr ""

#: ../../../devel/rust.rst:242
msgid ""
"Here, the lower classes do not add any functionality, and mostly provide "
"extra compile-time checking; the basic *realize* functionality is the same "
"for all devices.  Therefore, ``DeviceMethods`` does not add the prefix."
msgstr ""

#: ../../../devel/rust.rst:247
msgid ""
"Whenever a name is unique in the hierarchy, instead, you should always "
"remove the class name prefix."
msgstr ""

#: ../../../devel/rust.rst:251
msgid "Common pitfalls"
msgstr ""

#: ../../../devel/rust.rst:253
msgid ""
"Rust has very strict rules with respect to how you get an exclusive "
"(``&mut``) reference; failure to respect those rules is a source of "
"undefined behavior. In particular, even if a value is loaded from a raw "
"mutable pointer (``*mut``), it *cannot* be casted to ``&mut`` unless the "
"value was stored to the ``*mut`` from a mutable reference.  Furthermore, it "
"is undefined behavior if any shared reference was created between the store "
"to the ``*mut`` and the load::"
msgstr ""

#: ../../../devel/rust.rst:260
msgid ""
"let mut p: u32 = 42;\n"
"let p_mut = &mut p;                              // 1\n"
"let p_raw = p_mut as *mut u32;                   // 2\n"
"\n"
"// p_raw keeps the mutable reference \"alive\"\n"
"\n"
"let p_shared = &p;                               // 3\n"
"println!(\"access from &u32: {}\", *p_shared);\n"
"\n"
"// Bring back the mutable reference, its lifetime overlaps\n"
"// with that of a shared reference.\n"
"let p_mut = unsafe { &mut *p_raw };              // 4\n"
"println!(\"access from &mut 32: {}\", *p_mut);\n"
"\n"
"println!(\"access from &u32: {}\", *p_shared);     // 5"
msgstr ""

#: ../../../devel/rust.rst:276
msgid "These rules can be tested with `MIRI`__, for example."
msgstr ""

#: ../../../devel/rust.rst:280
msgid ""
"Almost all Rust code in QEMU will involve QOM objects, and pointers to these "
"objects are *shared*, for example because they are part of the QOM "
"composition tree.  This creates exactly the above scenario:"
msgstr ""

#: ../../../devel/rust.rst:284
msgid "a QOM object is created"
msgstr ""

#: ../../../devel/rust.rst:286
msgid ""
"a ``*mut`` is created, for example as the opaque value for a ``MemoryRegion``"
msgstr ""

#: ../../../devel/rust.rst:288
msgid "the QOM object is placed in the composition tree"
msgstr ""

#: ../../../devel/rust.rst:290
msgid "a memory access dereferences the opaque value to a ``&mut``"
msgstr ""

#: ../../../devel/rust.rst:292
msgid "but the shared reference is still present in the composition tree"
msgstr ""

#: ../../../devel/rust.rst:294
msgid ""
"Because of this, QOM objects should almost always use ``&self`` instead of "
"``&mut self``; access to internal fields must use *interior mutability* to "
"go from a shared reference to a ``&mut``."
msgstr ""

#: ../../../devel/rust.rst:298
msgid ""
"Whenever C code provides you with an opaque ``void *``, avoid converting it "
"to a Rust mutable reference, and use a shared reference instead.  The "
"``qemu_api::cell`` module provides wrappers that can be used to tell the "
"Rust compiler about interior mutability, and optionally to enforce locking "
"rules for the \"Big QEMU Lock\".  In the future, similar cell types might "
"also be provided for ``AioContext``-based locking as well."
msgstr ""

#: ../../../devel/rust.rst:305
msgid ""
"In particular, device code will usually rely on the ``BqlRefCell`` and "
"``BqlCell`` type to ensure that data is accessed correctly under the \"Big "
"QEMU Lock\".  These cell types are also known to the ``vmstate`` crate, "
"which is able to \"look inside\" them when building an in-memory "
"representation of a ``struct``'s layout.  Note that the same is not true of "
"a ``RefCell`` or ``Mutex``."
msgstr ""

#: ../../../devel/rust.rst:312
msgid ""
"Bindings code instead will usually use the ``Opaque`` type, which hides the "
"contents of the underlying struct and can be easily converted to a raw "
"pointer, for use in calls to C functions.  It can be used for example as "
"follows::"
msgstr ""

#: ../../../devel/rust.rst:317
msgid ""
"#[repr(transparent)]\n"
"#[derive(Debug, qemu_api_macros::Wrapper)]\n"
"pub struct Object(Opaque<bindings::Object>);"
msgstr ""

#: ../../../devel/rust.rst:321
msgid ""
"where the special ``derive`` macro provides useful methods such as "
"``from_raw``, ``as_ptr`, ``as_mut_ptr`` and ``raw_get``.  The bindings will "
"then manually check for the big QEMU lock with assertions, which allows the "
"wrapper to be declared thread-safe::"
msgstr ""

#: ../../../devel/rust.rst:326
msgid ""
"unsafe impl Send for Object {}\n"
"unsafe impl Sync for Object {}"
msgstr ""

#: ../../../devel/rust.rst:330
msgid "Writing bindings to C code"
msgstr ""

#: ../../../devel/rust.rst:332
msgid ""
"Here are some things to keep in mind when working on the ``qemu_api`` crate."
msgstr ""

#: ../../../devel/rust.rst:334
msgid "**Look at existing code**"
msgstr ""

#: ../../../devel/rust.rst:335
msgid ""
"Very often, similar idioms in C code correspond to similar tricks in Rust "
"bindings.  If the C code uses ``offsetof``, look at qdev properties or "
"``vmstate``.  If the C code has a complex const struct, look at "
"``MemoryRegion``.  Reuse existing patterns for handling lifetimes; for "
"example use ``&T`` for QOM objects that do not need a reference count "
"(including those that can be embedded in other objects) and ``Owned<T>`` for "
"those that need it."
msgstr ""

#: ../../../devel/rust.rst:343
msgid "**Use the type system**"
msgstr ""

#: ../../../devel/rust.rst:344
msgid ""
"Bindings often will need access information that is specific to a type "
"(either a builtin one or a user-defined one) in order to pass it to C "
"functions.  Put them in a trait and access it through generic parameters. "
"The ``vmstate`` module has examples of how to retrieve type information for "
"the fields of a Rust ``struct``."
msgstr ""

#: ../../../devel/rust.rst:350
msgid "**Prefer unsafe traits to unsafe functions**"
msgstr ""

#: ../../../devel/rust.rst:351
msgid ""
"Unsafe traits are much easier to prove correct than unsafe functions. They "
"are an excellent place to store metadata that can later be accessed by "
"generic functions.  C code usually places metadata in global variables; in "
"Rust, they can be stored in traits and then turned into ``static`` "
"variables.  Often, unsafe traits can be generated by procedural macros."
msgstr ""

#: ../../../devel/rust.rst:357
msgid "**Document limitations due to old Rust versions**"
msgstr ""

#: ../../../devel/rust.rst:358
msgid ""
"If you need to settle for an inferior solution because of the currently "
"supported set of Rust versions, document it in the source and in this file.  "
"This ensures that it can be fixed when the minimum supported version is "
"bumped."
msgstr ""

#: ../../../devel/rust.rst:363
msgid "**Keep locking in mind**."
msgstr ""

#: ../../../devel/rust.rst:364
msgid ""
"When marking a type ``Sync``, be careful of whether it needs the big QEMU "
"lock.  Use ``BqlCell`` and ``BqlRefCell`` for interior data, or assert "
"``bql_locked()``."
msgstr ""

#: ../../../devel/rust.rst:368
msgid "**Don't be afraid of complexity, but document and isolate it**"
msgstr ""

#: ../../../devel/rust.rst:369
msgid ""
"It's okay to be tricky; device code is written more often than bindings code "
"and it's important that it is idiomatic.  However, you should strive to "
"isolate any tricks in a place (for example a ``struct``, a trait or a macro) "
"where it can be documented and tested.  If needed, include toy versions of "
"the code in the documentation."
msgstr ""

#: ../../../devel/rust.rst:376
msgid "Writing procedural macros"
msgstr ""

#: ../../../devel/rust.rst:378
msgid ""
"By conventions, procedural macros are split in two functions, one returning "
"``Result<proc_macro2::TokenStream, MacroError>`` with the body of the "
"procedural macro, and the second returning ``proc_macro::TokenStream`` which "
"is the actual procedural macro.  The former's name is the same as the latter "
"with the ``_or_error`` suffix.  The code for the latter is more or less "
"fixed; it follows the following template, which is fixed apart from the type "
"after ``as`` in the invocation of ``parse_macro_input!``::"
msgstr ""

#: ../../../devel/rust.rst:386
msgid ""
"#[proc_macro_derive(Object)]\n"
"pub fn derive_object(input: TokenStream) -> TokenStream {\n"
"    let input = parse_macro_input!(input as DeriveInput);\n"
"    let expanded = derive_object_or_error(input).unwrap_or_else(Into::"
"into);\n"
"\n"
"    TokenStream::from(expanded)\n"
"}"
msgstr ""

#: ../../../devel/rust.rst:394
msgid ""
"The ``qemu_api_macros`` crate has utility functions to examine a "
"``DeriveInput`` and perform common checks (e.g. looking for a struct with "
"named fields).  These functions return ``Result<..., MacroError>`` and can "
"be used easily in the procedural macro function::"
msgstr ""

#: ../../../devel/rust.rst:399
msgid ""
"fn derive_object_or_error(input: DeriveInput) ->\n"
"    Result<proc_macro2::TokenStream, MacroError>\n"
"{\n"
"    is_c_repr(&input, \"#[derive(Object)]\")?;\n"
"\n"
"    let name = &input.ident;\n"
"    let parent = &get_fields(&input, \"#[derive(Object)]\")?[0].ident;\n"
"    ...\n"
"}"
msgstr ""

#: ../../../devel/rust.rst:409
msgid ""
"Use procedural macros with care.  They are mostly useful for two purposes:"
msgstr ""

#: ../../../devel/rust.rst:411
msgid ""
"Performing consistency checks; for example ``#[derive(Object)]`` checks that "
"the structure has ``#[repr[C])`` and that the type of the first field is "
"consistent with the ``ObjectType`` declaration."
msgstr ""

#: ../../../devel/rust.rst:415
msgid ""
"Extracting information from Rust source code into traits, typically based on "
"types and attributes.  For example, ``#[derive(TryInto)]`` builds an "
"implementation of ``TryFrom``, and it uses the ``#[repr(...)]`` attribute as "
"the ``TryFrom`` source and error types."
msgstr ""

#: ../../../devel/rust.rst:420
msgid ""
"Procedural macros can be hard to debug and test; if the code generation "
"exceeds a few lines of code, it may be worthwhile to delegate work to "
"\"regular\" declarative (``macro_rules!``) macros and write unit tests for "
"those instead."
msgstr ""

#: ../../../devel/rust.rst:427
msgid "Coding style"
msgstr ""

#: ../../../devel/rust.rst:429
msgid "Code should pass clippy and be formatted with rustfmt."
msgstr ""

#: ../../../devel/rust.rst:431
msgid ""
"Right now, only the nightly version of ``rustfmt`` is supported.  This might "
"change in the future.  While CI checks for correct formatting via ``cargo "
"fmt --check``, maintainers can fix this for you when applying patches."
msgstr ""

#: ../../../devel/rust.rst:435
msgid ""
"It is expected that ``qemu_api`` provides full ``rustdoc`` documentation for "
"bindings that are in their final shape or close."
msgstr ""

#: ../../../devel/rust.rst:439
msgid "Adding dependencies"
msgstr ""

#: ../../../devel/rust.rst:441
msgid ""
"Generally, the set of dependent crates is kept small.  Think twice before "
"adding a new external crate, especially if it comes with a large set of "
"dependencies itself.  Sometimes QEMU only needs a small subset of the "
"functionality; see for example QEMU's ``assertions`` or ``c_str`` modules."
msgstr ""

#: ../../../devel/rust.rst:446
msgid ""
"On top of this recommendation, adding external crates to QEMU is a slightly "
"complicated process, mostly due to the need to teach Meson how to build "
"them.  While Meson has initial support for parsing ``Cargo.lock`` files, it "
"is still highly experimental and is therefore not used."
msgstr ""

#: ../../../devel/rust.rst:451
msgid ""
"Therefore, external crates must be added as subprojects for Meson to learn "
"how to build them, as well as to the relevant ``Cargo.toml`` files. The "
"versions specified in ``rust/Cargo.lock`` must be the same as the "
"subprojects; note that the ``rust/`` directory forms a Cargo `workspace`__, "
"and therefore there is a single lock file for the whole build."
msgstr ""

#: ../../../devel/rust.rst:459
msgid ""
"Choose a version of the crate that works with QEMU's minimum supported Rust "
"version (|msrv|)."
msgstr ""

#: ../../../devel/rust.rst:462
msgid ""
"Second, a new ``wrap`` file must be added to teach Meson how to download the "
"crate.  The wrap file must be named ``NAME-SEMVER-rs.wrap``, where ``NAME`` "
"is the name of the crate and ``SEMVER`` is the version up to and including "
"the first non-zero number.  For example, a crate with version ``0.2.3`` will "
"use ``0.2`` for its ``SEMVER``, while a crate with version ``1.0.84`` will "
"use ``1``."
msgstr ""

#: ../../../devel/rust.rst:468
msgid ""
"Third, the Meson rules to build the crate must be added at ``subprojects/"
"NAME-SEMVER-rs/meson.build``.  Generally this includes:"
msgstr ""

#: ../../../devel/rust.rst:471
msgid "``subproject`` and ``dependency`` lines for all dependent crates"
msgstr ""

#: ../../../devel/rust.rst:473
msgid ""
"a ``static_library`` or ``rust.proc_macro`` line to perform the actual build"
msgstr ""

#: ../../../devel/rust.rst:475
msgid ""
"``declare_dependency`` and a ``meson.override_dependency`` lines to expose "
"the result to QEMU and to other subprojects"
msgstr ""

#: ../../../devel/rust.rst:478
msgid ""
"Remember to add ``native: true`` to ``dependency``, ``static_library`` and "
"``meson.override_dependency`` for dependencies of procedural macros. If a "
"crate is needed in both procedural macros and QEMU binaries, everything "
"apart from ``subproject`` must be duplicated to build both native and non-"
"native versions of the crate."
msgstr ""

#: ../../../devel/rust.rst:484
msgid "It's important to specify the right compiler options.  These include:"
msgstr ""

#: ../../../devel/rust.rst:486
msgid "the language edition (which can be found in the ``Cargo.toml`` file)"
msgstr ""

#: ../../../devel/rust.rst:488
msgid ""
"the ``--cfg`` (which have to be \"reverse engineered\" from the ``build.rs`` "
"file of the crate)."
msgstr ""

#: ../../../devel/rust.rst:491
msgid ""
"usually, a ``--cap-lints allow`` argument to hide warnings from rustc or "
"clippy."
msgstr ""

#: ../../../devel/rust.rst:494
msgid ""
"After every change to the ``meson.build`` file you have to update the "
"patched version with ``meson subprojects update --reset ``NAME-SEMVER-rs``.  "
"This might be automated in the future."
msgstr ""

#: ../../../devel/rust.rst:498
msgid ""
"Also, after every change to the ``meson.build`` file it is strongly "
"suggested to do a dummy change to the ``.wrap`` file (for example adding a "
"comment like ``# version 2``), which will help Meson notice that the "
"subproject is out of date."
msgstr ""

#: ../../../devel/rust.rst:502
msgid ""
"As a last step, add the new subproject to ``scripts/archive-source.sh``, "
"``scripts/make-release`` and ``subprojects/.gitignore``."
msgstr ""
