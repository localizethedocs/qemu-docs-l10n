# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 10.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/testing/fuzzing.rst:3
msgid "Fuzzing"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:5
msgid ""
"This document describes the virtual-device fuzzing infrastructure in QEMU "
"and how to use it to implement additional fuzzers."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:9
msgid "Basics"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:11
msgid ""
"Fuzzing operates by passing inputs to an entry point/target function. The "
"fuzzer tracks the code coverage triggered by the input. Based on these "
"findings, the fuzzer mutates the input and repeats the fuzzing."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:15
msgid ""
"To fuzz QEMU, we rely on libfuzzer. Unlike other fuzzers such as AFL, "
"libfuzzer is an *in-process* fuzzer. For the developer, this means that it "
"is their responsibility to ensure that state is reset between fuzzing-runs."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:20
msgid "Building the fuzzers"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:22
msgid ""
"To build the fuzzers, install a recent version of clang: Configure with "
"(substitute the clang binaries with the version you installed). Here, enable-"
"asan and enable-ubsan are optional but they allow us to reliably detect bugs "
"such as out-of-bounds accesses, uses-after-free, double-frees etc.::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:28
msgid ""
"CC=clang-8 CXX=clang++-8 /path/to/configure \\\n"
"    --enable-fuzzing --enable-asan --enable-ubsan"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:31
msgid "Fuzz targets are built similarly to system targets::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:33
msgid "make qemu-fuzz-i386"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:35
msgid "This builds ``./qemu-fuzz-i386``"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:37
msgid ""
"The first option to this command is: ``--fuzz-target=FUZZ_NAME`` To list all "
"of the available fuzzers run ``qemu-fuzz-i386`` with no arguments."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:40
msgid "For example::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:42
msgid "./qemu-fuzz-i386 --fuzz-target=virtio-scsi-fuzz"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:44
msgid ""
"Internally, libfuzzer parses all arguments that do not begin with ``\"--"
"\"``. Information about these is available by passing ``-help=1``"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:47
msgid ""
"Now the only thing left to do is wait for the fuzzer to trigger potential "
"crashes."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:51
msgid "Useful libFuzzer flags"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:53
msgid ""
"As mentioned above, libFuzzer accepts some arguments. Passing ``-help=1`` "
"will list the available arguments. In particular, these arguments might be "
"helpful:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:56
msgid ""
"``CORPUS_DIR/`` : Specify a directory as the last argument to libFuzzer. "
"libFuzzer stores each \"interesting\" input in this corpus directory. The "
"next time you run libFuzzer, it will read all of the inputs from the corpus, "
"and continue fuzzing from there. You can also specify multiple directories. "
"libFuzzer loads existing inputs from all specified directories, but will "
"only write new ones to the first one specified."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:63
msgid ""
"``-max_len=4096`` : specify the maximum byte-length of the inputs libFuzzer "
"will generate."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:66
msgid ""
"``-close_fd_mask={1,2,3}`` : close, stderr, or both. Useful for targets that "
"trigger many debug/error messages, or create output on the serial console."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:69
msgid ""
"``-jobs=4 -workers=4`` : These arguments configure libFuzzer to run 4 "
"fuzzers in parallel (4 fuzzing jobs in 4 worker processes). Alternatively, "
"with only ``-jobs=N``, libFuzzer automatically spawns a number of workers "
"less than or equal to half the available CPU cores. Replace 4 with a number "
"appropriate for your machine. Make sure to specify a ``CORPUS_DIR``, which "
"will allow the parallel fuzzers to share information about the interesting "
"inputs they find."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:76
msgid ""
"``-use_value_profile=1`` : For each comparison operation, libFuzzer computes "
"``(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)`` and places this in the "
"coverage table. Useful for targets with \"magic\" constants. If Arg1 came "
"from the fuzzer's input and Arg2 is a magic constant, then each time the "
"Hamming distance between Arg1 and Arg2 decreases, libFuzzer adds the input "
"to the corpus."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:83
msgid ""
"``-shrink=1`` : Tries to make elements of the corpus \"smaller\". Might lead "
"to better coverage performance, depending on the target."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:86
msgid ""
"Note that libFuzzer's exact behavior will depend on the version of clang and "
"libFuzzer used to build the device fuzzers."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:90
msgid "Generating Coverage Reports"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:92
msgid ""
"Code coverage is a crucial metric for evaluating a fuzzer's performance. "
"libFuzzer's output provides a \"cov: \" column that provides a total number "
"of unique blocks/edges covered. To examine coverage on a line-by-line basis "
"we can use Clang coverage:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:97
msgid ""
"Configure libFuzzer to store a corpus of all interesting inputs (see "
"CORPUS_DIR above)"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:99
msgid "``./configure`` the QEMU build with ::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:101
msgid ""
"--enable-fuzzing \\\n"
"--extra-cflags=\"-fprofile-instr-generate -fcoverage-mapping\""
msgstr ""

#: ../../../devel/testing/fuzzing.rst:104
msgid ""
"Re-run the fuzzer. Specify $CORPUS_DIR/* as an argument, telling libfuzzer "
"to execute all of the inputs in $CORPUS_DIR and exit. Once the process "
"exits, you should find a file, \"default.profraw\" in the working directory."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:107
msgid "Execute these commands to generate a detailed HTML coverage-report::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:109
msgid ""
"llvm-profdata merge -output=default.profdata default.profraw\n"
"llvm-cov show ./path/to/qemu-fuzz-i386 -instr-profile=default.profdata \\\n"
"--format html -output-dir=/path/to/output/report"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:114
msgid "Adding a new fuzzer"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:116
msgid ""
"Coverage over virtual devices can be improved by adding additional fuzzers. "
"Fuzzers are kept in ``tests/qtest/fuzz/`` and should be added to ``tests/"
"qtest/fuzz/meson.build``"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:120
msgid ""
"Fuzzers can rely on both qtest and libqos to communicate with virtual "
"devices."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:122
msgid ""
"Create a new source file. For example ``tests/qtest/fuzz/foo-device-fuzz.c``."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:124
msgid ""
"Write the fuzzing code using the libqtest/libqos API. See existing fuzzers "
"for reference."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:127
msgid "Add the fuzzer to ``tests/qtest/fuzz/meson.build``."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:129
msgid ""
"Fuzzers can be more-or-less thought of as special qtest programs which can "
"modify the qtest commands and/or qtest command arguments based on inputs "
"provided by libfuzzer. Libfuzzer passes a byte array and length. Commonly "
"the fuzzer loops over the byte-array interpreting it as a list of qtest "
"commands, addresses, or values."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:136
msgid "The Generic Fuzzer"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:138
msgid ""
"Writing a fuzz target can be a lot of effort (especially if a device driver "
"has not be built-out within libqos). Many devices can be fuzzed to some "
"degree, without any device-specific code, using the generic-fuzz target."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:142
msgid ""
"The generic-fuzz target is capable of fuzzing devices over their PIO, MMIO, "
"and DMA input-spaces. To apply the generic-fuzz to a device, we need to "
"define two env-variables, at minimum:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:146
msgid ""
"``QEMU_FUZZ_ARGS=`` is the set of QEMU arguments used to configure a "
"machine, with the device attached. For example, if we want to fuzz the "
"virtio-net device attached to a pc-i440fx machine, we can specify::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:150
msgid ""
"QEMU_FUZZ_ARGS=\"-M pc -nodefaults -netdev user,id=user0 \\\n"
"-device virtio-net,netdev=user0\""
msgstr ""

#: ../../../devel/testing/fuzzing.rst:153
msgid ""
"``QEMU_FUZZ_OBJECTS=`` is a set of space-delimited strings used to identify "
"the MemoryRegions that will be fuzzed. These strings are compared against "
"MemoryRegion names and MemoryRegion owner names, to decide whether each "
"MemoryRegion should be fuzzed. These strings support globbing. For the "
"virtio-net example, we could use one of ::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:159
msgid ""
"QEMU_FUZZ_OBJECTS='virtio-net'\n"
"QEMU_FUZZ_OBJECTS='virtio*'\n"
"QEMU_FUZZ_OBJECTS='virtio* pcspk' # Fuzz the virtio devices and the speaker\n"
"QEMU_FUZZ_OBJECTS='*' # Fuzz the whole machine``"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:164
msgid ""
"The ``\"info mtree\"`` and ``\"info qom-tree\"`` monitor commands can be "
"especially useful for identifying the ``MemoryRegion`` and ``Object`` names "
"used for matching."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:168
msgid ""
"As a generic rule-of-thumb, the more ``MemoryRegions``/Devices we match, the "
"greater the input-space, and the smaller the probability of finding crashing "
"inputs for individual devices. As such, it is usually a good idea to limit "
"the fuzzer to only a few ``MemoryRegions``."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:173
msgid ""
"To ensure that these env variables have been configured correctly, we can "
"use::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:175
msgid "./qemu-fuzz-i386 --fuzz-target=generic-fuzz -runs=0"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:177
msgid "The output should contain a complete list of matched MemoryRegions."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:180
msgid "OSS-Fuzz"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:181
msgid ""
"QEMU is continuously fuzzed on `OSS-Fuzz <https://github.com/google/oss-"
"fuzz>`_.  By default, the OSS-Fuzz build will try to fuzz every fuzz-target. "
"Since the generic-fuzz target requires additional information provided in "
"environment variables, we pre-define some generic-fuzz configs in ``tests/"
"qtest/fuzz/generic_fuzz_configs.h``. Each config must specify:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:188
msgid "``.name``: To identify the fuzzer config"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:190
msgid ""
"``.args`` OR ``.argfunc``: A string or pointer to a function returning a "
"string.  These strings are used to specify the ``QEMU_FUZZ_ARGS`` "
"environment variable.  ``argfunc`` is useful when the config relies on e.g. "
"a dynamically created temp directory, or a free tcp/udp port."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:195
msgid ""
"``.objects``: A string that specifies the ``QEMU_FUZZ_OBJECTS`` environment "
"variable."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:198
msgid ""
"To fuzz additional devices/device configuration on OSS-Fuzz, send patches "
"for either a new device-specific fuzzer or a new generic-fuzz config."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:201
msgid "Build details:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:203
msgid ""
"The Dockerfile that sets up the environment for building QEMU's fuzzers on "
"OSS-Fuzz can be fund in the OSS-Fuzz repository __(https://github.com/google/"
"oss-fuzz/blob/master/projects/qemu/Dockerfile)"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:207
msgid ""
"The script responsible for building the fuzzers can be found in the QEMU "
"source tree at ``scripts/oss-fuzz/build.sh``"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:211
msgid "Building Crash Reproducers"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:212
msgid ""
"When we find a crash, we should try to create an independent reproducer, "
"that can be used on a non-fuzzer build of QEMU. This filters out any "
"potential false-positives, and improves the debugging experience for "
"developers. Here are the steps for building a reproducer for a crash found "
"by the generic-fuzz target."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:218
msgid "Ensure the crash reproduces::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:220
msgid "qemu-fuzz-i386 --fuzz-target... ./crash-..."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:222
msgid "Gather the QTest output for the crash::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:224
msgid ""
"QEMU_FUZZ_TIMEOUT=0 QTEST_LOG=1 FUZZ_SERIALIZE_QTEST=1 \\\n"
"qemu-fuzz-i386 --fuzz-target... ./crash-... &> /tmp/trace"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:227
msgid "Reorder and clean-up the resulting trace::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:229
msgid ""
"scripts/oss-fuzz/reorder_fuzzer_qtest_trace.py /tmp/trace > /tmp/reproducer"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:231
msgid "Get the arguments needed to start qemu, and provide a path to qemu::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:233
msgid ""
"less /tmp/trace # The args should be logged at the top of this file\n"
"export QEMU_ARGS=\"-machine ...\"\n"
"export QEMU_PATH=\"path/to/qemu-system\""
msgstr ""

#: ../../../devel/testing/fuzzing.rst:237
msgid "Ensure the crash reproduces in qemu-system::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:239
msgid "$QEMU_PATH $QEMU_ARGS -qtest stdio < /tmp/reproducer"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:241
msgid ""
"From the crash output, obtain some string that identifies the crash. This "
"can be a line in the stack-trace, for example::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:244
msgid "export CRASH_TOKEN=\"hw/usb/hcd-xhci.c:1865\""
msgstr ""

#: ../../../devel/testing/fuzzing.rst:246
msgid "Minimize the reproducer::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:248
msgid ""
"scripts/oss-fuzz/minimize_qtest_trace.py -M1 -M2 \\\n"
"  /tmp/reproducer /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:251
msgid "Confirm that the minimized reproducer still crashes::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:253
msgid "$QEMU_PATH $QEMU_ARGS -qtest stdio < /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:255
msgid "Create a one-liner reproducer that can be sent over email::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:257
msgid "./scripts/oss-fuzz/output_reproducer.py -bash /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:259
msgid "Output the C source code for a test case that will reproduce the bug::"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:261
msgid ""
"./scripts/oss-fuzz/output_reproducer.py -owner \"John Smith <john@smith."
"com>\"\\\n"
"  -name \"test_function_name\" /tmp/reproducer-minimized"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:264
msgid "Report the bug and send a patch with the C reproducer upstream"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:267
msgid "Implementation Details / Fuzzer Lifecycle"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:269
msgid ""
"The fuzzer has two entrypoints that libfuzzer calls. libfuzzer provides it's "
"own ``main()``, which performs some setup, and calls the entrypoints:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:272
msgid ""
"``LLVMFuzzerInitialize``: called prior to fuzzing. Used to initialize all of "
"the necessary state"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:275
msgid ""
"``LLVMFuzzerTestOneInput``: called for each fuzzing run. Processes the input "
"and resets the state at the end of each run."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:278
msgid "In more detail:"
msgstr ""

#: ../../../devel/testing/fuzzing.rst:280
msgid ""
"``LLVMFuzzerInitialize`` parses the arguments to the fuzzer (must start with "
"two dashes, so they are ignored by libfuzzer ``main()``). Currently, the "
"arguments select the fuzz target. Then, the qtest client is initialized. If "
"the target requires qos, qgraph is set up and the QOM/LIBQOS modules are "
"initialized. Then the QGraph is walked and the QEMU cmd_line is determined "
"and saved."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:286
msgid ""
"After this, the ``vl.c:main`` is called to set up the guest. There are "
"target-specific hooks that can be called before and after main, for "
"additional setup(e.g. PCI setup, or VM snapshotting)."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:290
msgid ""
"``LLVMFuzzerTestOneInput``: Uses qtest/qos functions to act based on the "
"fuzz input. It is also responsible for manually calling ``main_loop_wait`` "
"to ensure that bottom halves are executed and any cleanup required before "
"the next input."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:294
msgid ""
"Since the same process is reused for many fuzzing runs, QEMU state needs to "
"be reset at the end of each run. For example, this can be done by rebooting "
"the VM, after each run."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:298
msgid "*Pros*: Straightforward and fast for simple fuzz targets."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:300
msgid ""
"*Cons*: Depending on the device, does not reset all device state. If the "
"device requires some initialization prior to being ready for fuzzing (common "
"for QOS-based targets), this initialization needs to be done after each "
"reboot."
msgstr ""

#: ../../../devel/testing/fuzzing.rst:305
msgid "*Example target*: ``i440fx-qtest-reboot-fuzz``"
msgstr ""
