<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SiFive HiFive Unleashed (sifive_u) &#8212; QEMU 6.0.1 文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=d2f4ad69"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/qemu-docs-l10n/system/riscv/sifive_u.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="RX System emulator" href="../target-rx.html" />
    <link rel="prev" title="Microchip PolarFire SoC Icicle Kit (microchip-icicle-kit)" href="microchip-icicle-kit.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="sifive-hifive-unleashed-sifive-u">
<h1>SiFive HiFive Unleashed (<code class="docutils literal notranslate"><span class="pre">sifive_u</span></code>)<a class="headerlink" href="#sifive-hifive-unleashed-sifive-u" title="Link to this heading">¶</a></h1>
<p>SiFive HiFive Unleashed Development Board is the ultimate RISC-V development
board featuring the Freedom U540 multi-core RISC-V processor.</p>
<section id="supported-devices">
<h2>Supported devices<a class="headerlink" href="#supported-devices" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine supports the following devices:</p>
<blockquote>
<div><ul class="simple">
<li><p>1 E51 / E31 core</p></li>
<li><p>Up to 4 U54 / U34 cores</p></li>
<li><p>Core Level Interruptor (CLINT)</p></li>
<li><p>Platform-Level Interrupt Controller (PLIC)</p></li>
<li><p>Power, Reset, Clock, Interrupt (PRCI)</p></li>
<li><p>L2 Loosely Integrated Memory (L2-LIM)</p></li>
<li><p>DDR memory controller</p></li>
<li><p>2 UARTs</p></li>
<li><p>1 GEM Ethernet controller</p></li>
<li><p>1 GPIO controller</p></li>
<li><p>1 One-Time Programmable (OTP) memory with stored serial number</p></li>
<li><p>1 DMA controller</p></li>
<li><p>2 QSPI controllers</p></li>
<li><p>1 ISSI 25WP256 flash</p></li>
<li><p>1 SD card in SPI mode</p></li>
</ul>
</div></blockquote>
<p>Please note the real world HiFive Unleashed board has a fixed configuration of
1 E51 core and 4 U54 core combination and the RISC-V core boots in 64-bit mode.
With QEMU, one can create a machine with 1 E51 core and up to 4 U54 cores. It
is also possible to create a 32-bit variant with the same peripherals except
that the RISC-V cores are replaced by the 32-bit ones (E31 and U34), to help
testing of 32-bit guest software.</p>
</section>
<section id="hardware-configuration-information">
<h2>Hardware configuration information<a class="headerlink" href="#hardware-configuration-information" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine automatically generates a device tree blob (&quot;dtb&quot;)
which it passes to the guest. This provides information about the addresses,
interrupt lines and other configuration of the various devices in the system.
Guest software should discover the devices that are present in the generated
DTB instead of using a DTB for the real hardware, as some of the devices are
not modeled by QEMU and trying to access these devices may cause unexpected
behavior.</p>
</section>
<section id="boot-options">
<h2>Boot options<a class="headerlink" href="#boot-options" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine can start using the standard -kernel functionality
for loading a Linux kernel, a VxWorks kernel, a modified U-Boot bootloader
(S-mode) or ELF executable with the default OpenSBI firmware image as the
-bios. It also supports booting the unmodified U-Boot bootloader using the
standard -bios functionality.</p>
</section>
<section id="machine-specific-options">
<h2>Machine-specific options<a class="headerlink" href="#machine-specific-options" title="Link to this heading">¶</a></h2>
<p>The following machine-specific options are supported:</p>
<ul>
<li><p>serial=nnn</p>
<p>The board serial number. When not given, the default serial number 1 is used.</p>
<p>SiFive reserves the first 1 KiB of the 16 KiB OTP memory for internal use.
The current usage is only used to store the serial number of the board at
offset 0xfc. U-Boot reads the serial number from the OTP memory, and uses
it to generate a unique MAC address to be programmed to the on-chip GEM
Ethernet controller. When multiple QEMU <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machines are created
and connected to the same subnet, they all have the same MAC address hence
it creates an unusable network. In such scenario, user should give different
values to serial= when creating different <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machines.</p>
</li>
<li><p>start-in-flash</p>
<p>When given, QEMU's ROM codes jump to QSPI memory-mapped flash directly.
Otherwise QEMU will jump to DRAM or L2LIM depending on the msel= value.
When not given, it defaults to direct DRAM booting.</p>
</li>
<li><p>msel=[6|11]</p>
<p>Mode Select (MSEL[3:0]) pins value, used to control where to boot from.</p>
<p>The FU540 SoC supports booting from several sources, which are controlled
using the Mode Select pins on the chip. Typically, the boot process runs
through several stages before it begins execution of user-provided programs.
These stages typically include the following:</p>
<ol class="arabic simple">
<li><p>Zeroth Stage Boot Loader (ZSBL), which is contained in an on-chip mask
ROM and provided by QEMU. Note QEMU implemented ROM codes are not the
same as what is programmed in the hardware. The QEMU one is a simplified
version, but it provides the same functionality as the hardware.</p></li>
<li><p>First Stage Boot Loader (FSBL), which brings up PLLs and DDR memory.
This is U-Boot SPL.</p></li>
<li><p>Second Stage Boot Loader (SSBL), which further initializes additional
peripherals as needed. This is U-Boot proper combined with an OpenSBI
fw_dynamic firmware image.</p></li>
</ol>
<p>msel=6 means FSBL and SSBL are both on the QSPI flash. msel=11 means FSBL
and SSBL are both on the SD card.</p>
</li>
</ul>
</section>
<section id="running-linux-kernel">
<h2>Running Linux kernel<a class="headerlink" href="#running-linux-kernel" title="Link to this heading">¶</a></h2>
<p>Linux mainline v5.10 release is tested at the time of writing. To build a
Linux mainline kernel that can be booted by the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine in
64-bit mode, simply configure the kernel using the defconfig configuration:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">ARCH</span><span class="o">=</span>riscv
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>riscv64-linux-
$<span class="w"> </span>make<span class="w"> </span>defconfig
$<span class="w"> </span>make
</pre></div>
</div>
<p>To boot the newly built Linux kernel in QEMU with the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-riscv64<span class="w"> </span>-M<span class="w"> </span>sifive_u<span class="w"> </span>-smp<span class="w"> </span><span class="m">5</span><span class="w"> </span>-m<span class="w"> </span>2G<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-display<span class="w"> </span>none<span class="w"> </span>-serial<span class="w"> </span>stdio<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-kernel<span class="w"> </span>arch/riscv/boot/Image<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-initrd<span class="w"> </span>/path/to/rootfs.ext4<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-append<span class="w"> </span><span class="s2">&quot;root=/dev/ram&quot;</span>
</pre></div>
</div>
<p>To build a Linux mainline kernel that can be booted by the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine
in 32-bit mode, use the rv32_defconfig configuration. A patch is required to
fix the 32-bit boot issue for Linux kernel v5.10.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">ARCH</span><span class="o">=</span>riscv
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>riscv64-linux-
$<span class="w"> </span>curl<span class="w"> </span>https://patchwork.kernel.org/project/linux-riscv/patch/20201219001356.2887782-1-atish.patra@wdc.com/mbox/<span class="w"> </span>&gt;<span class="w"> </span>riscv.patch
$<span class="w"> </span>git<span class="w"> </span>am<span class="w"> </span>riscv.patch
$<span class="w"> </span>make<span class="w"> </span>rv32_defconfig
$<span class="w"> </span>make
</pre></div>
</div>
<p>Replace <code class="docutils literal notranslate"><span class="pre">qemu-system-riscv64</span></code> with <code class="docutils literal notranslate"><span class="pre">qemu-system-riscv32</span></code> in the command
line above to boot the 32-bit Linux kernel. A rootfs image containing 32-bit
applications shall be used in order for kernel to boot to user space.</p>
</section>
<section id="running-vxworks-kernel">
<h2>Running VxWorks kernel<a class="headerlink" href="#running-vxworks-kernel" title="Link to this heading">¶</a></h2>
<p>VxWorks 7 SR0650 release is tested at the time of writing. To build a 64-bit
VxWorks mainline kernel that can be booted by the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine, simply
create a VxWorks source build project based on the sifive_generic BSP, and a
VxWorks image project to generate the bootable VxWorks image, by following the
BSP documentation instructions.</p>
<p>A pre-built 64-bit VxWorks 7 image for HiFive Unleashed board is available as
part of the VxWorks SDK for testing as well. Instructions to download the SDK:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>wget<span class="w"> </span>https://labs.windriver.com/downloads/wrsdk-vxworks7-sifive-hifive-1.01.tar.bz2
$<span class="w"> </span>tar<span class="w"> </span>xvf<span class="w"> </span>wrsdk-vxworks7-sifive-hifive-1.01.tar.bz2
$<span class="w"> </span>ls<span class="w"> </span>bsps/sifive_generic_1_0_0_0/uboot/uVxWorks
</pre></div>
</div>
<p>To boot the VxWorks kernel in QEMU with the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine, use:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-riscv64<span class="w"> </span>-M<span class="w"> </span>sifive_u<span class="w"> </span>-smp<span class="w"> </span><span class="m">5</span><span class="w"> </span>-m<span class="w"> </span>2G<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-display<span class="w"> </span>none<span class="w"> </span>-serial<span class="w"> </span>stdio<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-nic<span class="w"> </span>tap,ifname<span class="o">=</span>tap0,script<span class="o">=</span>no,downscript<span class="o">=</span>no<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-kernel<span class="w"> </span>/path/to/vxWorks<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-append<span class="w"> </span><span class="s2">&quot;gem(0,0)host:vxWorks h=192.168.200.1 e=192.168.200.2:ffffff00 u=target pw=vxTarget f=0x01&quot;</span>
</pre></div>
</div>
<p>It is also possible to test 32-bit VxWorks on the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine. Create
a 32-bit project to build the 32-bit VxWorks image, and use exact the same
command line options with <code class="docutils literal notranslate"><span class="pre">qemu-system-riscv32</span></code>.</p>
</section>
<section id="running-u-boot">
<h2>Running U-Boot<a class="headerlink" href="#running-u-boot" title="Link to this heading">¶</a></h2>
<p>U-Boot mainline v2021.01 release is tested at the time of writing. To build a
U-Boot mainline bootloader that can be booted by the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine, use
the sifive_fu540_defconfig with similar commands as described above for Linux:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>riscv64-linux-
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">OPENSBI</span><span class="o">=</span>/path/to/opensbi-riscv64-generic-fw_dynamic.bin
$<span class="w"> </span>make<span class="w"> </span>sifive_fu540_defconfig
</pre></div>
</div>
<p>You will get spl/u-boot-spl.bin and u-boot.itb file in the build tree.</p>
<p>To start U-Boot using the <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine, prepare an SPI flash image, or
SD card image that is properly partitioned and populated with correct contents.
<a class="reference external" href="https://github.com/pengutronix/genimage">genimage</a> can be used to generate these images.</p>
<p>A sample configuration file for a 128 MiB SD card image is:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cat<span class="w"> </span>genimage_sdcard.cfg
image<span class="w"> </span>sdcard.img<span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nv">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>128M

<span class="w">        </span>hdimage<span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">gpt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="w">        </span><span class="o">}</span>

<span class="w">        </span>partition<span class="w"> </span>u-boot-spl<span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;u-boot-spl.bin&quot;</span>
<span class="w">                </span><span class="nv">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>17K
<span class="w">                </span>partition-type-uuid<span class="w"> </span><span class="o">=</span><span class="w"> </span>5B193300-FC78-40CD-8002-E86C45580B47
<span class="w">        </span><span class="o">}</span>

<span class="w">        </span>partition<span class="w"> </span>u-boot<span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;u-boot.itb&quot;</span>
<span class="w">                </span><span class="nv">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>1041K
<span class="w">                </span>partition-type-uuid<span class="w"> </span><span class="o">=</span><span class="w"> </span>2E54B353-1271-4842-806F-E436D6AF6985
<span class="w">        </span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>SPI flash image has slightly different partition offsets, and the size has to
be 32 MiB to match the ISSI 25WP256 flash on the real board:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cat<span class="w"> </span>genimage_spi-nor.cfg
image<span class="w"> </span>spi-nor.img<span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nv">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>32M

<span class="w">        </span>hdimage<span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">gpt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span>
<span class="w">        </span><span class="o">}</span>

<span class="w">        </span>partition<span class="w"> </span>u-boot-spl<span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;u-boot-spl.bin&quot;</span>
<span class="w">                </span><span class="nv">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>20K
<span class="w">                </span>partition-type-uuid<span class="w"> </span><span class="o">=</span><span class="w"> </span>5B193300-FC78-40CD-8002-E86C45580B47
<span class="w">        </span><span class="o">}</span>

<span class="w">        </span>partition<span class="w"> </span>u-boot<span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;u-boot.itb&quot;</span>
<span class="w">                </span><span class="nv">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>1044K
<span class="w">                </span>partition-type-uuid<span class="w"> </span><span class="o">=</span><span class="w"> </span>2E54B353-1271-4842-806F-E436D6AF6985
<span class="w">        </span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Assume U-Boot binaries are put in the same directory as the config file,
we can generate the image by:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>genimage<span class="w"> </span>--config<span class="w"> </span>genimage_&lt;boot_src&gt;.cfg<span class="w"> </span>--inputpath<span class="w"> </span>.
</pre></div>
</div>
<p>Boot U-Boot from SD card, by specifying msel=11 and pass the SD card image
to QEMU <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-riscv64<span class="w"> </span>-M<span class="w"> </span>sifive_u,msel<span class="o">=</span><span class="m">11</span><span class="w"> </span>-smp<span class="w"> </span><span class="m">5</span><span class="w"> </span>-m<span class="w"> </span>8G<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-display<span class="w"> </span>none<span class="w"> </span>-serial<span class="w"> </span>stdio<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-bios<span class="w"> </span>/path/to/u-boot-spl.bin<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-drive<span class="w"> </span><span class="nv">file</span><span class="o">=</span>/path/to/sdcard.img,if<span class="o">=</span>sd
</pre></div>
</div>
<p>Changing msel= value to 6, allows booting U-Boot from the SPI flash:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-riscv64<span class="w"> </span>-M<span class="w"> </span>sifive_u,msel<span class="o">=</span><span class="m">6</span><span class="w"> </span>-smp<span class="w"> </span><span class="m">5</span><span class="w"> </span>-m<span class="w"> </span>8G<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-display<span class="w"> </span>none<span class="w"> </span>-serial<span class="w"> </span>stdio<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-bios<span class="w"> </span>/path/to/u-boot-spl.bin<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-drive<span class="w"> </span><span class="nv">file</span><span class="o">=</span>/path/to/spi-nor.img,if<span class="o">=</span>mtd
</pre></div>
</div>
<p>Note when testing U-Boot, QEMU automatically generated device tree blob is
not used because U-Boot itself embeds device tree blobs for U-Boot SPL and
U-Boot proper. Hence the number of cores and size of memory have to match
the real hardware, ie: 5 cores (-smp 5) and 8 GiB memory (-m 8G).</p>
<p>Above use case is to run upstream U-Boot for the SiFive HiFive Unleashed
board on QEMU <code class="docutils literal notranslate"><span class="pre">sifive_u</span></code> machine out of the box. This allows users to
develop and test the recommended RISC-V boot flow with a real world use
case: ZSBL (in QEMU) loads U-Boot SPL from SD card or SPI flash to L2LIM,
then U-Boot SPL loads the combined payload image of OpenSBI fw_dynamic
firmware and U-Boot proper. However sometimes we want to have a quick test
of booting U-Boot on QEMU without the needs of preparing the SPI flash or
SD card images, an alternate way can be used, which is to create a U-Boot
S-mode image by modifying the configuration of U-Boot:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>menuconfig
</pre></div>
</div>
<p>then manually select the following configuration in U-Boot:</p>
<blockquote>
<div><p>Device Tree Control &gt; Provider of DTB for DT Control &gt; Prior Stage bootloader DTB</p>
</div></blockquote>
<p>This lets U-Boot to use the QEMU generated device tree blob. During the build,
a build error will be seen below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MKIMAGE u-boot.img
./tools/mkimage: Can&#39;t open arch/riscv/dts/hifive-unleashed-a00.dtb: No such file or directory
./tools/mkimage: failed to build FIT
make: *** [Makefile:1440: u-boot.img] Error 1
</pre></div>
</div>
<p>The above errors can be safely ignored as we don't run U-Boot SPL under QEMU
in this alternate configuration.</p>
<p>Boot the 64-bit U-Boot S-mode image directly:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-riscv64<span class="w"> </span>-M<span class="w"> </span>sifive_u<span class="w"> </span>-smp<span class="w"> </span><span class="m">5</span><span class="w"> </span>-m<span class="w"> </span>2G<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-display<span class="w"> </span>none<span class="w"> </span>-serial<span class="w"> </span>stdio<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-kernel<span class="w"> </span>/path/to/u-boot.bin
</pre></div>
</div>
<p>It's possible to create a 32-bit U-Boot S-mode image as well.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>riscv64-linux-
$<span class="w"> </span>make<span class="w"> </span>sifive_fu540_defconfig
$<span class="w"> </span>make<span class="w"> </span>menuconfig
</pre></div>
</div>
<p>then manually update the following configuration in U-Boot:</p>
<blockquote>
<div><p>Device Tree Control &gt; Provider of DTB for DT Control &gt; Prior Stage bootloader DTB
RISC-V architecture &gt; Base ISA &gt; RV32I
Boot images &gt; Text Base &gt; 0x80400000</p>
</div></blockquote>
<p>Use the same command line options to boot the 32-bit U-Boot S-mode image:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-riscv32<span class="w"> </span>-M<span class="w"> </span>sifive_u<span class="w"> </span>-smp<span class="w"> </span><span class="m">5</span><span class="w"> </span>-m<span class="w"> </span>2G<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-display<span class="w"> </span>none<span class="w"> </span>-serial<span class="w"> </span>stdio<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-kernel<span class="w"> </span>/path/to/u-boot.bin
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">QEMU</a></h1>








<div id="editpage">
  <ul>
    <li><a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/system/riscv/sifive_u.rst">Page source</a></li>
  </ul>
</div><h3>导航</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">System Emulation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html">Quick Start</a></li>
<li class="toctree-l2"><a class="reference internal" href="../invocation.html">Invocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../keys.html">Keys in the graphical frontends</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mux-chardev.html">Keys in the character backend multiplexer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../monitor.html">QEMU Monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../images.html">Disk Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../net.html">Network emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../virtio-net-failover.html">QEMU virtio-net standby (net_failover)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb.html">USB emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvme.html">NVMe Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ivshmem.html">Inter-VM Shared Memory device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linuxboot.html">Direct Linux Boot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-loader.html">Generic Loader</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guest-loader.html">Guest Loader</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vnc-security.html">VNC security</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tls.html">TLS setup for network services</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gdb.html">GDB usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../managed-startup.html">Managed start up options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpu-hotplug.html">Virtual CPU hotplug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../virtio-pmem.html">virtio pmem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pr-manager.html">Persistent reservation managers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../targets.html">QEMU System Emulator Targets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="../multi-process.html">Multi-process QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../deprecated.html">Deprecated features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../removed-features.html">Removed features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../build-platforms.html">Supported build platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../license.html">License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devel/index.html">Developer Information</a></li>
</ul>


<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2020, The QEMU Project Developers.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>