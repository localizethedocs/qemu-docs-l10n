# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 6.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:00+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../system/gdb.rst:4
msgid "GDB usage"
msgstr ""

#: ../../../system/gdb.rst:6
msgid ""
"QEMU supports working with gdb via gdb's remote-connection facility (the "
"\"gdbstub\"). This allows you to debug guest code in the same way that you "
"might with a low-level debug facility like JTAG on real hardware. You can "
"stop and start the virtual machine, examine state like registers and memory, "
"and set breakpoints and watchpoints."
msgstr ""

#: ../../../system/gdb.rst:13
msgid ""
"In order to use gdb, launch QEMU with the ``-s`` and ``-S`` options. The ``-"
"s`` option will make QEMU listen for an incoming connection from gdb on TCP "
"port 1234, and ``-S`` will make QEMU not start the guest until you tell it "
"to from gdb. (If you want to specify which TCP port to use or to use "
"something other than TCP for the gdbstub connection, use the ``-gdb dev`` "
"option instead of ``-s``.)"
msgstr ""

#: ../../../system/gdb.rst:22
msgid ""
"|qemu_system| -s -S -kernel bzImage -hda rootdisk.img -append \"root=/dev/"
"hda\""
msgstr ""

#: ../../../system/gdb.rst:24
msgid "QEMU will launch but will silently wait for gdb to connect."
msgstr ""

#: ../../../system/gdb.rst:26
msgid "Then launch gdb on the 'vmlinux' executable::"
msgstr ""

#: ../../../system/gdb.rst:28
msgid "> gdb vmlinux"
msgstr ""

#: ../../../system/gdb.rst:30
msgid "In gdb, connect to QEMU::"
msgstr ""

#: ../../../system/gdb.rst:32
msgid "(gdb) target remote localhost:1234"
msgstr ""

#: ../../../system/gdb.rst:34
msgid ""
"Then you can use gdb normally. For example, type 'c' to launch the kernel::"
msgstr ""

#: ../../../system/gdb.rst:37
msgid "(gdb) c"
msgstr ""

#: ../../../system/gdb.rst:39
msgid "Here are some useful tips in order to use gdb on system code:"
msgstr ""

#: ../../../system/gdb.rst:41
msgid "Use ``info reg`` to display all the CPU registers."
msgstr ""

#: ../../../system/gdb.rst:43
msgid "Use ``x/10i $eip`` to display the code at the PC position."
msgstr ""

#: ../../../system/gdb.rst:45
msgid ""
"Use ``set architecture i8086`` to dump 16 bit code. Then use ``x/10i $cs*16+"
"$eip`` to dump the code at the PC position."
msgstr ""

#: ../../../system/gdb.rst:49
msgid "Debugging multicore machines"
msgstr ""

#: ../../../system/gdb.rst:51
msgid ""
"GDB's abstraction for debugging targets with multiple possible parallel "
"flows of execution is a two layer one: it supports multiple \"inferiors\", "
"each of which can have multiple \"threads\". When the QEMU machine has more "
"than one CPU, QEMU exposes each CPU cluster as a separate \"inferior\", "
"where each CPU within the cluster is a separate \"thread\". Most QEMU "
"machine types have identical CPUs, so there is a single cluster which has "
"all the CPUs in it.  A few machine types are heterogenous and have multiple "
"clusters: for example the ``sifive_u`` machine has a cluster with one E51 "
"core and a second cluster with four U54 cores. Here the E51 is the only "
"thread in the first inferior, and the U54 cores are all threads in the "
"second inferior."
msgstr ""

#: ../../../system/gdb.rst:63
msgid ""
"When you connect gdb to the gdbstub, it will automatically connect to the "
"first inferior; you can display the CPUs in this cluster using the gdb "
"``info thread`` command, and switch between them using gdb's usual thread-"
"management commands."
msgstr ""

#: ../../../system/gdb.rst:68
msgid ""
"For multi-cluster machines, unfortunately gdb does not by default handle "
"multiple inferiors, and so you have to explicitly connect to them. First, "
"you must connect with the ``extended-remote`` protocol, not ``remote``::"
msgstr ""

#: ../../../system/gdb.rst:73
msgid "(gdb) target extended-remote localhost:1234"
msgstr ""

#: ../../../system/gdb.rst:75
msgid ""
"Once connected, gdb will have a single inferior, for the first cluster. You "
"need to create inferiors for the other clusters and attach to them, like "
"this::"
msgstr ""

#: ../../../system/gdb.rst:79
msgid ""
"(gdb) add-inferior\n"
"Added inferior 2\n"
"(gdb) inferior 2\n"
"[Switching to inferior 2 [<null>] (<noexec>)]\n"
"(gdb) attach 2\n"
"Attaching to process 2\n"
"warning: No executable has been specified and target does not support\n"
"determining executable automatically.  Try using the \"file\" command.\n"
"0x00000000 in ?? ()"
msgstr ""

#: ../../../system/gdb.rst:89
msgid ""
"Once you've done this, ``info threads`` will show CPUs in all the clusters "
"you have attached to::"
msgstr ""

#: ../../../system/gdb.rst:92
msgid ""
"(gdb) info threads\n"
"  Id   Target Id         Frame\n"
"  1.1  Thread 1.1 (cortex-m33-arm-cpu cpu [running]) 0x00000000 in ?? ()\n"
"* 2.1  Thread 2.2 (cortex-m33-arm-cpu cpu [halted ]) 0x00000000 in ?? ()"
msgstr ""

#: ../../../system/gdb.rst:97
msgid ""
"You probably also want to set gdb to ``schedule-multiple`` mode, so that "
"when you tell gdb to ``continue`` it resumes all CPUs, not just those in the "
"cluster you are currently working on::"
msgstr ""

#: ../../../system/gdb.rst:101
msgid "(gdb) set schedule-multiple on"
msgstr ""

#: ../../../system/gdb.rst:104
msgid "Advanced debugging options"
msgstr ""

#: ../../../system/gdb.rst:107
msgid "Changing single-stepping behaviour"
msgstr ""

#: ../../../system/gdb.rst:109
msgid ""
"The default single stepping behavior is step with the IRQs and timer service "
"routines off. It is set this way because when gdb executes a single step it "
"expects to advance beyond the current instruction. With the IRQs and timer "
"service routines on, a single step might jump into the one of the interrupt "
"or exception vectors instead of executing the current instruction. This "
"means you may hit the same breakpoint a number of times before executing the "
"instruction gdb wants to have executed. Because there are rare circumstances "
"where you want to single step into an interrupt vector the behavior can be "
"controlled from GDB. There are three commands you can query and set the "
"single step behavior:"
msgstr ""

#: ../../../system/gdb.rst:120
msgid "``maintenance packet qqemu.sstepbits``"
msgstr ""

#: ../../../system/gdb.rst:121
msgid "This will display the MASK bits used to control the single stepping IE:"
msgstr ""

#: ../../../system/gdb.rst:126
msgid ""
"(gdb) maintenance packet qqemu.sstepbits\n"
"sending: \"qqemu.sstepbits\"\n"
"received: \"ENABLE=1,NOIRQ=2,NOTIMER=4\""
msgstr ""

#: ../../../system/gdb.rst:130
msgid "``maintenance packet qqemu.sstep``"
msgstr ""

#: ../../../system/gdb.rst:131
msgid ""
"This will display the current value of the mask used when single stepping IE:"
msgstr ""

#: ../../../system/gdb.rst:136
msgid ""
"(gdb) maintenance packet qqemu.sstep\n"
"sending: \"qqemu.sstep\"\n"
"received: \"0x7\""
msgstr ""

#: ../../../system/gdb.rst:140
msgid "``maintenance packet Qqemu.sstep=HEX_VALUE``"
msgstr ""

#: ../../../system/gdb.rst:141
msgid ""
"This will change the single step mask, so if wanted to enable IRQs on the "
"single step, but not timers, you would use:"
msgstr ""

#: ../../../system/gdb.rst:146
msgid ""
"(gdb) maintenance packet Qqemu.sstep=0x5\n"
"sending: \"qemu.sstep=0x5\"\n"
"received: \"OK\""
msgstr ""

#: ../../../system/gdb.rst:151
msgid "Examining physical memory"
msgstr ""

#: ../../../system/gdb.rst:153
msgid ""
"Another feature that QEMU gdbstub provides is to toggle the memory GDB works "
"with, by default GDB will show the current process memory respecting the "
"virtual address translation."
msgstr ""

#: ../../../system/gdb.rst:157
msgid ""
"If you want to examine/change the physical memory you can set the gdbstub to "
"work with the physical memory rather with the virtual one."
msgstr ""

#: ../../../system/gdb.rst:160
msgid "The memory mode can be checked by sending the following command:"
msgstr ""

#: ../../../system/gdb.rst:162
msgid "``maintenance packet qqemu.PhyMemMode``"
msgstr ""

#: ../../../system/gdb.rst:163
msgid ""
"This will return either 0 or 1, 1 indicates you are currently in the "
"physical memory mode."
msgstr ""

#: ../../../system/gdb.rst:166
msgid "``maintenance packet Qqemu.PhyMemMode:1``"
msgstr ""

#: ../../../system/gdb.rst:167
msgid "This will change the memory mode to physical memory."
msgstr ""

#: ../../../system/gdb.rst:169
msgid "``maintenance packet Qqemu.PhyMemMode:0``"
msgstr ""

#: ../../../system/gdb.rst:170
msgid "This will change it back to normal memory mode."
msgstr ""
