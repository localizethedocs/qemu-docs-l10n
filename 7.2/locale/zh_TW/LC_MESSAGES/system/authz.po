# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 7.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../system/authz.rst:4
msgid "Client authorization"
msgstr ""

#: ../../../system/authz.rst:6
msgid ""
"When configuring a QEMU network backend with either TLS certificates or SASL "
"authentication, access will be granted if the client successfully proves "
"their identity. If the authorization identity database is scoped to the QEMU "
"client this may be sufficient. It is common, however, for the identity "
"database to be much broader and thus authentication alone does not enable "
"sufficient access control. In this case QEMU provides a flexible system for "
"enforcing finer grained authorization on clients post-authentication."
msgstr ""

#: ../../../system/authz.rst:15
msgid "Identity providers"
msgstr ""

#: ../../../system/authz.rst:17
msgid ""
"At the time of writing there are two authentication frameworks used by QEMU "
"that emit an identity upon completion."
msgstr ""

#: ../../../system/authz.rst:20
msgid "TLS x509 certificate distinguished name."
msgstr ""

#: ../../../system/authz.rst:22
msgid ""
"When configuring the QEMU backend as a network server with TLS, there are a "
"choice of credentials to use. The most common scenario is to utilize x509 "
"certificates. The simplest configuration only involves issuing certificates "
"to the servers, allowing the client to avoid a MITM attack against their "
"intended server."
msgstr ""

#: ../../../system/authz.rst:28
msgid ""
"It is possible, however, to enable mutual verification by requiring that the "
"client provide a certificate to the server to prove its own identity. This "
"is done by setting the property ``verify-peer=yes`` on the ``tls-creds-"
"x509`` object, which is in fact the default."
msgstr ""

#: ../../../system/authz.rst:33
msgid ""
"When peer verification is enabled, client will need to be issued with a "
"certificate by the same certificate authority as the server. If this is "
"still not sufficiently strong access control the Distinguished Name of the "
"certificate can be used as an identity in the QEMU authorization framework."
msgstr ""

#: ../../../system/authz.rst:39
msgid "SASL username."
msgstr ""

#: ../../../system/authz.rst:41
msgid ""
"When configuring the QEMU backend as a network server with SASL, upon "
"completion of the SASL authentication mechanism, a username will be "
"provided. The format of this username will vary depending on the choice of "
"mechanism configured for SASL. It might be a simple UNIX style user "
"``joebloggs``, while if using Kerberos/GSSAPI it can have a realm attached "
"``joebloggs@QEMU.ORG``.  Whatever format the username is presented in, it "
"can be used with the QEMU authorization framework."
msgstr ""

#: ../../../system/authz.rst:50
msgid "Authorization drivers"
msgstr ""

#: ../../../system/authz.rst:52
msgid ""
"The QEMU authorization framework is a general purpose design with choice of "
"user customizable drivers. These are provided as objects that can be created "
"at startup using the ``-object`` argument, or at runtime using the "
"``object_add`` monitor command."
msgstr ""

#: ../../../system/authz.rst:58
msgid "Simple"
msgstr ""

#: ../../../system/authz.rst:60
msgid ""
"This authorization driver provides a simple mechanism for granting access "
"based on an exact match against a single identity. This is useful when it is "
"known that only a single client is to be allowed access."
msgstr ""

#: ../../../system/authz.rst:64
msgid ""
"A possible use case would be when configuring QEMU for an incoming live "
"migration. It is known exactly which source QEMU the migration is expected "
"to arrive from. The x509 certificate associated with this source QEMU would "
"thus be used as the identity to match against. Alternatively if the virtual "
"machine is dedicated to a specific tenant, then the VNC server would be "
"configured with SASL and the username of only that tenant listed."
msgstr ""

#: ../../../system/authz.rst:71
msgid "To create an instance of this driver via QMP:"
msgstr ""

#: ../../../system/authz.rst:75
msgid ""
"{\n"
"  \"execute\": \"object-add\",\n"
"  \"arguments\": {\n"
"    \"qom-type\": \"authz-simple\",\n"
"    \"id\": \"authz0\",\n"
"    \"identity\": \"fred\"\n"
"  }\n"
"}"
msgstr ""

#: ../../../system/authz.rst:85
msgid "Or via the command line"
msgstr ""

#: ../../../system/authz.rst:89
msgid "-object authz-simple,id=authz0,identity=fred"
msgstr ""

#: ../../../system/authz.rst:93
msgid "List"
msgstr ""

#: ../../../system/authz.rst:95
msgid ""
"In some network backends it will be desirable to grant access to a range of "
"clients. This authorization driver provides a list mechanism for granting "
"access by matching identities against a list of permitted one. Each match "
"rule has an associated policy and a catch all policy applies if no rule "
"matches. The match can either be done as an exact string comparison, or can "
"use the shell-like glob syntax, which allows for use of wildcards."
msgstr ""

#: ../../../system/authz.rst:102 ../../../system/authz.rst:133
#: ../../../system/authz.rst:182
msgid "To create an instance of this class via QMP:"
msgstr ""

#: ../../../system/authz.rst:106
msgid ""
"{\n"
"  \"execute\": \"object-add\",\n"
"  \"arguments\": {\n"
"    \"qom-type\": \"authz-list\",\n"
"    \"id\": \"authz0\",\n"
"    \"rules\": [\n"
"       { \"match\": \"fred\", \"policy\": \"allow\", \"format\": "
"\"exact\" },\n"
"       { \"match\": \"bob\", \"policy\": \"allow\", \"format\": "
"\"exact\" },\n"
"       { \"match\": \"danb\", \"policy\": \"deny\", \"format\": "
"\"exact\" },\n"
"       { \"match\": \"dan*\", \"policy\": \"allow\", \"format\": \"glob\" }\n"
"    ],\n"
"    \"policy\": \"deny\"\n"
"  }\n"
"}"
msgstr ""

#: ../../../system/authz.rst:122
msgid ""
"Due to the way this driver requires setting nested properties, creating it "
"on the command line will require use of the JSON syntax for ``-object``. In "
"most cases, however, the next driver will be more suitable."
msgstr ""

#: ../../../system/authz.rst:127
msgid "List file"
msgstr ""

#: ../../../system/authz.rst:129
msgid ""
"This is a variant on the previous driver that allows for a more dynamic "
"access control policy by storing the match rules in a standalone file that "
"can be reloaded automatically upon change."
msgstr ""

#: ../../../system/authz.rst:137
msgid ""
"{\n"
"  \"execute\": \"object-add\",\n"
"  \"arguments\": {\n"
"    \"qom-type\": \"authz-list-file\",\n"
"    \"id\": \"authz0\",\n"
"    \"filename\": \"/etc/qemu/myvm-vnc.acl\",\n"
"    \"refresh\": true\n"
"  }\n"
"}"
msgstr ""

#: ../../../system/authz.rst:148
msgid ""
"If ``refresh`` is ``yes``, inotify is used to monitor for changes to the "
"file and auto-reload the rules."
msgstr ""

#: ../../../system/authz.rst:151
msgid ""
"The ``myvm-vnc.acl`` file should contain the match rules in a format that "
"closely matches the previous driver:"
msgstr ""

#: ../../../system/authz.rst:156
msgid ""
"{\n"
"  \"rules\": [\n"
"    { \"match\": \"fred\", \"policy\": \"allow\", \"format\": \"exact\" },\n"
"    { \"match\": \"bob\", \"policy\": \"allow\", \"format\": \"exact\" },\n"
"    { \"match\": \"danb\", \"policy\": \"deny\", \"format\": \"exact\" },\n"
"    { \"match\": \"dan*\", \"policy\": \"allow\", \"format\": \"glob\" }\n"
"  ],\n"
"  \"policy\": \"deny\"\n"
"}"
msgstr ""

#: ../../../system/authz.rst:167
msgid "The object can be created on the command line using"
msgstr ""

#: ../../../system/authz.rst:171
msgid ""
"-object authz-list-file,id=authz0,\\\n"
"        filename=/etc/qemu/myvm-vnc.acl,refresh=on"
msgstr ""

#: ../../../system/authz.rst:176
msgid "PAM"
msgstr ""

#: ../../../system/authz.rst:178
msgid ""
"In some scenarios it might be desirable to integrate with authorization "
"mechanisms that are implemented outside of QEMU. In order to allow maximum "
"flexibility, QEMU provides a driver that uses the ``PAM`` framework."
msgstr ""

#: ../../../system/authz.rst:186
msgid ""
"{\n"
"  \"execute\": \"object-add\",\n"
"  \"arguments\": {\n"
"    \"qom-type\": \"authz-pam\",\n"
"    \"id\": \"authz0\",\n"
"    \"parameters\": {\n"
"      \"service\": \"qemu-vnc-tls\"\n"
"    }\n"
"  }\n"
"}"
msgstr ""

#: ../../../system/authz.rst:198
msgid ""
"The driver only uses the PAM \"account\" verification subsystem. The above "
"config would require a config file /etc/pam.d/qemu-vnc-tls. For a simple "
"file lookup it would contain"
msgstr ""

#: ../../../system/authz.rst:205
msgid ""
"account requisite  pam_listfile.so item=user sense=allow \\\n"
"        file=/etc/qemu/vnc.allow"
msgstr ""

#: ../../../system/authz.rst:209
msgid ""
"The external file would then contain a list of usernames. If x509 cert was "
"being used as the username, a suitable entry would match the distinguished "
"name:"
msgstr ""

#: ../../../system/authz.rst:215
msgid "CN=laptop.berrange.com,O=Berrange Home,L=London,ST=London,C=GB"
msgstr ""

#: ../../../system/authz.rst:218
msgid "On the command line it can be created using"
msgstr ""

#: ../../../system/authz.rst:222
msgid "-object authz-pam,id=authz0,service=qemu-vnc-tls"
msgstr ""

#: ../../../system/authz.rst:225
msgid ""
"There are a variety of PAM plugins that can be used which are not "
"illustrated here, and it is possible to implement brand new plugins using "
"the PAM API."
msgstr ""

#: ../../../system/authz.rst:230
msgid "Connecting backends"
msgstr ""

#: ../../../system/authz.rst:232
msgid ""
"The authorization driver is created using the ``-object`` argument and then "
"needs to be associated with a network service. The authorization driver "
"object will be given a unique ID that needs to be referenced."
msgstr ""

#: ../../../system/authz.rst:236
msgid ""
"The property to set in the network service will vary depending on the type "
"of identity to verify. By convention, any network server backend that uses "
"TLS will provide ``tls-authz`` property, while any server using SASL will "
"provide a ``sasl-authz`` property."
msgstr ""

#: ../../../system/authz.rst:241
msgid ""
"Thus an example using SASL and authorization for the VNC server would look "
"like:"
msgstr ""

#: ../../../system/authz.rst:246
msgid ""
"$QEMU --object authz-simple,id=authz0,identity=fred \\\n"
"      --vnc 0.0.0.0:1,sasl,sasl-authz=authz0"
msgstr ""

#: ../../../system/authz.rst:249
msgid "While to validate both the x509 certificate and SASL username:"
msgstr ""

#: ../../../system/authz.rst:253
msgid ""
"echo \"CN=laptop.qemu.org,O=QEMU Project,L=London,ST=London,C=GB\" >> tls."
"acl\n"
"$QEMU --object authz-simple,id=authz0,identity=fred \\\n"
"      --object authz-list-file,id=authz1,filename=tls.acl \\\n"
"      --object tls-creds-x509,id=tls0,dir=/etc/qemu/tls,verify-peer=yes \\\n"
"      --vnc 0.0.0.0:1,sasl,sasl-authz=auth0,tls-creds=tls0,tls-authz=authz1"
msgstr ""
