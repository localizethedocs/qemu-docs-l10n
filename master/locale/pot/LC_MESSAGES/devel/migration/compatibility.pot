# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/migration/compatibility.rst:2
msgid "Backwards compatibility"
msgstr ""

#: ../../../devel/migration/compatibility.rst:5
msgid "How backwards compatibility works"
msgstr ""

#: ../../../devel/migration/compatibility.rst:7
msgid ""
"When we do migration, we have two QEMU processes: the source and the "
"target.  There are two cases, they are the same version or they are "
"different versions.  The easy case is when they are the same version. The "
"difficult one is when they are different versions."
msgstr ""

#: ../../../devel/migration/compatibility.rst:12
msgid ""
"There are two things that are different, but they have very similar names "
"and sometimes get confused:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:15
msgid "QEMU version"
msgstr ""

#: ../../../devel/migration/compatibility.rst:16
msgid "machine type version"
msgstr ""

#: ../../../devel/migration/compatibility.rst:18
msgid "Let's start with a practical example, we start with:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:20
msgid "qemu-system-x86_64 (v5.2), from now on qemu-5.2."
msgstr ""

#: ../../../devel/migration/compatibility.rst:21
msgid "qemu-system-x86_64 (v5.1), from now on qemu-5.1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:23
msgid ""
"Related to this are the \"latest\" machine types defined on each of them:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:26
msgid "pc-q35-5.2 (newer one in qemu-5.2) from now on pc-5.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:27
msgid "pc-q35-5.1 (newer one in qemu-5.1) from now on pc-5.1"
msgstr ""

#: ../../../devel/migration/compatibility.rst:29
msgid ""
"First of all, migration is only supposed to work if you use the same machine "
"type in both source and destination. The QEMU hardware configuration needs "
"to be the same also on source and destination. Most aspects of the backend "
"configuration can be changed at will, except for a few cases where the "
"backend features influence frontend device feature exposure.  But that is "
"not relevant for this section."
msgstr ""

#: ../../../devel/migration/compatibility.rst:36
msgid ""
"I am going to list the number of combinations that we can have.  Let's start "
"with the trivial ones, QEMU is the same on source and destination:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:40
msgid "1 - qemu-5.2 -M pc-5.2  -> migrates to -> qemu-5.2 -M pc-5.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:42
msgid ""
"This is the latest QEMU with the latest machine type. This have to work, and "
"if it doesn't work it is a bug."
msgstr ""

#: ../../../devel/migration/compatibility.rst:45
msgid "2 - qemu-5.1 -M pc-5.1  -> migrates to -> qemu-5.1 -M pc-5.1"
msgstr ""

#: ../../../devel/migration/compatibility.rst:47
msgid ""
"Exactly the same case than the previous one, but for 5.1. Nothing to see "
"here either."
msgstr ""

#: ../../../devel/migration/compatibility.rst:50
msgid ""
"This are the easiest ones, we will not talk more about them in this section."
msgstr ""

#: ../../../devel/migration/compatibility.rst:53
msgid ""
"Now we start with the more interesting cases.  Consider the case where we "
"have the same QEMU version in both sides (qemu-5.2) but we are using the "
"latest machine type for that version (pc-5.2) but one of an older QEMU "
"version, in this case pc-5.1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:58
#: ../../../devel/migration/compatibility.rst:165
msgid "3 - qemu-5.2 -M pc-5.1  -> migrates to -> qemu-5.2 -M pc-5.1"
msgstr ""

#: ../../../devel/migration/compatibility.rst:60
msgid ""
"It needs to use the definition of pc-5.1 and the devices as they were "
"configured on 5.1, but this should be easy in the sense that both sides are "
"the same QEMU and both sides have exactly the same idea of what the pc-5.1 "
"machine is."
msgstr ""

#: ../../../devel/migration/compatibility.rst:65
msgid "4 - qemu-5.1 -M pc-5.2  -> migrates to -> qemu-5.1 -M pc-5.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:67
msgid ""
"This combination is not possible as the qemu-5.1 doesn't understand pc-5.2 "
"machine type.  So nothing to worry here."
msgstr ""

#: ../../../devel/migration/compatibility.rst:70
msgid ""
"Now it comes the interesting ones, when both QEMU processes are different.  "
"Notice also that the machine type needs to be pc-5.1, because we have the "
"limitation than qemu-5.1 doesn't know pc-5.2.  So the possible cases are:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:75
#: ../../../devel/migration/compatibility.rst:149
msgid "5 - qemu-5.2 -M pc-5.1  -> migrates to -> qemu-5.1 -M pc-5.1"
msgstr ""

#: ../../../devel/migration/compatibility.rst:77
msgid ""
"This migration is known as newer to older.  We need to make sure when we are "
"developing 5.2 we need to take care about not to break migration to "
"qemu-5.1.  Notice that we can't make updates to qemu-5.1 to understand "
"whatever qemu-5.2 decides to change, so it is in qemu-5.2 side to make the "
"relevant changes."
msgstr ""

#: ../../../devel/migration/compatibility.rst:83
#: ../../../devel/migration/compatibility.rst:156
msgid "6 - qemu-5.1 -M pc-5.1  -> migrates to -> qemu-5.2 -M pc-5.1"
msgstr ""

#: ../../../devel/migration/compatibility.rst:85
msgid ""
"This migration is known as older to newer.  We need to make sure than we are "
"able to receive migrations from qemu-5.1. The problem is similar to the "
"previous one."
msgstr ""

#: ../../../devel/migration/compatibility.rst:89
msgid ""
"If qemu-5.1 and qemu-5.2 were the same, there will not be any compatibility "
"problems.  But the reason that we create qemu-5.2 is to get new features, "
"devices, defaults, etc."
msgstr ""

#: ../../../devel/migration/compatibility.rst:93
msgid ""
"If we get a device that has a new feature, or change a default value, we "
"have a problem when we try to migrate between different QEMU versions."
msgstr ""

#: ../../../devel/migration/compatibility.rst:97
msgid ""
"So we need a way to tell qemu-5.2 that when we are using machine type "
"pc-5.1, it needs to **not** use the feature, to be able to migrate to real "
"qemu-5.1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:101
msgid ""
"And the equivalent part when migrating from qemu-5.1 to qemu-5.2. qemu-5.2 "
"has to expect that it is not going to get data for the new feature, because "
"qemu-5.1 doesn't know about it."
msgstr ""

#: ../../../devel/migration/compatibility.rst:105
msgid ""
"How do we tell QEMU about these device feature changes?  In hw/core/machine."
"c:hw_compat_X_Y arrays."
msgstr ""

#: ../../../devel/migration/compatibility.rst:108
msgid ""
"If we change a default value, we need to put back the old value on that "
"array.  And the device, during initialization needs to look at that array to "
"see what value it needs to get for that feature.  And what are we going to "
"put in that array, the value of a property."
msgstr ""

#: ../../../devel/migration/compatibility.rst:113
msgid ""
"To create a property for a device, we need to use one of the DEFINE_PROP_*() "
"macros. See include/hw/qdev-properties.h to find the macros that exist.  "
"With it, we set the default value for that property, and that is what it is "
"going to get in the latest released version.  But if we want a different "
"value for a previous version, we can change that in the hw_compat_X_Y arrays."
msgstr ""

#: ../../../devel/migration/compatibility.rst:120
msgid "hw_compat_X_Y is an array of registers that have the format:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:122
msgid "name_device"
msgstr ""

#: ../../../devel/migration/compatibility.rst:123
msgid "name_property"
msgstr ""

#: ../../../devel/migration/compatibility.rst:124
msgid "value"
msgstr ""

#: ../../../devel/migration/compatibility.rst:126
msgid "Let's see a practical example."
msgstr ""

#: ../../../devel/migration/compatibility.rst:128
msgid ""
"In qemu-5.2 virtio-blk-device got multi queue support.  This is a change "
"that is not backward compatible.  In qemu-5.1 it has one queue. In qemu-5.2 "
"it has the same number of queues as the number of cpus in the system."
msgstr ""

#: ../../../devel/migration/compatibility.rst:133
msgid ""
"When we are doing migration, if we migrate from a device that has 4 queues "
"to a device that have only one queue, we don't know where to put the extra "
"information for the other 3 queues, and we fail migration."
msgstr ""

#: ../../../devel/migration/compatibility.rst:138
msgid ""
"Similar problem when we migrate from qemu-5.1 that has only one queue to "
"qemu-5.2, we only sent information for one queue, but destination has 4, and "
"we have 3 queues that are not properly initialized and anything can happen."
msgstr ""

#: ../../../devel/migration/compatibility.rst:143
msgid ""
"So, how can we address this problem.  Easy, just convince qemu-5.2 that when "
"it is running pc-5.1, it needs to set the number of queues for virtio-blk-"
"devices to 1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:147
msgid "That way we fix the cases 5 and 6."
msgstr ""

#: ../../../devel/migration/compatibility.rst:151
msgid ""
"qemu-5.2 -M pc-5.1 sets number of queues to be 1. qemu-5.1 -M pc-5.1 expects "
"number of queues to be 1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:154
#: ../../../devel/migration/compatibility.rst:161
msgid "correct.  migration works."
msgstr ""

#: ../../../devel/migration/compatibility.rst:158
msgid ""
"qemu-5.1 -M pc-5.1 sets number of queues to be 1. qemu-5.2 -M pc-5.1 expects "
"number of queues to be 1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:163
msgid "And now the other interesting case, case 3.  In this case we have:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:167
msgid ""
"Here we have the same QEMU in both sides.  So it doesn't matter a lot if we "
"have set the number of queues to 1 or not, because they are the same."
msgstr ""

#: ../../../devel/migration/compatibility.rst:171
msgid "WRONG!"
msgstr ""

#: ../../../devel/migration/compatibility.rst:173
msgid "Think what happens if we do one of this double migrations:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:175
msgid "A -> migrates -> B -> migrates -> C"
msgstr ""

#: ../../../devel/migration/compatibility.rst:177
msgid "where:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:179
msgid "A: qemu-5.1 -M pc-5.1 B: qemu-5.2 -M pc-5.1 C: qemu-5.2 -M pc-5.1"
msgstr ""

#: ../../../devel/migration/compatibility.rst:183
msgid "migration A -> B is case 6, so number of queues needs to be 1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:185
msgid ""
"migration B -> C is case 3, so we don't care.  But actually we care because "
"we haven't started the guest in qemu-5.2, it came migrated from qemu-5.1.  "
"So to be in the safe place, we need to always use number of queues 1 when we "
"are using pc-5.1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:190
msgid ""
"Now, how was this done in reality?  The following commit shows how it was "
"done::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:193
msgid ""
"commit 9445e1e15e66c19e42bea942ba810db28052cd05\n"
"Author: Stefan Hajnoczi <stefanha@redhat.com>\n"
"Date:   Tue Aug 18 15:33:47 2020 +0100\n"
"\n"
"virtio-blk-pci: default num_queues to -smp N"
msgstr ""

#: ../../../devel/migration/compatibility.rst:199
msgid "The relevant parts for migration are::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:201
msgid ""
"@@ -1281,7 +1284,8 @@ static const Property virtio_blk_properties[] = {\n"
" #endif\n"
"     DEFINE_PROP_BIT(\"request-merging\", VirtIOBlock, conf.request_merging, "
"0,\n"
"                     true),\n"
"-    DEFINE_PROP_UINT16(\"num-queues\", VirtIOBlock, conf.num_queues, 1),\n"
"+    DEFINE_PROP_UINT16(\"num-queues\", VirtIOBlock, conf.num_queues,\n"
"+                       VIRTIO_BLK_AUTO_NUM_QUEUES),\n"
"     DEFINE_PROP_UINT16(\"queue-size\", VirtIOBlock, conf.queue_size, 256),"
msgstr ""

#: ../../../devel/migration/compatibility.rst:210
msgid ""
"It changes the default value of num_queues.  But it fishes it for old "
"machine types to have the right value::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:213
msgid ""
"@@ -31,6 +31,7 @@\n"
" GlobalProperty hw_compat_5_1[] = {\n"
"     ...\n"
"+    { \"virtio-blk-device\", \"num-queues\", \"1\"},\n"
"     ...\n"
" };"
msgstr ""

#: ../../../devel/migration/compatibility.rst:221
msgid "A device with different features on both sides"
msgstr ""

#: ../../../devel/migration/compatibility.rst:223
msgid ""
"Let's assume that we are using the same QEMU binary on both sides, just to "
"make the things easier.  But we have a device that has different features on "
"both sides of the migration.  That can be because the devices are different, "
"because the kernel driver of both devices have different features, whatever."
msgstr ""

#: ../../../devel/migration/compatibility.rst:229
msgid ""
"How can we get this to work with migration.  The way to do that is "
"\"theoretically\" easy.  You have to get the features that the device has in "
"the source of the migration.  The features that the device has on the target "
"of the migration, you get the intersection of the features of both sides, "
"and that is the way that you should launch QEMU."
msgstr ""

#: ../../../devel/migration/compatibility.rst:236
msgid ""
"Notice that this is not completely related to QEMU.  The most important "
"thing here is that this should be handled by the managing application that "
"launches QEMU.  If QEMU is configured correctly, the migration will succeed."
msgstr ""

#: ../../../devel/migration/compatibility.rst:241
msgid ""
"That said, actually doing it is complicated.  Almost all devices are bad at "
"being able to be launched with only some features enabled. With one big "
"exception: cpus."
msgstr ""

#: ../../../devel/migration/compatibility.rst:245
msgid "You can read the documentation for QEMU x86 cpu models here:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:247
msgid "https://qemu-project.gitlab.io/qemu/system/qemu-cpu-models.html"
msgstr ""

#: ../../../devel/migration/compatibility.rst:249
msgid ""
"See when they talk about migration they recommend that one chooses the "
"newest cpu model that is supported for all cpus."
msgstr ""

#: ../../../devel/migration/compatibility.rst:252
msgid "Let's say that we have:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:254
#: ../../../devel/migration/compatibility.rst:268
#: ../../../devel/migration/compatibility.rst:292
msgid "Host A:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:256
msgid "Device X has the feature Y"
msgstr ""

#: ../../../devel/migration/compatibility.rst:258
#: ../../../devel/migration/compatibility.rst:272
#: ../../../devel/migration/compatibility.rst:296
msgid "Host B:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:260
msgid "Device X has not the feature Y"
msgstr ""

#: ../../../devel/migration/compatibility.rst:262
msgid ""
"If we try to migrate without any care from host A to host B, it will fail "
"because when migration tries to load the feature Y on destination, it will "
"find that the hardware is not there."
msgstr ""

#: ../../../devel/migration/compatibility.rst:266
msgid "Doing this would be the equivalent of doing with cpus:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:270
#: ../../../devel/migration/compatibility.rst:274
msgid "$ qemu-system-x86_64 -cpu host"
msgstr ""

#: ../../../devel/migration/compatibility.rst:276
msgid ""
"When both hosts have different cpu features this is guaranteed to fail.  "
"Especially if Host B has less features than host A.  If host A has less "
"features than host B, sometimes it works.  Important word of last sentence "
"is \"sometimes\"."
msgstr ""

#: ../../../devel/migration/compatibility.rst:281
msgid ""
"So, forgetting about cpu models and continuing with the -cpu host example, "
"let's see that the differences of the cpus is that Host A and B have the "
"following features:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:285
msgid ""
"Features:   'pcid'  'stibp' 'taa-no' Host A:        X       X Host "
"B:                        X"
msgstr ""

#: ../../../devel/migration/compatibility.rst:289
msgid ""
"And we want to migrate between them, the way configure both QEMU cpu will be:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:294
msgid "$ qemu-system-x86_64 -cpu host,pcid=off,stibp=off"
msgstr ""

#: ../../../devel/migration/compatibility.rst:298
msgid "$ qemu-system-x86_64 -cpu host,taa-no=off"
msgstr ""

#: ../../../devel/migration/compatibility.rst:300
msgid ""
"And you would be able to migrate between them.  It is responsibility of the "
"management application or of the user to make sure that the configuration is "
"correct.  QEMU doesn't know how to look at this kind of features in general."
msgstr ""

#: ../../../devel/migration/compatibility.rst:305
msgid ""
"Notice that we don't recommend to use -cpu host for migration.  It is used "
"in this example because it makes the example simpler."
msgstr ""

#: ../../../devel/migration/compatibility.rst:308
msgid ""
"Other devices have worse control about individual features.  If they want to "
"be able to migrate between hosts that show different features, the device "
"needs a way to configure which ones it is going to use."
msgstr ""

#: ../../../devel/migration/compatibility.rst:312
msgid ""
"In this section we have considered that we are using the same QEMU binary in "
"both sides of the migration.  If we use different QEMU versions process, "
"then we need to have into account all other differences and the examples "
"become even more complicated."
msgstr ""

#: ../../../devel/migration/compatibility.rst:318
msgid "How to mitigate when we have a backward compatibility error"
msgstr ""

#: ../../../devel/migration/compatibility.rst:320
msgid ""
"We broke migration for old machine types continuously during development.  "
"But as soon as we find that there is a problem, we fix it.  The problem is "
"what happens when we detect after we have done a release that something has "
"gone wrong."
msgstr ""

#: ../../../devel/migration/compatibility.rst:325
msgid "Let see how it worked with one example."
msgstr ""

#: ../../../devel/migration/compatibility.rst:327
msgid ""
"After the release of qemu-8.0 we found a problem when doing migration of the "
"machine type pc-7.2."
msgstr ""

#: ../../../devel/migration/compatibility.rst:330
#: ../../../devel/migration/compatibility.rst:467
msgid "$ qemu-7.2 -M pc-7.2  ->  qemu-7.2 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:332
#: ../../../devel/migration/compatibility.rst:336
msgid "This migration works"
msgstr ""

#: ../../../devel/migration/compatibility.rst:334
#: ../../../devel/migration/compatibility.rst:468
msgid "$ qemu-8.0 -M pc-7.2  ->  qemu-8.0 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:338
#: ../../../devel/migration/compatibility.rst:476
msgid "$ qemu-8.0 -M pc-7.2  ->  qemu-7.2 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:340
#: ../../../devel/migration/compatibility.rst:344
msgid "This migration fails"
msgstr ""

#: ../../../devel/migration/compatibility.rst:342
#: ../../../devel/migration/compatibility.rst:475
msgid "$ qemu-7.2 -M pc-7.2  ->  qemu-8.0 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:346
msgid ""
"So clearly something fails when migration between qemu-7.2 and qemu-8.0 with "
"machine type pc-7.2.  The error messages, and git bisect pointed to this "
"commit."
msgstr ""

#: ../../../devel/migration/compatibility.rst:350
msgid "In qemu-8.0 we got this commit::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:352
msgid ""
"commit 010746ae1db7f52700cb2e2c46eb94f299cfa0d2\n"
"Author: Jonathan Cameron <Jonathan.Cameron@huawei.com>\n"
"Date:   Thu Mar 2 13:37:02 2023 +0000\n"
"\n"
"hw/pci/aer: Implement PCI_ERR_UNCOR_MASK register"
msgstr ""

#: ../../../devel/migration/compatibility.rst:359
msgid "The relevant bits of the commit for our example are this ones::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:361
msgid ""
"--- a/hw/pci/pcie_aer.c\n"
"+++ b/hw/pci/pcie_aer.c\n"
"@@ -112,6 +112,10 @@ int pcie_aer_init(PCIDevice *dev,\n"
"\n"
"     pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n"
"                  PCI_ERR_UNC_SUPPORTED);\n"
"+    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_MASK,\n"
"+                 PCI_ERR_UNC_MASK_DEFAULT);\n"
"+    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_MASK,\n"
"+                 PCI_ERR_UNC_SUPPORTED);\n"
"\n"
"     pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n"
"                 PCI_ERR_UNC_SEVERITY_DEFAULT);"
msgstr ""

#: ../../../devel/migration/compatibility.rst:375
msgid ""
"The patch changes how we configure PCI space for AER.  But QEMU fails when "
"the PCI space configuration is different between source and destination."
msgstr ""

#: ../../../devel/migration/compatibility.rst:379
msgid "The following commit shows how this got fixed::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:381
msgid ""
"commit 5ed3dabe57dd9f4c007404345e5f5bf0e347317f\n"
"Author: Leonardo Bras <leobras@redhat.com>\n"
"Date:   Tue May 2 21:27:02 2023 -0300\n"
"\n"
"hw/pci: Disable PCI_ERR_UNCOR_MASK register for machine type < 8.0\n"
"\n"
"[...]"
msgstr ""

#: ../../../devel/migration/compatibility.rst:389
msgid "The relevant parts of the fix in QEMU are as follow:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:391
msgid ""
"First, we create a new property for the device to be able to configure the "
"old behaviour or the new behaviour::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:394
msgid ""
"diff --git a/hw/pci/pci.c b/hw/pci/pci.c\n"
"index 8a87ccc8b0..5153ad63d6 100644\n"
"--- a/hw/pci/pci.c\n"
"+++ b/hw/pci/pci.c\n"
"@@ -79,6 +79,8 @@ static const Property pci_props[] = {\n"
"     DEFINE_PROP_STRING(\"failover_pair_id\", PCIDevice,\n"
"                        failover_pair_id),\n"
"     DEFINE_PROP_UINT32(\"acpi-index\",  PCIDevice, acpi_index, 0),\n"
"+    DEFINE_PROP_BIT(\"x-pcie-err-unc-mask\", PCIDevice, cap_present,\n"
"+                    QEMU_PCIE_ERR_UNC_MASK_BITNR, true),\n"
" };"
msgstr ""

#: ../../../devel/migration/compatibility.rst:406
msgid "Notice that we enable the feature for new machine types."
msgstr ""

#: ../../../devel/migration/compatibility.rst:408
msgid ""
"Now we see how the fix is done.  This is going to depend on what kind of "
"breakage happens, but in this case it is quite simple::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:411
msgid ""
"diff --git a/hw/pci/pcie_aer.c b/hw/pci/pcie_aer.c\n"
"index 103667c368..374d593ead 100644\n"
"--- a/hw/pci/pcie_aer.c\n"
"+++ b/hw/pci/pcie_aer.c\n"
"@@ -112,10 +112,13 @@ int pcie_aer_init(PCIDevice *dev, uint8_t cap_ver,\n"
"uint16_t offset,\n"
"\n"
"     pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n"
"                  PCI_ERR_UNC_SUPPORTED);\n"
"-    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_MASK,\n"
"-                 PCI_ERR_UNC_MASK_DEFAULT);\n"
"-    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_MASK,\n"
"-                 PCI_ERR_UNC_SUPPORTED);\n"
"+\n"
"+    if (dev->cap_present & QEMU_PCIE_ERR_UNC_MASK) {\n"
"+        pci_set_long(dev->config + offset + PCI_ERR_UNCOR_MASK,\n"
"+                     PCI_ERR_UNC_MASK_DEFAULT);\n"
"+        pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_MASK,\n"
"+                     PCI_ERR_UNC_SUPPORTED);\n"
"+    }\n"
"\n"
"     pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n"
"                  PCI_ERR_UNC_SEVERITY_DEFAULT);"
msgstr ""

#: ../../../devel/migration/compatibility.rst:435
msgid ""
"I.e. If the property bit is enabled, we configure it as we did for "
"qemu-8.0.  If the property bit is not set, we configure it as it was in 7.2."
msgstr ""

#: ../../../devel/migration/compatibility.rst:438
msgid ""
"And now, everything that is missing is disabling the feature for old machine "
"types::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:441
msgid ""
"diff --git a/hw/core/machine.c b/hw/core/machine.c\n"
"index 47a34841a5..07f763eb2e 100644\n"
"--- a/hw/core/machine.c\n"
"+++ b/hw/core/machine.c\n"
"@@ -48,6 +48,7 @@ GlobalProperty hw_compat_7_2[] = {\n"
"     { \"e1000e\", \"migrate-timadj\", \"off\" },\n"
"     { \"virtio-mem\", \"x-early-migration\", \"false\" },\n"
"     { \"migration\", \"x-preempt-pre-7-2\", \"true\" },\n"
"+    { TYPE_PCI_DEVICE, \"x-pcie-err-unc-mask\", \"off\" },\n"
" };\n"
" const size_t hw_compat_7_2_len = G_N_ELEMENTS(hw_compat_7_2);"
msgstr ""

#: ../../../devel/migration/compatibility.rst:453
msgid ""
"And now, when qemu-8.0.1 is released with this fix, all combinations are "
"going to work as supposed."
msgstr ""

#: ../../../devel/migration/compatibility.rst:456
msgid "$ qemu-7.2 -M pc-7.2  ->  qemu-7.2 -M pc-7.2 (works)"
msgstr ""

#: ../../../devel/migration/compatibility.rst:457
msgid "$ qemu-8.0.1 -M pc-7.2  ->  qemu-8.0.1 -M pc-7.2 (works)"
msgstr ""

#: ../../../devel/migration/compatibility.rst:458
msgid "$ qemu-8.0.1 -M pc-7.2  ->  qemu-7.2 -M pc-7.2 (works)"
msgstr ""

#: ../../../devel/migration/compatibility.rst:459
msgid "$ qemu-7.2 -M pc-7.2  ->  qemu-8.0.1 -M pc-7.2 (works)"
msgstr ""

#: ../../../devel/migration/compatibility.rst:461
msgid "So the normality has been restored and everything is ok, no?"
msgstr ""

#: ../../../devel/migration/compatibility.rst:463
msgid ""
"Not really, now our matrix is much bigger.  We started with the easy cases, "
"migration from the same version to the same version always works:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:469
msgid "$ qemu-8.0.1 -M pc-7.2  ->  qemu-8.0.1 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:471
msgid ""
"Now the interesting ones.  When the QEMU processes versions are different.  "
"For the 1st set, their fail and we can do nothing, both versions are "
"released and we can't change anything."
msgstr ""

#: ../../../devel/migration/compatibility.rst:478
msgid ""
"This two are the ones that work. The whole point of making the change in "
"qemu-8.0.1 release was to fix this issue:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:481
msgid "$ qemu-7.2 -M pc-7.2  ->  qemu-8.0.1 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:482
msgid "$ qemu-8.0.1 -M pc-7.2  ->  qemu-7.2 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:484
msgid ""
"But now we found that qemu-8.0 neither can migrate to qemu-7.2 not "
"qemu-8.0.1."
msgstr ""

#: ../../../devel/migration/compatibility.rst:487
#: ../../../devel/migration/compatibility.rst:497
msgid "$ qemu-8.0 -M pc-7.2  ->  qemu-8.0.1 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:488
msgid "$ qemu-8.0.1 -M pc-7.2  ->  qemu-8.0 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:490
msgid ""
"So, if we start a pc-7.2 machine in qemu-8.0 we can't migrate it to anything "
"except to qemu-8.0."
msgstr ""

#: ../../../devel/migration/compatibility.rst:493
msgid "Can we do better?"
msgstr ""

#: ../../../devel/migration/compatibility.rst:495
msgid "Yeap.  If we know that we are going to do this migration:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:499
msgid "We can launch the appropriate devices with::"
msgstr ""

#: ../../../devel/migration/compatibility.rst:501
msgid "--device...,x-pci-e-err-unc-mask=on"
msgstr ""

#: ../../../devel/migration/compatibility.rst:503
msgid ""
"And now we can receive a migration from 8.0.  And from now on, we can do "
"that migration to new machine types if we remember to enable that property "
"for pc-7.2.  Notice that we need to remember, it is not enough to know that "
"the source of the migration is qemu-8.0.  Think of this example:"
msgstr ""

#: ../../../devel/migration/compatibility.rst:509
msgid "$ qemu-8.0 -M pc-7.2 -> qemu-8.0.1 -M pc-7.2 -> qemu-8.2 -M pc-7.2"
msgstr ""

#: ../../../devel/migration/compatibility.rst:511
msgid ""
"In the second migration, the source is not qemu-8.0, but we still have that "
"\"problem\" and have that property enabled.  Notice that we need to continue "
"having this mark/property until we have this machine rebooted.  But it is "
"not a normal reboot (that don't reload QEMU) we need the machine to poweroff/"
"poweron on a fixed QEMU.  And from now on we can use the proper real machine."
msgstr ""
