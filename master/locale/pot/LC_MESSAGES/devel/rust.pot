# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/rust.rst:4
msgid "Rust in QEMU"
msgstr ""

#: ../../../devel/rust.rst:6
msgid ""
"Rust in QEMU is a project to enable using the Rust programming language to "
"add new functionality to QEMU."
msgstr ""

#: ../../../devel/rust.rst:9
msgid ""
"Right now, the focus is on making it possible to write devices that inherit "
"from ``SysBusDevice`` in `*safe*`__ Rust.  Later, it may become possible to "
"write other kinds of devices (e.g. PCI devices that can do DMA), complete "
"boards, or backends (e.g. block device formats)."
msgstr ""

#: ../../../devel/rust.rst:17
msgid "Building the Rust in QEMU code"
msgstr ""

#: ../../../devel/rust.rst:19
msgid ""
"The Rust in QEMU code is included in the emulators via Meson.  Meson invokes "
"rustc directly, building static libraries that are then linked together with "
"the C code.  This is completely automatic when you run ``make`` or ``ninja``."
msgstr ""

#: ../../../devel/rust.rst:24
msgid ""
"However, QEMU's build system also tries to be easy to use for people who are "
"accustomed to the more \"normal\" Cargo-based development workflow. In "
"particular:"
msgstr ""

#: ../../../devel/rust.rst:28
msgid ""
"the set of warnings and lints that are used to build QEMU always comes from "
"the ``rust/Cargo.toml`` workspace file"
msgstr ""

#: ../../../devel/rust.rst:31
msgid ""
"it is also possible to use ``cargo`` for common Rust-specific coding tasks, "
"in particular to invoke ``clippy``, ``rustfmt`` and ``rustdoc``."
msgstr ""

#: ../../../devel/rust.rst:34
msgid ""
"To this end, QEMU includes a ``build.rs`` build script that picks up "
"generated sources from QEMU's build directory and puts it in Cargo's output "
"directory (typically ``rust/target/``).  A vanilla invocation of Cargo will "
"complain that it cannot find the generated sources, which can be fixed in "
"different ways:"
msgstr ""

#: ../../../devel/rust.rst:40
msgid ""
"by using Makefile targets, provided by Meson, that run ``clippy`` or "
"``rustdoc``:"
msgstr ""

#: ../../../devel/rust.rst:43
msgid "make clippy make rustdoc"
msgstr ""

#: ../../../devel/rust.rst:46
msgid "A target for ``rustfmt`` is also declared in ``rust/meson.build``:"
msgstr ""

#: ../../../devel/rust.rst:48
msgid "make rustfmt"
msgstr ""

#: ../../../devel/rust.rst:50
msgid ""
"by invoking ``cargo`` through the Meson `development environment`__ feature::"
msgstr ""

#: ../../../devel/rust.rst:53
msgid ""
"pyvenv/bin/meson devenv -w ../rust cargo clippy --tests\n"
"pyvenv/bin/meson devenv -w ../rust cargo fmt"
msgstr ""

#: ../../../devel/rust.rst:56
msgid ""
"If you are going to use ``cargo`` repeatedly, ``pyvenv/bin/meson devenv`` "
"will enter a shell where commands like ``cargo fmt`` just work."
msgstr ""

#: ../../../devel/rust.rst:61
msgid ""
"by pointing the ``MESON_BUILD_ROOT`` to the top of your QEMU build tree.  "
"This third method is useful if you are using ``rust-analyzer``; you can set "
"the environment variable through the ``rust-analyzer.cargo.extraEnv`` "
"setting."
msgstr ""

#: ../../../devel/rust.rst:66
msgid ""
"As shown above, you can use the ``--tests`` option as usual to operate on "
"test code.  Note however that you cannot *build* or run tests via ``cargo``, "
"because they need support C code from QEMU that Cargo does not know about.  "
"Tests can be run via Meson (``pyvenv/bin/meson test``) or ``make``::"
msgstr ""

#: ../../../devel/rust.rst:71
msgid "make check-rust"
msgstr ""

#: ../../../devel/rust.rst:73
msgid ""
"Note that doctests require all ``.o`` files from the build to be available."
msgstr ""

#: ../../../devel/rust.rst:76
msgid "Supported tools"
msgstr ""

#: ../../../devel/rust.rst:78
msgid ""
"QEMU supports rustc version 1.83.0 and newer.  The following features from "
"relatively new versions of Rust are not used for historical reasons; patches "
"are welcome:"
msgstr ""

#: ../../../devel/rust.rst:82
msgid ""
"associated constants are still explicitly marked ``'static`` (`changed in "
"1.81.0`__)"
msgstr ""

#: ../../../devel/rust.rst:85
msgid "``&raw`` (stable in 1.82.0)."
msgstr ""

#: ../../../devel/rust.rst:87
msgid ""
"NUL-terminated file names with ``#[track_caller]`` are scheduled for "
"inclusion as ``#![feature(location_file_nul)]``, but it will be a while "
"before QEMU can use them.  For now, there is special code in ``util/error."
"c`` to support non-NUL-terminated file names."
msgstr ""

#: ../../../devel/rust.rst:92
msgid ""
"Associated const equality would be nice to have for some users of "
"``callbacks::FnCall``, but is still experimental.  Const assertions are used "
"instead."
msgstr ""

#: ../../../devel/rust.rst:98
msgid ""
"QEMU also supports version 0.60.x of bindgen, which is missing option ``--"
"generate-cstr``.  This option requires version 0.66.x and will be adopted as "
"soon as supporting these older versions is not necessary anymore."
msgstr ""

#: ../../../devel/rust.rst:104
msgid "Writing Rust code in QEMU"
msgstr ""

#: ../../../devel/rust.rst:106
msgid "QEMU includes several crates:"
msgstr ""

#: ../../../devel/rust.rst:108
msgid "``common`` provides Rust-only utilities"
msgstr ""

#: ../../../devel/rust.rst:110
msgid ""
"``bql``, ``chardev``, ``hw/core``, ``migration``, ``qom``, ``system``, "
"``util`` for bindings to respective QEMU C library APIs"
msgstr ""

#: ../../../devel/rust.rst:113
msgid ""
"``qemu_macros`` defines several procedural macros that are useful when "
"writing C code"
msgstr ""

#: ../../../devel/rust.rst:116
msgid ""
"``pl011`` (under ``rust/hw/char/pl011``) and ``hpet`` (under ``rust/hw/timer/"
"hpet``) are sample devices that demonstrate Rust binding usage and "
"``qemu_macros``, and are used to further develop them.  These two crates are "
"functional\\ [#issues]_ replacements for the ``hw/char/pl011.c`` and ``hw/"
"timer/hpet.c`` files."
msgstr ""

#: ../../../devel/rust.rst:121
msgid ""
"The ``pl011`` crate is synchronized with ``hw/char/pl011.c`` as of commit "
"3e0f118f82.  The ``hpet`` crate is synchronized as of commit 1433e38cc8.  "
"Both are lacking tracing functionality."
msgstr ""

#: ../../../devel/rust.rst:125
msgid "This section explains how to work with them."
msgstr ""

#: ../../../devel/rust.rst:128
msgid "Status"
msgstr ""

#: ../../../devel/rust.rst:130
msgid "The stability of the modules can be defined as:"
msgstr ""

#: ../../../devel/rust.rst:132
msgid ""
"*complete*: ready for use in new devices; if applicable, the API supports "
"the full functionality available in C"
msgstr ""

#: ../../../devel/rust.rst:135
msgid ""
"*stable*: ready for production use, the API is safe and should not undergo "
"major changes"
msgstr ""

#: ../../../devel/rust.rst:138
msgid ""
"*proof of concept*: the API is subject to change but allows working with "
"safe Rust"
msgstr ""

#: ../../../devel/rust.rst:141
msgid ""
"*initial*: the API is in its initial stages; it requires large amount of "
"unsafe code; it might have soundness or type-safety issues"
msgstr ""

#: ../../../devel/rust.rst:144
msgid "The status of the modules is as follows:"
msgstr ""

#: ../../../devel/rust.rst:147
msgid "module"
msgstr ""

#: ../../../devel/rust.rst:147
msgid "status"
msgstr ""

#: ../../../devel/rust.rst:149
msgid "``bql::cell``"
msgstr ""

#: ../../../devel/rust.rst:149 ../../../devel/rust.rst:150
#: ../../../devel/rust.rst:154 ../../../devel/rust.rst:156
#: ../../../devel/rust.rst:157 ../../../devel/rust.rst:159
#: ../../../devel/rust.rst:160 ../../../devel/rust.rst:161
#: ../../../devel/rust.rst:162 ../../../devel/rust.rst:165
msgid "stable"
msgstr ""

#: ../../../devel/rust.rst:150
msgid "``common::assertions``"
msgstr ""

#: ../../../devel/rust.rst:151
msgid "``common::bitops``"
msgstr ""

#: ../../../devel/rust.rst:151 ../../../devel/rust.rst:152
#: ../../../devel/rust.rst:153 ../../../devel/rust.rst:155
#: ../../../devel/rust.rst:164
msgid "complete"
msgstr ""

#: ../../../devel/rust.rst:152
msgid "``common::callbacks``"
msgstr ""

#: ../../../devel/rust.rst:153
msgid "``common::errno``"
msgstr ""

#: ../../../devel/rust.rst:154
msgid "``common::zeroable``"
msgstr ""

#: ../../../devel/rust.rst:155
msgid "``hwcore::irq``"
msgstr ""

#: ../../../devel/rust.rst:156
msgid "``hwcore::qdev``"
msgstr ""

#: ../../../devel/rust.rst:157
msgid "``hwcore::sysbus``"
msgstr ""

#: ../../../devel/rust.rst:158
msgid "``migration::migratable``"
msgstr ""

#: ../../../devel/rust.rst:158 ../../../devel/rust.rst:163
msgid "proof of concept"
msgstr ""

#: ../../../devel/rust.rst:159
msgid "``migration::vmstate``"
msgstr ""

#: ../../../devel/rust.rst:160
msgid "``qom``"
msgstr ""

#: ../../../devel/rust.rst:161
msgid "``system::memory``"
msgstr ""

#: ../../../devel/rust.rst:162
msgid "``util::error``"
msgstr ""

#: ../../../devel/rust.rst:163
msgid "``util::log``"
msgstr ""

#: ../../../devel/rust.rst:164
msgid "``util::module``"
msgstr ""

#: ../../../devel/rust.rst:165
msgid "``util::timer``"
msgstr ""

#: ../../../devel/rust.rst:169
msgid ""
"API stability is not a promise, if anything because the C APIs are not a "
"stable interface either.  Also, ``unsafe`` interfaces may be replaced by "
"safe interfaces later."
msgstr ""

#: ../../../devel/rust.rst:174
msgid "Naming convention"
msgstr ""

#: ../../../devel/rust.rst:176
msgid ""
"C function names usually are prefixed according to the data type that they "
"apply to, for example ``timer_mod`` or ``sysbus_connect_irq``.  Furthermore, "
"both function and structs sometimes have a ``qemu_`` or ``QEMU`` prefix. "
"Generally speaking, these are all removed in the corresponding Rust "
"functions: ``QEMUTimer`` becomes ``timer::Timer``, ``timer_mod`` becomes "
"``Timer::modify``, ``sysbus_connect_irq`` becomes ``SysBusDeviceMethods::"
"connect_irq``."
msgstr ""

#: ../../../devel/rust.rst:183
msgid ""
"Sometimes however a name appears multiple times in the QOM class hierarchy, "
"and the only difference is in the prefix.  An example is ``qdev_realize`` "
"and ``sysbus_realize``.  In such cases, whenever a name is not unique in the "
"hierarchy, always add the prefix to the classes that are lower in the "
"hierarchy; for the top class, decide on a case by case basis."
msgstr ""

#: ../../../devel/rust.rst:189
msgid "For example:"
msgstr ""

#: ../../../devel/rust.rst:192
msgid "``device_cold_reset()``"
msgstr ""

#: ../../../devel/rust.rst:192
msgid "``DeviceMethods::cold_reset()``"
msgstr ""

#: ../../../devel/rust.rst:193
msgid "``pci_device_reset()``"
msgstr ""

#: ../../../devel/rust.rst:193
msgid "``PciDeviceMethods::pci_device_reset()``"
msgstr ""

#: ../../../devel/rust.rst:194
msgid "``pci_bridge_reset()``"
msgstr ""

#: ../../../devel/rust.rst:194
msgid "``PciBridgeMethods::pci_bridge_reset()``"
msgstr ""

#: ../../../devel/rust.rst:197
msgid ""
"Here, the name is not exactly the same, but nevertheless "
"``PciDeviceMethods`` adds the prefix to avoid confusion, because the "
"functionality of ``device_cold_reset()`` and ``pci_device_reset()`` is "
"subtly different."
msgstr ""

#: ../../../devel/rust.rst:201
msgid "In this case, however, no prefix is needed:"
msgstr ""

#: ../../../devel/rust.rst:204
msgid "``device_realize()``"
msgstr ""

#: ../../../devel/rust.rst:204
msgid "``DeviceMethods::realize()``"
msgstr ""

#: ../../../devel/rust.rst:205
msgid "``sysbus_realize()``"
msgstr ""

#: ../../../devel/rust.rst:205
msgid "``SysbusDeviceMethods::sysbus_realize()``"
msgstr ""

#: ../../../devel/rust.rst:206
msgid "``pci_realize()``"
msgstr ""

#: ../../../devel/rust.rst:206
msgid "``PciDeviceMethods::pci_realize()``"
msgstr ""

#: ../../../devel/rust.rst:209
msgid ""
"Here, the lower classes do not add any functionality, and mostly provide "
"extra compile-time checking; the basic *realize* functionality is the same "
"for all devices.  Therefore, ``DeviceMethods`` does not add the prefix."
msgstr ""

#: ../../../devel/rust.rst:214
msgid ""
"Whenever a name is unique in the hierarchy, instead, you should always "
"remove the class name prefix."
msgstr ""

#: ../../../devel/rust.rst:218
msgid "Common pitfalls"
msgstr ""

#: ../../../devel/rust.rst:220
msgid ""
"Rust has very strict rules with respect to how you get an exclusive "
"(``&mut``) reference; failure to respect those rules is a source of "
"undefined behavior. In particular, even if a value is loaded from a raw "
"mutable pointer (``*mut``), it *cannot* be casted to ``&mut`` unless the "
"value was stored to the ``*mut`` from a mutable reference.  Furthermore, it "
"is undefined behavior if any shared reference was created between the store "
"to the ``*mut`` and the load::"
msgstr ""

#: ../../../devel/rust.rst:227
msgid ""
"let mut p: u32 = 42;\n"
"let p_mut = &mut p;                              // 1\n"
"let p_raw = p_mut as *mut u32;                   // 2\n"
"\n"
"// p_raw keeps the mutable reference \"alive\"\n"
"\n"
"let p_shared = &p;                               // 3\n"
"println!(\"access from &u32: {}\", *p_shared);\n"
"\n"
"// Bring back the mutable reference, its lifetime overlaps\n"
"// with that of a shared reference.\n"
"let p_mut = unsafe { &mut *p_raw };              // 4\n"
"println!(\"access from &mut 32: {}\", *p_mut);\n"
"\n"
"println!(\"access from &u32: {}\", *p_shared);     // 5"
msgstr ""

#: ../../../devel/rust.rst:243
msgid "These rules can be tested with `MIRI`__, for example."
msgstr ""

#: ../../../devel/rust.rst:247
msgid ""
"Almost all Rust code in QEMU will involve QOM objects, and pointers to these "
"objects are *shared*, for example because they are part of the QOM "
"composition tree.  This creates exactly the above scenario:"
msgstr ""

#: ../../../devel/rust.rst:251
msgid "a QOM object is created"
msgstr ""

#: ../../../devel/rust.rst:253
msgid ""
"a ``*mut`` is created, for example as the opaque value for a ``MemoryRegion``"
msgstr ""

#: ../../../devel/rust.rst:255
msgid "the QOM object is placed in the composition tree"
msgstr ""

#: ../../../devel/rust.rst:257
msgid "a memory access dereferences the opaque value to a ``&mut``"
msgstr ""

#: ../../../devel/rust.rst:259
msgid "but the shared reference is still present in the composition tree"
msgstr ""

#: ../../../devel/rust.rst:261
msgid ""
"Because of this, QOM objects should almost always use ``&self`` instead of "
"``&mut self``; access to internal fields must use *interior mutability* to "
"go from a shared reference to a ``&mut``."
msgstr ""

#: ../../../devel/rust.rst:265
msgid ""
"Whenever C code provides you with an opaque ``void *``, avoid converting it "
"to a Rust mutable reference, and use a shared reference instead.  The ``bql::"
"cell`` module provides wrappers that can be used to tell the Rust compiler "
"about interior mutability, and optionally to enforce locking rules for the "
"\"Big QEMU Lock\".  In the future, similar cell types might also be provided "
"for ``AioContext``-based locking as well."
msgstr ""

#: ../../../devel/rust.rst:272
msgid ""
"In particular, device code will usually rely on the ``BqlRefCell`` and "
"``BqlCell`` type to ensure that data is accessed correctly under the \"Big "
"QEMU Lock\".  These cell types are also known to the ``vmstate`` crate, "
"which is able to \"look inside\" them when building an in-memory "
"representation of a ``struct``'s layout.  Note that the same is not true of "
"a ``RefCell`` or ``Mutex``."
msgstr ""

#: ../../../devel/rust.rst:279
msgid ""
"Bindings code instead will usually use the ``Opaque`` type, which hides the "
"contents of the underlying struct and can be easily converted to a raw "
"pointer, for use in calls to C functions.  It can be used for example as "
"follows::"
msgstr ""

#: ../../../devel/rust.rst:284
msgid ""
"#[repr(transparent)]\n"
"#[derive(Debug, common::Wrapper)]\n"
"pub struct Object(Opaque<bindings::Object>);"
msgstr ""

#: ../../../devel/rust.rst:288
msgid ""
"where the special ``derive`` macro provides useful methods such as "
"``from_raw``, ``as_ptr`, ``as_mut_ptr`` and ``raw_get``.  The bindings will "
"then manually check for the big QEMU lock with assertions, which allows the "
"wrapper to be declared thread-safe::"
msgstr ""

#: ../../../devel/rust.rst:293
msgid ""
"unsafe impl Send for Object {}\n"
"unsafe impl Sync for Object {}"
msgstr ""

#: ../../../devel/rust.rst:297
msgid "Writing bindings to C code"
msgstr ""

#: ../../../devel/rust.rst:299
msgid ""
"Here are some things to keep in mind when working on the QEMU Rust crate."
msgstr ""

#: ../../../devel/rust.rst:301
msgid "**Look at existing code**"
msgstr ""

#: ../../../devel/rust.rst:302
msgid ""
"Very often, similar idioms in C code correspond to similar tricks in Rust "
"bindings.  If the C code uses ``offsetof``, look at qdev properties or "
"``vmstate``.  If the C code has a complex const struct, look at "
"``MemoryRegion``.  Reuse existing patterns for handling lifetimes; for "
"example use ``&T`` for QOM objects that do not need a reference count "
"(including those that can be embedded in other objects) and ``Owned<T>`` for "
"those that need it."
msgstr ""

#: ../../../devel/rust.rst:310
msgid "**Use the type system**"
msgstr ""

#: ../../../devel/rust.rst:311
msgid ""
"Bindings often will need access information that is specific to a type "
"(either a builtin one or a user-defined one) in order to pass it to C "
"functions.  Put them in a trait and access it through generic parameters. "
"The ``vmstate`` module has examples of how to retrieve type information for "
"the fields of a Rust ``struct``."
msgstr ""

#: ../../../devel/rust.rst:317
msgid "**Prefer unsafe traits to unsafe functions**"
msgstr ""

#: ../../../devel/rust.rst:318
msgid ""
"Unsafe traits are much easier to prove correct than unsafe functions. They "
"are an excellent place to store metadata that can later be accessed by "
"generic functions.  C code usually places metadata in global variables; in "
"Rust, they can be stored in traits and then turned into ``static`` "
"variables.  Often, unsafe traits can be generated by procedural macros."
msgstr ""

#: ../../../devel/rust.rst:324
msgid "**Document limitations due to old Rust versions**"
msgstr ""

#: ../../../devel/rust.rst:325
msgid ""
"If you need to settle for an inferior solution because of the currently "
"supported set of Rust versions, document it in the source and in this file.  "
"This ensures that it can be fixed when the minimum supported version is "
"bumped."
msgstr ""

#: ../../../devel/rust.rst:330
msgid "**Keep locking in mind**."
msgstr ""

#: ../../../devel/rust.rst:331
msgid ""
"When marking a type ``Sync``, be careful of whether it needs the big QEMU "
"lock.  Use ``BqlCell`` and ``BqlRefCell`` for interior data, or assert "
"``bql_locked()``."
msgstr ""

#: ../../../devel/rust.rst:335
msgid "**Don't be afraid of complexity, but document and isolate it**"
msgstr ""

#: ../../../devel/rust.rst:336
msgid ""
"It's okay to be tricky; device code is written more often than bindings code "
"and it's important that it is idiomatic.  However, you should strive to "
"isolate any tricks in a place (for example a ``struct``, a trait or a macro) "
"where it can be documented and tested.  If needed, include toy versions of "
"the code in the documentation."
msgstr ""

#: ../../../devel/rust.rst:343
msgid "Writing procedural macros"
msgstr ""

#: ../../../devel/rust.rst:345
msgid ""
"By conventions, procedural macros are split in two functions, one returning "
"``Result<proc_macro2::TokenStream, syn::Error>`` with the body of the "
"procedural macro, and the second returning ``proc_macro::TokenStream`` which "
"is the actual procedural macro.  The former's name is the same as the latter "
"with the ``_or_error`` suffix.  The code for the latter is more or less "
"fixed; it follows the following template, which is fixed apart from the type "
"after ``as`` in the invocation of ``parse_macro_input!``::"
msgstr ""

#: ../../../devel/rust.rst:353
msgid ""
"#[proc_macro_derive(Object)]\n"
"pub fn derive_object(input: TokenStream) -> TokenStream {\n"
"    let input = parse_macro_input!(input as DeriveInput);\n"
"\n"
"    derive_object_or_error(input)\n"
"        .unwrap_or_else(syn::Error::into_compile_error)\n"
"        .into()\n"
"}"
msgstr ""

#: ../../../devel/rust.rst:362
msgid ""
"The ``qemu_macros`` crate has utility functions to examine a ``DeriveInput`` "
"and perform common checks (e.g. looking for a struct with named fields).  "
"These functions return ``Result<..., syn::Error>`` and can be used easily in "
"the procedural macro function::"
msgstr ""

#: ../../../devel/rust.rst:367
msgid ""
"fn derive_object_or_error(input: DeriveInput) ->\n"
"    Result<proc_macro2::TokenStream, Error>\n"
"{\n"
"    is_c_repr(&input, \"#[derive(Object)]\")?;\n"
"\n"
"    let name = &input.ident;\n"
"    let parent = &get_fields(&input, \"#[derive(Object)]\")?[0].ident;\n"
"    ...\n"
"}"
msgstr ""

#: ../../../devel/rust.rst:377
msgid ""
"Use procedural macros with care.  They are mostly useful for two purposes:"
msgstr ""

#: ../../../devel/rust.rst:379
msgid ""
"Performing consistency checks; for example ``#[derive(Object)]`` checks that "
"the structure has ``#[repr[C])`` and that the type of the first field is "
"consistent with the ``ObjectType`` declaration."
msgstr ""

#: ../../../devel/rust.rst:383
msgid ""
"Extracting information from Rust source code into traits, typically based on "
"types and attributes.  For example, ``#[derive(TryInto)]`` builds an "
"implementation of ``TryFrom``, and it uses the ``#[repr(...)]`` attribute as "
"the ``TryFrom`` source and error types."
msgstr ""

#: ../../../devel/rust.rst:388
msgid ""
"Procedural macros can be hard to debug and test; if the code generation "
"exceeds a few lines of code, it may be worthwhile to delegate work to "
"\"regular\" declarative (``macro_rules!``) macros and write unit tests for "
"those instead."
msgstr ""

#: ../../../devel/rust.rst:395
msgid "Coding style"
msgstr ""

#: ../../../devel/rust.rst:397
msgid "Code should pass clippy and be formatted with rustfmt."
msgstr ""

#: ../../../devel/rust.rst:399
msgid ""
"Right now, only the nightly version of ``rustfmt`` is supported.  This might "
"change in the future.  While CI checks for correct formatting via ``cargo "
"fmt --check``, maintainers can fix this for you when applying patches."
msgstr ""

#: ../../../devel/rust.rst:403
msgid ""
"It is expected that QEMU Rust crates provides full ``rustdoc`` documentation "
"for bindings that are in their final shape or close."
msgstr ""

#: ../../../devel/rust.rst:407
msgid "Adding dependencies"
msgstr ""

#: ../../../devel/rust.rst:409
msgid ""
"Generally, the set of dependent crates is kept small.  Think twice before "
"adding a new external crate, especially if it comes with a large set of "
"dependencies itself.  Sometimes QEMU only needs a small subset of the "
"functionality; see for example QEMU's ``assertions`` module."
msgstr ""

#: ../../../devel/rust.rst:414
msgid ""
"On top of this recommendation, adding external crates to QEMU is a slightly "
"complicated process, mostly due to the need to teach Meson how to build "
"them.  While Meson has initial support for parsing ``Cargo.lock`` files, it "
"is still highly experimental and is therefore not used."
msgstr ""

#: ../../../devel/rust.rst:419
msgid ""
"Therefore, external crates must be added as subprojects for Meson to learn "
"how to build them, as well as to the relevant ``Cargo.toml`` files. The "
"versions specified in ``rust/Cargo.lock`` must be the same as the "
"subprojects; note that the ``rust/`` directory forms a Cargo `workspace`__, "
"and therefore there is a single lock file for the whole build."
msgstr ""

#: ../../../devel/rust.rst:427
msgid ""
"Choose a version of the crate that works with QEMU's minimum supported Rust "
"version (|msrv|)."
msgstr ""

#: ../../../devel/rust.rst:430
msgid ""
"Second, a new ``wrap`` file must be added to teach Meson how to download the "
"crate.  The wrap file must be named ``NAME-SEMVER-rs.wrap``, where ``NAME`` "
"is the name of the crate and ``SEMVER`` is the version up to and including "
"the first non-zero number.  For example, a crate with version ``0.2.3`` will "
"use ``0.2`` for its ``SEMVER``, while a crate with version ``1.0.84`` will "
"use ``1``."
msgstr ""

#: ../../../devel/rust.rst:436
msgid ""
"Third, the Meson rules to build the crate must be added at ``subprojects/"
"NAME-SEMVER-rs/meson.build``.  Generally this includes:"
msgstr ""

#: ../../../devel/rust.rst:439
msgid "``subproject`` and ``dependency`` lines for all dependent crates"
msgstr ""

#: ../../../devel/rust.rst:441
msgid ""
"a ``static_library`` or ``rust.proc_macro`` line to perform the actual build"
msgstr ""

#: ../../../devel/rust.rst:443
msgid ""
"``declare_dependency`` and a ``meson.override_dependency`` lines to expose "
"the result to QEMU and to other subprojects"
msgstr ""

#: ../../../devel/rust.rst:446
msgid ""
"Remember to add ``native: true`` to ``dependency``, ``static_library`` and "
"``meson.override_dependency`` for dependencies of procedural macros. If a "
"crate is needed in both procedural macros and QEMU binaries, everything "
"apart from ``subproject`` must be duplicated to build both native and non-"
"native versions of the crate."
msgstr ""

#: ../../../devel/rust.rst:452
msgid "It's important to specify the right compiler options.  These include:"
msgstr ""

#: ../../../devel/rust.rst:454
msgid "the language edition (which can be found in the ``Cargo.toml`` file)"
msgstr ""

#: ../../../devel/rust.rst:456
msgid ""
"the ``--cfg`` (which have to be \"reverse engineered\" from the ``build.rs`` "
"file of the crate)."
msgstr ""

#: ../../../devel/rust.rst:459
msgid ""
"usually, a ``--cap-lints allow`` argument to hide warnings from rustc or "
"clippy."
msgstr ""

#: ../../../devel/rust.rst:462
msgid ""
"After every change to the ``meson.build`` file you have to update the "
"patched version with ``meson subprojects update --reset ``NAME-SEMVER-rs``.  "
"This might be automated in the future."
msgstr ""

#: ../../../devel/rust.rst:466
msgid ""
"Also, after every change to the ``meson.build`` file it is strongly "
"suggested to do a dummy change to the ``.wrap`` file (for example adding a "
"comment like ``# version 2``), which will help Meson notice that the "
"subproject is out of date."
msgstr ""

#: ../../../devel/rust.rst:470
msgid ""
"As a last step, add the new subproject to ``scripts/archive-source.sh``, "
"``scripts/make-release`` and ``subprojects/.gitignore``."
msgstr ""
