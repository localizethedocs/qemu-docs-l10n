# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-05 08:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/qdev-api.rst:5
msgid "QEMU Device (qdev) API Reference"
msgstr ""

#: ../../../../include/hw/core/qdev.h:3
msgid "**The QEMU Device API**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:15
msgid ""
"All modern devices should represented as a derived QOM class of TYPE_DEVICE. "
"The device API introduces the additional methods of **realize** and "
"**unrealize** to represent additional stages in a device objects life cycle."
msgstr ""

#: ../../../../include/hw/core/qdev.h:23
msgid "Devices are constructed in two stages:"
msgstr ""

#: ../../../../include/hw/core/qdev.h:25
msgid "object instantiation via object_initialize() and"
msgstr ""

#: ../../../../include/hw/core/qdev.h:26
msgid ""
"device realization via the :c:type:`DeviceState.realized <DeviceState>` "
"property"
msgstr ""

#: ../../../../include/hw/core/qdev.h:28
msgid ""
"The former may not fail (and must not abort or exit, since it is called "
"during device introspection already), and the latter may return error "
"information to the caller and must be re-entrant. Trivial field "
"initializations should go into :c:type:`TypeInfo.instance_init <TypeInfo>`. "
"Operations depending on **props** static properties should go into "
"**realize**. After successful realization, setting static properties will "
"fail."
msgstr ""

#: ../../../../include/hw/core/qdev.h:35
msgid ""
"As an interim step, the :c:type:`DeviceState.realized <DeviceState>` "
"property can also be set with qdev_realize(). In the future, devices will "
"propagate this state change to their children and along busses they expose. "
"The point in time will be deferred to machine creation, so that values set "
"in **realize** will not be introspectable beforehand. Therefore devices must "
"not create children during **realize**; they should initialize them via "
"object_initialize() in their own :c:type:`TypeInfo.instance_init <TypeInfo>` "
"and forward the realization events appropriately."
msgstr ""

#: ../../../../include/hw/core/qdev.h:45
msgid ""
"Any type may override the **realize** and/or **unrealize** callbacks but "
"needs to call the parent type's implementation if keeping their "
"functionality is desired. Refer to QOM documentation for further discussion "
"and examples."
msgstr ""

#: ../../../../include/hw/core/qdev.h:50
msgid ""
"Since TYPE_DEVICE doesn't implement **realize** and **unrealize**, types "
"derived directly from it need not call their parent's **realize** and "
"**unrealize**. For other types consult the documentation and implementation "
"of the respective parent types."
msgstr ""

#: ../../../../include/hw/core/qdev.h:58
msgid ""
"To hide a device, a DeviceListener function hide_device() needs to be "
"registered. It can be used to defer adding a device and therefore hide it "
"from the guest. The handler registering to this DeviceListener can save the "
"QOpts passed to it for re-using it later. It must return if it wants the "
"device to be hidden or visible. When the handler function decides the device "
"shall be visible it will be added with qdev_device_add() and realized as any "
"other device. Otherwise qdev_device_add() will return early without adding "
"the device. The guest will not see a \"hidden\" device until it was marked "
"visible and qdev_device_add called again."
msgstr ""

#: ../../../../include/hw/core/qdev.h:102
msgid "The base class for all devices."
msgstr ""

#: ../../../../include/hw/core/qdev.h:106
#: ../../../../include/hw/core/qdev.h:221
#: ../../../../include/hw/core/qdev.h:370
msgid "**Definition**::"
msgstr ""

#: ../../../../include/hw/core/qdev.h:108
msgid ""
"struct DeviceClass {\n"
"    unsigned long categories[BITS_TO_LONGS(DEVICE_CATEGORY_MAX)];\n"
"    const char *fw_name;\n"
"    const char *desc;\n"
"    const Property *props_;\n"
"    uint16_t props_count_;\n"
"    bool user_creatable;\n"
"    bool hotpluggable;\n"
"    DeviceReset legacy_reset;\n"
"    DeviceRealize realize;\n"
"    DeviceUnrealize unrealize;\n"
"    DeviceSyncConfig sync_config;\n"
"    const VMStateDescription *vmsd;\n"
"    const char *bus_type;\n"
"};"
msgstr ""

#: ../../../../include/hw/core/qdev.h:124
#: ../../../../include/hw/core/qdev.h:243
#: ../../../../include/hw/core/qdev.h:385
msgid "**Members**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:122
msgid "``categories``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:123
msgid "device categories device belongs to"
msgstr ""

#: ../../../../include/hw/core/qdev.h:126
msgid "``fw_name``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:127
msgid "name used to identify device to firmware interfaces"
msgstr ""

#: ../../../../include/hw/core/qdev.h:130
msgid "``desc``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:131
msgid "human readable description of device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:135
msgid "``props_``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:136
msgid ""
"properties associated with device, should only be assigned by using "
"device_class_set_props(). The underscore ensures a compile-time error if "
"someone attempts to assign dc->props directly."
msgstr ""

#: ../../../../include/hw/core/qdev.h:143
msgid "``props_count_``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:144
msgid ""
"number of elements in **props_**; should only be assigned by using "
"device_class_set_props()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:149
msgid "``user_creatable``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:150
msgid "Can user instantiate with -device / device_add?"
msgstr ""

#: ../../../../include/hw/core/qdev.h:152
msgid ""
"All devices should support instantiation with device_add, and this flag "
"should not exist.  But we're not there, yet.  Some devices fail to "
"instantiate with cryptic error messages. Others instantiate, but don't "
"work.  Exposing users to such behavior would be cruel; clearing this flag "
"will protect them. It should never be cleared without a comment explaining "
"why it is cleared."
msgstr ""

#: ../../../../include/hw/core/qdev.h:160
msgid "TODO remove once we're there"
msgstr ""

#: ../../../../include/hw/core/qdev.h:111
msgid "``hotpluggable``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:112
msgid ""
"indicates if :c:type:`DeviceClass <DeviceClass>` is hotpluggable, available "
"as readonly \"hotpluggable\" property of :c:type:`DeviceState <DeviceState>` "
"instance"
msgstr ""

#: ../../../../include/hw/core/qdev.h:166
msgid "``legacy_reset``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:167
msgid "deprecated device reset method pointer"
msgstr ""

#: ../../../../include/hw/core/qdev.h:169
msgid ""
"Modern code should use the ResettableClass interface to implement a multi-"
"phase reset."
msgstr ""

#: ../../../../include/hw/core/qdev.h:172
msgid "TODO: remove once every reset callback is unused"
msgstr ""

#: ../../../../include/hw/core/qdev.h:104
msgid "``realize``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:105
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``true``."
msgstr ""

#: ../../../../include/hw/core/qdev.h:106
msgid "``unrealize``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:107
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``false``."
msgstr ""

#: ../../../../include/hw/core/qdev.h:108
msgid "``sync_config``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:109
msgid ""
"Callback function invoked when QMP command device-sync-config is called. "
"Should synchronize device configuration from host to guest part and notify "
"the guest about the change."
msgstr ""

#: ../../../../include/hw/core/qdev.h:179
msgid "``vmsd``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:180
msgid "device state serialisation description for migration/save/restore"
msgstr ""

#: ../../../../include/hw/core/qdev.h:185
msgid "``bus_type``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:186
msgid "bus type private: to qdev / bus."
msgstr ""

#: ../../../../include/hw/core/qdev.h:217
msgid "common device state, accessed with qdev helpers"
msgstr ""

#: ../../../../include/hw/core/qdev.h:223
msgid ""
"struct DeviceState {\n"
"    char *id;\n"
"    char *canonical_path;\n"
"    bool realized;\n"
"    bool pending_deleted_event;\n"
"    int64_t pending_deleted_expires_ms;\n"
"    int hotplugged;\n"
"    bool allow_unplug_during_migration;\n"
"    BusState *parent_bus;\n"
"    NamedGPIOListHead gpios;\n"
"    NamedClockListHead clocks;\n"
"    BusStateHead child_bus;\n"
"    int num_child_bus;\n"
"    int instance_id_alias;\n"
"    int alias_required_for_version;\n"
"    ResettableState reset;\n"
"    GSList *unplug_blockers;\n"
"    MemReentrancyGuard mem_reentrancy_guard;\n"
"};"
msgstr ""

#: ../../../../include/hw/core/qdev.h:228
msgid "``id``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:229
msgid "global device id"
msgstr ""

#: ../../../../include/hw/core/qdev.h:232
msgid "``canonical_path``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:233
msgid "canonical path of realized device in the QOM tree"
msgstr ""

#: ../../../../include/hw/core/qdev.h:236
#: ../../../../include/hw/core/qdev.h:372
msgid "``realized``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:237
msgid "has device been realized?"
msgstr ""

#: ../../../../include/hw/core/qdev.h:240
msgid "``pending_deleted_event``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:241
msgid "track pending deletion events during unplug"
msgstr ""

#: ../../../../include/hw/core/qdev.h:244
msgid "``pending_deleted_expires_ms``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:245
msgid "optional timeout for deletion events"
msgstr ""

#: ../../../../include/hw/core/qdev.h:248
msgid "``hotplugged``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:249
msgid "was device added after PHASE_MACHINE_READY?"
msgstr ""

#: ../../../../include/hw/core/qdev.h:252
msgid "``allow_unplug_during_migration``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:253
msgid "can device be unplugged during migration"
msgstr ""

#: ../../../../include/hw/core/qdev.h:256
msgid "``parent_bus``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:257
msgid "bus this device belongs to"
msgstr ""

#: ../../../../include/hw/core/qdev.h:260
msgid "``gpios``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:261
msgid "QLIST of named GPIOs the device provides."
msgstr ""

#: ../../../../include/hw/core/qdev.h:264
msgid "``clocks``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:265
msgid "QLIST of named clocks the device provides."
msgstr ""

#: ../../../../include/hw/core/qdev.h:268
msgid "``child_bus``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:269
msgid "QLIST of child buses"
msgstr ""

#: ../../../../include/hw/core/qdev.h:272
msgid "``num_child_bus``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:273
msgid "number of **child_bus** entries"
msgstr ""

#: ../../../../include/hw/core/qdev.h:276
msgid "``instance_id_alias``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:277
msgid "device alias for handling legacy migration setups"
msgstr ""

#: ../../../../include/hw/core/qdev.h:280
msgid "``alias_required_for_version``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:281
msgid "indicates **instance_id_alias** is needed for migration"
msgstr ""

#: ../../../../include/hw/core/qdev.h:285
#: ../../../../include/hw/core/qdev.h:398
msgid "``reset``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:286
msgid "ResettableState for the device; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/core/qdev.h:289
msgid "``unplug_blockers``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:290
msgid "list of reasons to block unplugging of device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:293
msgid "``mem_reentrancy_guard``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:294
msgid "Is the device currently in mmio/pio/dma?"
msgstr ""

#: ../../../../include/hw/core/qdev.h:296
msgid "Used to prevent re-entrancy confusing things."
msgstr ""

#: ../../../../include/hw/core/qdev.h:3 ../../../../include/hw/core/qdev.h:299
#: ../../../../include/hw/core/qdev.h:406
#: ../../../../include/hw/core/qdev.h:436
#: ../../../../include/hw/core/qdev.h:448
#: ../../../../include/hw/core/qdev.h:474
#: ../../../../include/hw/core/qdev.h:493
#: ../../../../include/hw/core/qdev.h:519
#: ../../../../include/hw/core/qdev.h:591
#: ../../../../include/hw/core/qdev.h:609
#: ../../../../include/hw/core/qdev.h:632
#: ../../../../include/hw/core/qdev.h:652
#: ../../../../include/hw/core/qdev.h:685
#: ../../../../include/hw/core/qdev.h:712
#: ../../../../include/hw/core/qdev.h:734
#: ../../../../include/hw/core/qdev.h:759
#: ../../../../include/hw/core/qdev.h:778
#: ../../../../include/hw/core/qdev.h:808
#: ../../../../include/hw/core/qdev.h:835
#: ../../../../include/hw/core/qdev.h:851
#: ../../../../include/hw/core/qdev.h:899
#: ../../../../include/hw/core/qdev.h:908
#: ../../../../include/hw/core/qdev.h:940
#: ../../../../include/hw/core/qdev.h:965
#: ../../../../include/hw/core/qdev.h:977
#: ../../../../include/hw/core/qdev.h:992
#: ../../../../include/hw/core/qdev.h:1007
#: ../../../../include/hw/core/qdev.h:1038
#: ../../../../include/hw/core/qdev.h:1048
#: ../../../../include/hw/core/qdev.h:1089
#: ../../../../include/hw/core/qdev.h:1118
msgid "**Description**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:218
msgid ""
"This structure should not be accessed directly.  We declare it here so that "
"it can be embedded in individual device state structures."
msgstr ""

#: ../../../../include/hw/core/qdev.h:372
msgid ""
"struct BusState {\n"
"    DeviceState *parent;\n"
"    char *name;\n"
"    HotplugHandler *hotplug_handler;\n"
"    int max_index;\n"
"    bool realized;\n"
"    bool full;\n"
"    int num_children;\n"
"    BusChildHead children;\n"
"    BusStateEntry sibling;\n"
"    ResettableState reset;\n"
"};"
msgstr ""

#: ../../../../include/hw/core/qdev.h:368
msgid "``parent``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:369
msgid "parent Device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:369
msgid "``name``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:370
msgid "name of bus"
msgstr ""

#: ../../../../include/hw/core/qdev.h:370
msgid "``hotplug_handler``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:371
msgid "link to a hotplug handler associated with bus."
msgstr ""

#: ../../../../include/hw/core/qdev.h:371
msgid "``max_index``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:372
msgid "max number of child buses"
msgstr ""

#: ../../../../include/hw/core/qdev.h:373
msgid "is the bus itself realized?"
msgstr ""

#: ../../../../include/hw/core/qdev.h:373
msgid "``full``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:374
msgid "is the bus full?"
msgstr ""

#: ../../../../include/hw/core/qdev.h:374
msgid "``num_children``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:375
msgid "current number of child buses"
msgstr ""

#: ../../../../include/hw/core/qdev.h:389
msgid "``children``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:390
msgid ""
"an RCU protected QTAILQ, thus readers must use RCU to access it, and writers "
"must hold the big qemu lock"
msgstr ""

#: ../../../../include/hw/core/qdev.h:394
msgid "``sibling``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:395
msgid "next bus"
msgstr ""

#: ../../../../include/hw/core/qdev.h:399
msgid "ResettableState for the bus; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/core/qdev.h:404
msgid "a global property type"
msgstr ""

#: ../../../../include/hw/core/qdev.h:409
msgid ""
"An error is fatal for non-hotplugged devices, when the global is applied."
msgstr ""

#: ../../../../include/hw/core/qdev.h:433
msgid "Create a device on the heap"
msgstr ""

#: ../../../../include/hw/core/qdev.h:437
#: ../../../../include/hw/core/qdev.h:449
#: ../../../../include/hw/core/qdev.h:461
#: ../../../../include/hw/core/qdev.h:473
#: ../../../../include/hw/core/qdev.h:492
#: ../../../../include/hw/core/qdev.h:520
#: ../../../../include/hw/core/qdev.h:547
#: ../../../../include/hw/core/qdev.h:565
#: ../../../../include/hw/core/qdev.h:573
#: ../../../../include/hw/core/qdev.h:582
#: ../../../../include/hw/core/qdev.h:609
#: ../../../../include/hw/core/qdev.h:631
#: ../../../../include/hw/core/qdev.h:651
#: ../../../../include/hw/core/qdev.h:682
#: ../../../../include/hw/core/qdev.h:711
#: ../../../../include/hw/core/qdev.h:732
#: ../../../../include/hw/core/qdev.h:758
#: ../../../../include/hw/core/qdev.h:777
#: ../../../../include/hw/core/qdev.h:806
#: ../../../../include/hw/core/qdev.h:820
#: ../../../../include/hw/core/qdev.h:833
#: ../../../../include/hw/core/qdev.h:850
#: ../../../../include/hw/core/qdev.h:900
#: ../../../../include/hw/core/qdev.h:909
#: ../../../../include/hw/core/qdev.h:918
#: ../../../../include/hw/core/qdev.h:926
#: ../../../../include/hw/core/qdev.h:940
#: ../../../../include/hw/core/qdev.h:964
#: ../../../../include/hw/core/qdev.h:976
#: ../../../../include/hw/core/qdev.h:992
#: ../../../../include/hw/core/qdev.h:1006
#: ../../../../include/hw/core/qdev.h:1029
#: ../../../../include/hw/core/qdev.h:1039
#: ../../../../include/hw/core/qdev.h:1049
#: ../../../../include/hw/core/qdev.h:1090
#: ../../../../include/hw/core/qdev.h:1116
msgid "**Parameters**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:439
#: ../../../../include/hw/core/qdev.h:451
#: ../../../../include/hw/core/qdev.h:630
#: ../../../../include/hw/core/qdev.h:682
#: ../../../../include/hw/core/qdev.h:710
#: ../../../../include/hw/core/qdev.h:732
#: ../../../../include/hw/core/qdev.h:806
#: ../../../../include/hw/core/qdev.h:821
#: ../../../../include/hw/core/qdev.h:833
#: ../../../../include/hw/core/qdev.h:850
#: ../../../../include/hw/core/qdev.h:1041
msgid "``const char *name``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:434
msgid "device type to create (we assert() that this type exists)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:435
msgid ""
"This only allocates the memory and initializes the device state structure, "
"ready for the caller to set properties if they wish. The device still needs "
"to be realized."
msgstr ""

#: ../../../../include/hw/core/qdev.h:439
#: ../../../../include/hw/core/qdev.h:450
#: ../../../../include/hw/core/qdev.h:462
#: ../../../../include/hw/core/qdev.h:482
#: ../../../../include/hw/core/qdev.h:510
#: ../../../../include/hw/core/qdev.h:549
#: ../../../../include/hw/core/qdev.h:583
#: ../../../../include/hw/core/qdev.h:621
#: ../../../../include/hw/core/qdev.h:641
#: ../../../../include/hw/core/qdev.h:721
#: ../../../../include/hw/core/qdev.h:743
#: ../../../../include/hw/core/qdev.h:917
#: ../../../../include/hw/core/qdev.h:925
#: ../../../../include/hw/core/qdev.h:1039
#: ../../../../include/hw/core/qdev.h:1053
#: ../../../../include/hw/core/qdev.h:1119
msgid "**Return**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:440
msgid "a derived DeviceState object with a reference count of 1."
msgstr ""

#: ../../../../include/hw/core/qdev.h:445
msgid "Try to create a device on the heap"
msgstr ""

#: ../../../../include/hw/core/qdev.h:446
msgid "device type to create"
msgstr ""

#: ../../../../include/hw/core/qdev.h:447
msgid ""
"This is like qdev_new(), except it returns ``NULL`` when type **name** does "
"not exist, rather than asserting."
msgstr ""

#: ../../../../include/hw/core/qdev.h:451
msgid ""
"a derived DeviceState object with a reference count of 1 or NULL if type "
"**name** does not exist."
msgstr ""

#: ../../../../include/hw/core/qdev.h:457
msgid "check if device is realized"
msgstr ""

#: ../../../../include/hw/core/qdev.h:463
#: ../../../../include/hw/core/qdev.h:475
#: ../../../../include/hw/core/qdev.h:494
#: ../../../../include/hw/core/qdev.h:522
#: ../../../../include/hw/core/qdev.h:549
#: ../../../../include/hw/core/qdev.h:567
#: ../../../../include/hw/core/qdev.h:575
#: ../../../../include/hw/core/qdev.h:584
#: ../../../../include/hw/core/qdev.h:611
#: ../../../../include/hw/core/qdev.h:633
#: ../../../../include/hw/core/qdev.h:653
#: ../../../../include/hw/core/qdev.h:684
#: ../../../../include/hw/core/qdev.h:734
#: ../../../../include/hw/core/qdev.h:760
#: ../../../../include/hw/core/qdev.h:779
#: ../../../../include/hw/core/qdev.h:808
#: ../../../../include/hw/core/qdev.h:822
#: ../../../../include/hw/core/qdev.h:835
#: ../../../../include/hw/core/qdev.h:852
#: ../../../../include/hw/core/qdev.h:902
#: ../../../../include/hw/core/qdev.h:920
#: ../../../../include/hw/core/qdev.h:1051
msgid "``DeviceState *dev``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:458
msgid "The device to check."
msgstr ""

#: ../../../../include/hw/core/qdev.h:460
msgid "**Context**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:460
msgid "May be called outside big qemu lock."
msgstr ""

#: ../../../../include/hw/core/qdev.h:461
msgid "true if the device has been fully constructed, false otherwise."
msgstr ""

#: ../../../../include/hw/core/qdev.h:469
msgid "Realize **dev**."
msgstr ""

#: ../../../../include/hw/core/qdev.h:470
#: ../../../../include/hw/core/qdev.h:489
msgid "device to realize"
msgstr ""

#: ../../../../include/hw/core/qdev.h:472
#: ../../../../include/hw/core/qdev.h:491
#: ../../../../include/hw/core/qdev.h:911
#: ../../../../include/hw/core/qdev.h:928
#: ../../../../include/hw/core/qdev.h:1092
msgid "``BusState *bus``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:471
#: ../../../../include/hw/core/qdev.h:490
msgid "bus to plug it into (may be NULL)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:473
#: ../../../../include/hw/core/qdev.h:492
#: ../../../../include/hw/core/qdev.h:582
#: ../../../../include/hw/core/qdev.h:1117
msgid "``Error **errp``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:472
#: ../../../../include/hw/core/qdev.h:491
#: ../../../../include/hw/core/qdev.h:1116
msgid "pointer to error object"
msgstr ""

#: ../../../../include/hw/core/qdev.h:473
msgid ""
"\"Realize\" the device, i.e. perform the second phase of device "
"initialization. **dev** must not be plugged into a bus already. If **bus**, "
"plug **dev** into **bus**.  This takes a reference to **dev**. If **dev** "
"has no QOM parent, make one up, taking another reference."
msgstr ""

#: ../../../../include/hw/core/qdev.h:479
msgid ""
"If you created **dev** using qdev_new(), you probably want to use "
"qdev_realize_and_unref() instead."
msgstr ""

#: ../../../../include/hw/core/qdev.h:483
#: ../../../../include/hw/core/qdev.h:511
msgid "true on success, else false setting **errp** with error"
msgstr ""

#: ../../../../include/hw/core/qdev.h:488
msgid "Realize **dev** and drop a reference"
msgstr ""

#: ../../../../include/hw/core/qdev.h:492
msgid ""
"Realize **dev** and drop a reference. This is like qdev_realize(), except "
"the caller must hold a (private) reference, which is dropped on return "
"regardless of success or failure.  Intended use::"
msgstr ""

#: ../../../../include/hw/core/qdev.h:497
msgid ""
"dev = qdev_new();\n"
"[...]\n"
"qdev_realize_and_unref(dev, bus, errp);"
msgstr ""

#: ../../../../include/hw/core/qdev.h:501
msgid "Now **dev** can go away without further ado."
msgstr ""

#: ../../../../include/hw/core/qdev.h:503
msgid ""
"If you are embedding the device into some other QOM device and initialized "
"it via some variant on object_initialize_child() then do not use this "
"function, because that family of functions arrange for the only reference to "
"the child device to be held by the parent via the child<> property, and so "
"the reference-count-drop done here would be incorrect. For that use case you "
"want qdev_realize()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:516
msgid "Unrealize a device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:517
msgid "device to unrealize"
msgstr ""

#: ../../../../include/hw/core/qdev.h:518
msgid ""
"This function will \"unrealize\" a device, which is the first phase of "
"correctly destroying a device that has been realized. It will:"
msgstr ""

#: ../../../../include/hw/core/qdev.h:521
msgid ""
"unrealize any child buses by calling qbus_unrealize() (this will recursively "
"unrealize any devices on those buses)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:523
msgid "call the unrealize method of **dev**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:525
msgid ""
"The device can then be freed by causing its reference count to go to zero."
msgstr ""

#: ../../../../include/hw/core/qdev.h:528
msgid ""
"Warning: most devices in QEMU do not expect to be unrealized.  Only devices "
"which are hot-unpluggable should be unrealized (as part of the unplugging "
"process); all other devices are expected to last for the life of the "
"simulation and should not be unrealized and freed."
msgstr ""

#: ../../../../include/hw/core/qdev.h:543
msgid "Get handler responsible for device wiring"
msgstr ""

#: ../../../../include/hw/core/qdev.h:544
msgid "the device we want the HOTPLUG_HANDLER for."
msgstr ""

#: ../../../../include/hw/core/qdev.h:546
msgid "**Note**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:546
msgid ""
"in case **dev** has a parent bus, it will be returned as handler unless "
"machine handler overrides it."
msgstr ""

#: ../../../../include/hw/core/qdev.h:549
msgid ""
"pointer to object that implements TYPE_HOTPLUG_HANDLER interface or NULL if "
"there aren't any."
msgstr ""

#: ../../../../include/hw/core/qdev.h:561
msgid "Add an unplug blocker to a device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:563
msgid "Device to be blocked from unplug"
msgstr ""

#: ../../../../include/hw/core/qdev.h:565
#: ../../../../include/hw/core/qdev.h:573
msgid "``Error *reason``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:564
msgid "Reason for blocking"
msgstr ""

#: ../../../../include/hw/core/qdev.h:569
msgid "Remove an unplug blocker from a device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:571
msgid "Device to be unblocked"
msgstr ""

#: ../../../../include/hw/core/qdev.h:572
msgid ""
"Pointer to the Error used with qdev_add_unplug_blocker. Used as a handle to "
"lookup the blocker for deletion."
msgstr ""

#: ../../../../include/hw/core/qdev.h:578
msgid "Confirm if a device is blocked from unplug"
msgstr ""

#: ../../../../include/hw/core/qdev.h:580
msgid "Device to be tested"
msgstr ""

#: ../../../../include/hw/core/qdev.h:581
msgid "The reasons why the device is blocked, if any"
msgstr ""

#: ../../../../include/hw/core/qdev.h:583
msgid ""
"true (also setting **errp**) if device is blocked from unplug, false "
"otherwise"
msgstr ""

#: ../../../../include/hw/core/qdev.h:589
msgid "Polarity of a GPIO line"
msgstr ""

#: ../../../../include/hw/core/qdev.h:590
msgid ""
"GPIO lines use either positive (active-high) logic, or negative (active-low) "
"logic."
msgstr ""

#: ../../../../include/hw/core/qdev.h:593
msgid ""
"In active-high logic (``GPIO_POLARITY_ACTIVE_HIGH``), a pin is active when "
"the voltage on the pin is high (relative to ground); whereas in active-low "
"logic (``GPIO_POLARITY_ACTIVE_LOW``), a pin is active when the voltage on "
"the pin is low (or grounded)."
msgstr ""

#: ../../../../include/hw/core/qdev.h:605
msgid "Get one of a device's anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:606
#: ../../../../include/hw/core/qdev.h:628
msgid "Device whose GPIO we want"
msgstr ""

#: ../../../../include/hw/core/qdev.h:608
#: ../../../../include/hw/core/qdev.h:631
#: ../../../../include/hw/core/qdev.h:650
#: ../../../../include/hw/core/qdev.h:683
#: ../../../../include/hw/core/qdev.h:711
#: ../../../../include/hw/core/qdev.h:733
#: ../../../../include/hw/core/qdev.h:758
#: ../../../../include/hw/core/qdev.h:777
#: ../../../../include/hw/core/qdev.h:807
#: ../../../../include/hw/core/qdev.h:822
#: ../../../../include/hw/core/qdev.h:834
msgid "``int n``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:607
msgid "Number of the anonymous GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:608
msgid ""
"Returns the qemu_irq corresponding to an anonymous input GPIO line (which "
"the device has set up with qdev_init_gpio_in()). The index **n** of the GPIO "
"line must be valid (i.e. be at least 0 and less than the total number of "
"anonymous input GPIOs the device has); this function will assert() if passed "
"an invalid index."
msgstr ""

#: ../../../../include/hw/core/qdev.h:614
msgid ""
"This function is intended to be used by board code or SoC \"container\" "
"device models to wire up the GPIO lines; usually the return value will be "
"passed to qdev_connect_gpio_out() or a similar function to connect another "
"device's output GPIO line to this input."
msgstr ""

#: ../../../../include/hw/core/qdev.h:619
msgid "For named input GPIO lines, use qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:622
msgid "qemu_irq corresponding to anonymous input GPIO line"
msgstr ""

#: ../../../../include/hw/core/qdev.h:627
msgid "Get one of a device's named input GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:629
msgid "Name of the input GPIO array"
msgstr ""

#: ../../../../include/hw/core/qdev.h:630
msgid "Number of the GPIO line in that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:631
msgid ""
"Returns the qemu_irq corresponding to a single input GPIO line in a named "
"array of input GPIO lines on a device (which the device has set up with "
"qdev_init_gpio_in_named()). The **name** string must correspond to an input "
"GPIO array which exists on the device, and the index **n** of the GPIO line "
"must be valid (i.e. be at least 0 and less than the total number of input "
"GPIOs in that array); this function will assert() if passed an invalid name "
"or index."
msgstr ""

#: ../../../../include/hw/core/qdev.h:639
msgid "For anonymous input GPIO lines, use qdev_get_gpio_in()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:642
msgid "qemu_irq corresponding to named input GPIO line"
msgstr ""

#: ../../../../include/hw/core/qdev.h:647
msgid "Connect one of a device's anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:648
#: ../../../../include/hw/core/qdev.h:680
msgid "Device whose GPIO to connect"
msgstr ""

#: ../../../../include/hw/core/qdev.h:649
msgid "Number of the anonymous output GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:651
msgid "``qemu_irq pin``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:650
#: ../../../../include/hw/core/qdev.h:683
msgid "qemu_irq to connect the output line to"
msgstr ""

#: ../../../../include/hw/core/qdev.h:651
msgid ""
"This function connects an anonymous output GPIO line on a device up to an "
"arbitrary qemu_irq, so that when the device asserts that output GPIO line, "
"the qemu_irq's callback is invoked. The index **n** of the GPIO line must be "
"valid (i.e. be at least 0 and less than the total number of anonymous output "
"GPIOs the device has created with qdev_init_gpio_out()); otherwise this "
"function will assert()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:658
#: ../../../../include/hw/core/qdev.h:692
msgid ""
"Outbound GPIO lines can be connected to any qemu_irq, but the common case is "
"connecting them to another device's inbound GPIO line, using the qemu_irq "
"returned by qdev_get_gpio_in() or qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:662
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq. (Warning: "
"there is no assertion or other guard to catch this error: the model will "
"just not do the right thing.) Instead, for fan-out you can use the "
"TYPE_SPLIT_IRQ device: connect a device's outbound GPIO to the splitter's "
"input, and connect each of the splitter's outputs to a different device.  "
"For fan-in you can use the TYPE_OR_IRQ device, which is a model of a logical "
"OR gate with multiple inputs and one output."
msgstr ""

#: ../../../../include/hw/core/qdev.h:672
msgid "For named output GPIO lines, use qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:678
msgid "Connect one of a device's named output GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:681
#: ../../../../include/hw/core/qdev.h:709
#: ../../../../include/hw/core/qdev.h:731
msgid "Name of the output GPIO array"
msgstr ""

#: ../../../../include/hw/core/qdev.h:682
msgid ""
"Number of the output GPIO line within that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:684
msgid "``qemu_irq input_pin``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:684
msgid ""
"This function connects a single GPIO output in a named array of output GPIO "
"lines on a device up to an arbitrary qemu_irq, so that when the device "
"asserts that output GPIO line, the qemu_irq's callback is invoked. The "
"**name** string must correspond to an output GPIO array which exists on the "
"device, and the index **n** of the GPIO line must be valid (i.e. be at least "
"0 and less than the total number of output GPIOs in that array); this "
"function will assert() if passed an invalid name or index."
msgstr ""

#: ../../../../include/hw/core/qdev.h:696
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq; see "
"qdev_connect_gpio_out() for details."
msgstr ""

#: ../../../../include/hw/core/qdev.h:700
msgid "For anonymous output GPIO lines, use qdev_connect_gpio_out()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:707
msgid "Get the qemu_irq connected to an output GPIO"
msgstr ""

#: ../../../../include/hw/core/qdev.h:713
msgid "``const DeviceState *dev``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:708
msgid "Device whose output GPIO we are interested in"
msgstr ""

#: ../../../../include/hw/core/qdev.h:710
msgid "Number of the output GPIO line within that array"
msgstr ""

#: ../../../../include/hw/core/qdev.h:711
msgid ""
"Returns whatever qemu_irq is currently connected to the specified output "
"GPIO line of **dev**. This will be NULL if the output GPIO line has never "
"been wired up to the anything.  Note that the qemu_irq returned does not "
"belong to **dev** -- it will be the input GPIO or IRQ of whichever device "
"the board code has connected up to **dev**'s output GPIO."
msgstr ""

#: ../../../../include/hw/core/qdev.h:718
msgid ""
"You probably don't need to use this function -- it is used only by the "
"platform-bus subsystem."
msgstr ""

#: ../../../../include/hw/core/qdev.h:722
msgid "qemu_irq associated with GPIO or NULL if un-wired."
msgstr ""

#: ../../../../include/hw/core/qdev.h:728
msgid "Intercept an existing GPIO connection"
msgstr ""

#: ../../../../include/hw/core/qdev.h:729
msgid "Device to intercept the outbound GPIO line from"
msgstr ""

#: ../../../../include/hw/core/qdev.h:731
msgid "``qemu_irq icpt``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:730
msgid "New qemu_irq to connect instead"
msgstr ""

#: ../../../../include/hw/core/qdev.h:732
msgid "Number of the GPIO line in the array"
msgstr ""

#: ../../../../include/hw/core/qdev.h:734
msgid ""
"This function is provided only for use by the qtest testing framework and is "
"not suitable for use in non-testing parts of QEMU."
msgstr ""

#: ../../../../include/hw/core/qdev.h:737
msgid ""
"This function breaks an existing connection of an outbound GPIO line from "
"**dev**, and replaces it with the new qemu_irq **icpt**, as if "
"``qdev_connect_gpio_out_named(dev, icpt, name, n)`` had been called. The "
"previously connected qemu_irq is returned, so it can be restored by a second "
"call to qdev_intercept_gpio_out() if desired."
msgstr ""

#: ../../../../include/hw/core/qdev.h:744
msgid "old disconnected qemu_irq if one existed"
msgstr ""

#: ../../../../include/hw/core/qdev.h:754
msgid "create an array of anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:755
#: ../../../../include/hw/core/qdev.h:817
msgid "Device to create input GPIOs for"
msgstr ""

#: ../../../../include/hw/core/qdev.h:757
#: ../../../../include/hw/core/qdev.h:819
#: ../../../../include/hw/core/qdev.h:832
msgid "``qemu_irq_handler handler``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:756
#: ../../../../include/hw/core/qdev.h:818
msgid "Function to call when GPIO line value is set"
msgstr ""

#: ../../../../include/hw/core/qdev.h:757
#: ../../../../include/hw/core/qdev.h:776
msgid "Number of GPIO lines to create"
msgstr ""

#: ../../../../include/hw/core/qdev.h:758
msgid ""
"Devices should use functions in the qdev_init_gpio_in* family in their "
"instance_init or realize methods to create any input GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO input whose "
"purpose is obvious. Note that input GPIO lines can serve as 'sinks' for IRQ "
"lines."
msgstr ""

#: ../../../../include/hw/core/qdev.h:766
msgid ""
"See qdev_get_gpio_in() for how code that uses such a device can get hold of "
"an input GPIO line to manipulate it."
msgstr ""

#: ../../../../include/hw/core/qdev.h:773
msgid "create an array of anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:774
#: ../../../../include/hw/core/qdev.h:803
msgid "Device to create output GPIOs for"
msgstr ""

#: ../../../../include/hw/core/qdev.h:776
#: ../../../../include/hw/core/qdev.h:805
msgid "``qemu_irq *pins``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:775
#: ../../../../include/hw/core/qdev.h:804
msgid "Pointer to qemu_irq or qemu_irq array for the GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:777
msgid ""
"Devices should use functions in the qdev_init_gpio_out* family in their "
"instance_init or realize methods to create any output GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO output whose "
"purpose is obvious."
msgstr ""

#: ../../../../include/hw/core/qdev.h:784
msgid ""
"The **pins** argument should be a pointer to either a \"qemu_irq\" (if **n** "
"== 1) or a \"qemu_irq []\" array (if **n** > 1) in the device's state "
"structure. The device implementation can then raise and lower the GPIO line "
"by calling qemu_set_irq(). (If anything is connected to the other end of the "
"GPIO this will cause the handler function for that input GPIO to be called.)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:791
msgid ""
"See qdev_connect_gpio_out() for how code that uses such a device can connect "
"to one of its output GPIO lines."
msgstr ""

#: ../../../../include/hw/core/qdev.h:794
msgid ""
"There is no need to release the **pins** allocated array because it will be "
"automatically released when **dev** calls its instance_finalize() handler."
msgstr ""

#: ../../../../include/hw/core/qdev.h:802
msgid "create an array of named output GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:805
msgid "Name to give this array of GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:806
msgid "Number of GPIO lines to create in this array"
msgstr ""

#: ../../../../include/hw/core/qdev.h:807
msgid ""
"Like qdev_init_gpio_out(), but creates an array of GPIO output lines with a "
"name. Code using the device can then connect these GPIO lines using "
"qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/core/qdev.h:816
#: ../../../../include/hw/core/qdev.h:829
msgid "create an array of input GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:820
msgid "``void *opaque``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:819
msgid "Opaque data pointer to pass to **handler**"
msgstr ""

#: ../../../../include/hw/core/qdev.h:820
#: ../../../../include/hw/core/qdev.h:832
msgid "Name of the GPIO input (must be unique for this device)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:821
#: ../../../../include/hw/core/qdev.h:833
msgid "Number of GPIO lines in this input set"
msgstr ""

#: ../../../../include/hw/core/qdev.h:830
msgid "device to add array to"
msgstr ""

#: ../../../../include/hw/core/qdev.h:831
msgid "a &typedef qemu_irq_handler function to call when GPIO is set"
msgstr ""

#: ../../../../include/hw/core/qdev.h:834
msgid ""
"Like qdev_init_gpio_in_named_with_opaque(), but the opaque pointer passed to "
"the handler is **dev** (which is the most commonly desired behaviour)."
msgstr ""

#: ../../../../include/hw/core/qdev.h:846
msgid "create GPIO lines on container which pass through to device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:847
msgid "Device which has GPIO lines"
msgstr ""

#: ../../../../include/hw/core/qdev.h:849
msgid "``DeviceState *container``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:848
msgid "Container device which needs to expose them"
msgstr ""

#: ../../../../include/hw/core/qdev.h:849
msgid "Name of GPIO array to pass through (NULL for the anonymous GPIO array)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:850
msgid ""
"In QEMU, complicated devices like SoCs are often modelled with a "
"\"container\" QOM device which itself contains other QOM devices and which "
"wires them up appropriately. This function allows the container to create "
"GPIO arrays on itself which simply pass through to a GPIO array of one of "
"its internal devices."
msgstr ""

#: ../../../../include/hw/core/qdev.h:856
msgid ""
"If **dev** has both input and output GPIOs named **name** then both will be "
"passed through. It is not possible to pass a subset of the array with this "
"function."
msgstr ""

#: ../../../../include/hw/core/qdev.h:860
msgid ""
"To users of the container device, the GPIO array created on **container** "
"behaves exactly like any other."
msgstr ""

#: ../../../../include/hw/core/qdev.h:896
msgid "perform a recursive cold reset on a device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:897
msgid "device to reset."
msgstr ""

#: ../../../../include/hw/core/qdev.h:898
msgid ""
"Reset device **dev** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/core/qdev.h:905
msgid "perform a recursive cold reset on a bus"
msgstr ""

#: ../../../../include/hw/core/qdev.h:906
msgid "bus to reset"
msgstr ""

#: ../../../../include/hw/core/qdev.h:907
msgid ""
"Reset bus **bus** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/core/qdev.h:914
msgid "check device reset state"
msgstr ""

#: ../../../../include/hw/core/qdev.h:915
msgid "device to check"
msgstr ""

#: ../../../../include/hw/core/qdev.h:917
msgid "true if the device **dev** is currently being reset."
msgstr ""

#: ../../../../include/hw/core/qdev.h:922
msgid "check bus reset state"
msgstr ""

#: ../../../../include/hw/core/qdev.h:923
msgid "bus to check"
msgstr ""

#: ../../../../include/hw/core/qdev.h:925
msgid "true if the bus **bus** is currently being reset."
msgstr ""

#: ../../../../include/hw/core/qdev.h:938
msgid "``device_class_set_props (dc, props)``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:936
#: ../../../../include/hw/core/qdev.h:960
msgid "add a set of properties to an device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:942
msgid "``dc``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:937
#: ../../../../include/hw/core/qdev.h:961
msgid "the parent DeviceClass all devices inherit"
msgstr ""

#: ../../../../include/hw/core/qdev.h:939
msgid "``props``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:938
#: ../../../../include/hw/core/qdev.h:962
msgid "an array of properties"
msgstr ""

#: ../../../../include/hw/core/qdev.h:939
#: ../../../../include/hw/core/qdev.h:964
msgid ""
"This will add a set of properties to the object. It will fault if you "
"attempt to add an existing property defined by a parent class. To modify an "
"inherited property you need to use????"
msgstr ""

#: ../../../../include/hw/core/qdev.h:943
msgid ""
"Validate that **props** has at least one Property. Validate that **props** "
"is an array, not a pointer, via ARRAY_SIZE. Validate that the array does not "
"have a legacy terminator at compile-time; requires -O2 and the array to be "
"const."
msgstr ""

#: ../../../../include/hw/core/qdev.h:966
#: ../../../../include/hw/core/qdev.h:978
#: ../../../../include/hw/core/qdev.h:994
#: ../../../../include/hw/core/qdev.h:1008
msgid "``DeviceClass *dc``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:963
msgid "``const Property *props``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:964
msgid "``size_t n``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:963
msgid "ARRAY_SIZE(**props**)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:972
msgid "set up for chaining realize fns"
msgstr ""

#: ../../../../include/hw/core/qdev.h:973
#: ../../../../include/hw/core/qdev.h:989
#: ../../../../include/hw/core/qdev.h:1003
msgid "The device class"
msgstr ""

#: ../../../../include/hw/core/qdev.h:975
msgid "``DeviceRealize dev_realize``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:974
#: ../../../../include/hw/core/qdev.h:1004
msgid "the device realize function"
msgstr ""

#: ../../../../include/hw/core/qdev.h:976
msgid "``DeviceRealize *parent_realize``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:975
msgid "somewhere to save the parents realize function"
msgstr ""

#: ../../../../include/hw/core/qdev.h:976
msgid ""
"This is intended to be used when the new realize function will eventually "
"call its parent realization function during creation. This requires storing "
"the function call somewhere (usually in the instance structure) so you can "
"eventually call dc->parent_realize(dev, errp)"
msgstr ""

#: ../../../../include/hw/core/qdev.h:988
msgid "set the DeviceClass::reset method"
msgstr ""

#: ../../../../include/hw/core/qdev.h:991
msgid "``DeviceReset dev_reset``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:990
msgid "the reset function"
msgstr ""

#: ../../../../include/hw/core/qdev.h:991
msgid ""
"This function sets the DeviceClass::reset method. This is widely used in "
"existing code, but new code should prefer to use the Resettable API as "
"documented in docs/devel/reset.rst. In addition, devices which need to chain "
"to their parent class's reset methods or which need to be subclassed must "
"use Resettable."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1002
msgid "set up for chaining unrealize fns"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1005
msgid "``DeviceUnrealize dev_unrealize``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1006
msgid "``DeviceUnrealize *parent_unrealize``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1005
msgid "somewhere to save the parents unrealize function"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1006
msgid ""
"This is intended to be used when the new unrealize function will eventually "
"call its parent unrealization function during the unrealize phase. This "
"requires storing the function call somewhere (usually in the instance "
"structure) so you can eventually call dc->parent_unrealize(dev);"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1025
msgid "Create a fake machine container."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1031
msgid "``void``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1
msgid "no arguments"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1027
msgid ""
"This function is a kludge for user emulation (USER_ONLY) because when thread "
"(TYPE_CPU) are realized, qdev_realize() access a machine container."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1036
msgid "The name of container to lookup"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1037
msgid "Get a container of the machine (QOM path \"/machine/NAME\")."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1040
msgid "the machine container object."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1045
msgid "Return a human-readable name for a device"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1046
msgid "The device. Must be a valid and non-NULL pointer."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1048
msgid "This function is intended for user friendly error messages."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1051
msgid "Use g_free() to free it."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1051
msgid ""
"A newly allocated string containing the device id if not null, else the "
"object canonical path."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1086
msgid "Mark this bus as full, so no more devices can be attached"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1087
msgid "Bus to mark as full"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1088
msgid ""
"By default, QEMU will allow devices to be plugged into a bus up to the bus "
"class's device count limit. Calling this function marks a particular bus as "
"full, so that no more devices can be plugged into it. In particular this "
"means that the bus will not be considered as a candidate for plugging in "
"devices created by the user on the commandline or via the monitor. If a "
"machine has multiple buses of a given type, such as I2C, where some of those "
"buses in the real hardware are used only for internal devices and some are "
"exposed via expansion ports, you can use this function to mark the internal-"
"only buses as full after you have created all their internal devices. Then "
"user created devices will appear on the expansion-port bus where guest "
"software expects them."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1112
msgid "check if device should be hidden"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1118
msgid "``const QDict *opts``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1114
msgid "options QDict"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1116
msgid "``bool from_json``"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1115
msgid "true if **opts** entries are typed, false for all strings"
msgstr ""

#: ../../../../include/hw/core/qdev.h:1117
msgid "When a device is added via qdev_device_add() this will be called."
msgstr ""

#: ../../../../include/hw/core/qdev.h:1120
msgid "if the device should be added now or not."
msgstr ""
