# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../specs/fw_cfg.rst:3
msgid "QEMU Firmware Configuration (fw_cfg) Device"
msgstr ""

#: ../../../specs/fw_cfg.rst:6
msgid "Guest-side Hardware Interface"
msgstr ""

#: ../../../specs/fw_cfg.rst:8
msgid ""
"This hardware interface allows the guest to retrieve various data items "
"(blobs) that can influence how the firmware configures itself, or may "
"contain tables to be installed for the guest OS. Examples include device "
"boot order, ACPI and SMBIOS tables, virtual machine UUID, SMP and NUMA "
"information, kernel/initrd images for direct (Linux) kernel booting, etc."
msgstr ""

#: ../../../specs/fw_cfg.rst:15
msgid "Selector (Control) Register"
msgstr ""

#: ../../../specs/fw_cfg.rst:17
msgid "Write only"
msgstr ""

#: ../../../specs/fw_cfg.rst:18
msgid "Location: platform dependent (IOport or MMIO)"
msgstr ""

#: ../../../specs/fw_cfg.rst:19
msgid "Width: 16-bit"
msgstr ""

#: ../../../specs/fw_cfg.rst:20
msgid "Endianness: little-endian (if IOport), or big-endian (if MMIO)"
msgstr ""

#: ../../../specs/fw_cfg.rst:22
msgid ""
"A write to this register sets the index of a firmware configuration item "
"which can subsequently be accessed via the data register."
msgstr ""

#: ../../../specs/fw_cfg.rst:25
msgid ""
"Setting the selector register will cause the data offset to be set to zero. "
"The data offset impacts which data is accessed via the data register, and is "
"explained below."
msgstr ""

#: ../../../specs/fw_cfg.rst:29
msgid ""
"Bit14 of the selector register indicates whether the configuration setting "
"is being written. A value of 0 means the item is only being read, and all "
"write access to the data port will be ignored. A value of 1 means the item's "
"data can be overwritten by writes to the data register. In other words, "
"configuration write mode is enabled when the selector value is between "
"0x4000-0x7fff or 0xc000-0xffff."
msgstr ""

#: ../../../specs/fw_cfg.rst:37
msgid ""
"As of QEMU v2.4, writes to the fw_cfg data register are no longer supported, "
"and will be ignored (treated as no-ops)!"
msgstr ""

#: ../../../specs/fw_cfg.rst:41
msgid ""
"As of QEMU v2.9, writes are reinstated, but only through the DMA interface "
"(see below). Furthermore, writeability of any specific item is governed "
"independently of Bit14 in the selector key value."
msgstr ""

#: ../../../specs/fw_cfg.rst:45
msgid ""
"Bit15 of the selector register indicates whether the configuration setting "
"is architecture specific. A value of 0 means the item is a generic "
"configuration item. A value of 1 means the item is specific to a particular "
"architecture. In other words, generic configuration items are accessed with "
"a selector value between 0x0000-0x7fff, and architecture specific "
"configuration items are accessed with a selector value between 0x8000-0xffff."
msgstr ""

#: ../../../specs/fw_cfg.rst:54
msgid "Data Register"
msgstr ""

#: ../../../specs/fw_cfg.rst:56
msgid "Read/Write (writes ignored as of QEMU v2.4, but see the DMA interface)"
msgstr ""

#: ../../../specs/fw_cfg.rst:57
msgid "Location: platform dependent (IOport\\ [#placement]_ or MMIO)"
msgstr ""

#: ../../../specs/fw_cfg.rst:58
msgid "Width: 8-bit (if IOport), 8/16/32/64-bit (if MMIO)"
msgstr ""

#: ../../../specs/fw_cfg.rst:59
msgid "Endianness: string-preserving"
msgstr ""

#: ../../../specs/fw_cfg.rst:62
msgid ""
"On platforms where the data register is exposed as an IOport, its port "
"number will always be one greater than the port number of the selector "
"register. In other words, the two ports overlap, and can not be mapped "
"separately."
msgstr ""

#: ../../../specs/fw_cfg.rst:67
msgid ""
"The data register allows access to an array of bytes for each firmware "
"configuration data item. The specific item is selected by writing to the "
"selector register, as described above."
msgstr ""

#: ../../../specs/fw_cfg.rst:71
msgid ""
"Initially following a write to the selector register, the data offset will "
"be set to zero. Each successful access to the data register will increment "
"the data offset by the appropriate access width."
msgstr ""

#: ../../../specs/fw_cfg.rst:75
msgid ""
"Each firmware configuration item has a maximum length of data associated "
"with the item. After the data offset has passed the end of this maximum data "
"length, then any reads will return a data value of 0x00, and all writes will "
"be ignored."
msgstr ""

#: ../../../specs/fw_cfg.rst:80
msgid ""
"An N-byte wide read of the data register will return the next available N "
"bytes of the selected firmware configuration item, as a substring, in "
"increasing address order, similar to memcpy()."
msgstr ""

#: ../../../specs/fw_cfg.rst:85
msgid "Register Locations"
msgstr ""

#: ../../../specs/fw_cfg.rst:87
msgid "x86, x86_64"
msgstr ""

#: ../../../specs/fw_cfg.rst:88
msgid "Selector Register IOport: 0x510"
msgstr ""

#: ../../../specs/fw_cfg.rst:89
msgid "Data Register IOport:     0x511"
msgstr ""

#: ../../../specs/fw_cfg.rst:90
msgid "DMA Address IOport:       0x514"
msgstr ""

#: ../../../specs/fw_cfg.rst:92
msgid "Arm"
msgstr ""

#: ../../../specs/fw_cfg.rst:93
msgid "Selector Register address: Base + 8 (2 bytes)"
msgstr ""

#: ../../../specs/fw_cfg.rst:94
msgid "Data Register address:     Base + 0 (8 bytes)"
msgstr ""

#: ../../../specs/fw_cfg.rst:95
msgid "DMA Address address:       Base + 16 (8 bytes)"
msgstr ""

#: ../../../specs/fw_cfg.rst:98
msgid "ACPI Interface"
msgstr ""

#: ../../../specs/fw_cfg.rst:100
msgid ""
"The fw_cfg device is defined with ACPI ID ``QEMU0002``. Since we expect ACPI "
"tables to be passed into the guest through the fw_cfg device itself, the "
"guest-side firmware can not use ACPI to find fw_cfg. However, once the "
"firmware is finished setting up ACPI tables and hands control over to the "
"guest kernel, the latter can use the fw_cfg ACPI node for a more accurate "
"inventory of in-use IOport or MMIO regions."
msgstr ""

#: ../../../specs/fw_cfg.rst:108
msgid "Firmware Configuration Items"
msgstr ""

#: ../../../specs/fw_cfg.rst:111
msgid "Signature (Key 0x0000, ``FW_CFG_SIGNATURE``)"
msgstr ""

#: ../../../specs/fw_cfg.rst:113
msgid ""
"The presence of the fw_cfg selector and data registers can be verified by "
"selecting the \"signature\" item using key 0x0000 (``FW_CFG_SIGNATURE``), "
"and reading four bytes from the data register. If the fw_cfg device is "
"present, the four bytes read will contain the characters ``QEMU``."
msgstr ""

#: ../../../specs/fw_cfg.rst:118
msgid ""
"If the DMA interface is available, then reading the DMA Address Register "
"returns 0x51454d5520434647 (``QEMU CFG`` in big-endian format)."
msgstr ""

#: ../../../specs/fw_cfg.rst:122
msgid "Revision / feature bitmap (Key 0x0001, ``FW_CFG_ID``)"
msgstr ""

#: ../../../specs/fw_cfg.rst:124
msgid ""
"A 32-bit little-endian unsigned int, this item is used to check for enabled "
"features."
msgstr ""

#: ../../../specs/fw_cfg.rst:127
msgid "Bit 0: traditional interface. Always set."
msgstr ""

#: ../../../specs/fw_cfg.rst:128
msgid "Bit 1: DMA interface."
msgstr ""

#: ../../../specs/fw_cfg.rst:131
msgid "File Directory (Key 0x0019, ``FW_CFG_FILE_DIR``)"
msgstr ""

#: ../../../specs/fw_cfg.rst:135
msgid ""
"Firmware configuration items stored at selector keys 0x0020 or higher "
"(``FW_CFG_FILE_FIRST`` or higher) have an associated entry in a directory "
"structure, which makes it easier for guest-side firmware to identify and "
"retrieve them. The format of this file directory (from ``fw_cfg.h`` in the "
"QEMU source tree) is shown here, slightly annotated for clarity::"
msgstr ""

#: ../../../specs/fw_cfg.rst:141
msgid ""
"struct FWCfgFiles {         /* the entire file directory fw_cfg item */\n"
"    uint32_t count;         /* number of entries, in big-endian format */\n"
"    struct FWCfgFile f[];   /* array of file entries, see below */\n"
"};\n"
"\n"
"struct FWCfgFile {          /* an individual file entry, 64 bytes total */\n"
"    uint32_t size;          /* size of referenced fw_cfg item, big-endian "
"*/\n"
"    uint16_t select;        /* selector key of fw_cfg item, big-endian */\n"
"    uint16_t reserved;\n"
"    char name[56];          /* fw_cfg item name, NUL-terminated ascii */\n"
"};"
msgstr ""

#: ../../../specs/fw_cfg.rst:154
msgid "All Other Data Items"
msgstr ""

#: ../../../specs/fw_cfg.rst:156
msgid ""
"Please consult the QEMU source for the most up-to-date and authoritative "
"list of selector keys and their respective items' purpose, format and "
"writeability."
msgstr ""

#: ../../../specs/fw_cfg.rst:160
msgid "Ranges"
msgstr ""

#: ../../../specs/fw_cfg.rst:162
msgid ""
"Theoretically, there may be up to 0x4000 generic firmware configuration "
"items, and up to 0x4000 architecturally specific ones."
msgstr ""

#: ../../../specs/fw_cfg.rst:166
msgid "Selector Reg."
msgstr ""

#: ../../../specs/fw_cfg.rst:166
msgid "Range Usage"
msgstr ""

#: ../../../specs/fw_cfg.rst:168
msgid "0x0000 - 0x3fff"
msgstr ""

#: ../../../specs/fw_cfg.rst:168
msgid ""
"Generic (0x0000 - 0x3fff, generally RO, possibly RW through the DMA "
"interface in QEMU v2.9+)"
msgstr ""

#: ../../../specs/fw_cfg.rst:170
msgid "0x4000 - 0x7fff"
msgstr ""

#: ../../../specs/fw_cfg.rst:170
msgid "Generic (0x0000 - 0x3fff, RW, ignored in QEMU v2.4+)"
msgstr ""

#: ../../../specs/fw_cfg.rst:171
msgid "0x8000 - 0xbfff"
msgstr ""

#: ../../../specs/fw_cfg.rst:171
msgid ""
"Arch. Specific (0x0000 - 0x3fff, generally RO, possibly RW through the DMA "
"interface in QEMU v2.9+)"
msgstr ""

#: ../../../specs/fw_cfg.rst:173
msgid "0xc000 - 0xffff"
msgstr ""

#: ../../../specs/fw_cfg.rst:173
msgid "Arch. Specific (0x0000 - 0x3fff, RW, ignored in v2.4+)"
msgstr ""

#: ../../../specs/fw_cfg.rst:176
msgid ""
"In practice, the number of allowed firmware configuration items depends on "
"the machine type/version."
msgstr ""

#: ../../../specs/fw_cfg.rst:180
msgid "Guest-side DMA Interface"
msgstr ""

#: ../../../specs/fw_cfg.rst:182
msgid ""
"If bit 1 of the feature bitmap is set, the DMA interface is present. This "
"does not replace the existing fw_cfg interface, it is an add-on. This "
"interface can be used through the 64-bit wide address register."
msgstr ""

#: ../../../specs/fw_cfg.rst:186
msgid ""
"The address register is in big-endian format. The value for the register is "
"0 at startup and after an operation. A write to the least significant half "
"(at offset 4) triggers an operation. This means that operations with 32-bit "
"addresses can be triggered with just one write, whereas operations with 64-"
"bit addresses can be triggered with one 64-bit write or two 32-bit writes, "
"starting with the most significant half (at offset 0)."
msgstr ""

#: ../../../specs/fw_cfg.rst:193
msgid ""
"In this register, the physical address of a ``FWCfgDmaAccess`` structure in "
"RAM should be written. This is the format of the ``FWCfgDmaAccess`` "
"structure::"
msgstr ""

#: ../../../specs/fw_cfg.rst:196
msgid ""
"typedef struct FWCfgDmaAccess {\n"
"    uint32_t control;\n"
"    uint32_t length;\n"
"    uint64_t address;\n"
"} FWCfgDmaAccess;"
msgstr ""

#: ../../../specs/fw_cfg.rst:202
msgid ""
"The fields of the structure are in big endian mode, and the field at the "
"lowest address is the ``control`` field."
msgstr ""

#: ../../../specs/fw_cfg.rst:205
msgid "The ``control`` field has the following bits:"
msgstr ""

#: ../../../specs/fw_cfg.rst:207
msgid "Bit 0: Error"
msgstr ""

#: ../../../specs/fw_cfg.rst:208
msgid "Bit 1: Read"
msgstr ""

#: ../../../specs/fw_cfg.rst:209
msgid "Bit 2: Skip"
msgstr ""

#: ../../../specs/fw_cfg.rst:210
msgid "Bit 3: Select. The upper 16 bits are the selected index."
msgstr ""

#: ../../../specs/fw_cfg.rst:211
msgid "Bit 4: Write"
msgstr ""

#: ../../../specs/fw_cfg.rst:213
msgid ""
"When an operation is triggered, if the ``control`` field has bit 3 set, the "
"upper 16 bits are interpreted as an index of a firmware configuration item. "
"This has the same effect as writing the selector register."
msgstr ""

#: ../../../specs/fw_cfg.rst:217
msgid ""
"If the ``control`` field has bit 1 set, a read operation will be performed. "
"``length`` bytes for the current selector and offset will be copied into the "
"physical RAM address specified by the ``address`` field."
msgstr ""

#: ../../../specs/fw_cfg.rst:221
msgid ""
"If the ``control`` field has bit 4 set (and not bit 1), a write operation "
"will be performed. ``length`` bytes will be copied from the physical RAM "
"address specified by the ``address`` field to the current selector and "
"offset. QEMU prevents starting or finishing the write beyond the end of the "
"item associated with the current selector (i.e., the item cannot be "
"resized). Truncated writes are dropped entirely. Writes to read-only items "
"are also rejected. All of these write errors set bit 0 (the error bit) in "
"the ``control`` field."
msgstr ""

#: ../../../specs/fw_cfg.rst:229
msgid ""
"If the ``control`` field has bit 2 set (and neither bit 1 nor bit 4), a skip "
"operation will be performed. The offset for the current selector will be "
"advanced ``length`` bytes."
msgstr ""

#: ../../../specs/fw_cfg.rst:233
msgid "To check the result, read the ``control`` field:"
msgstr ""

#: ../../../specs/fw_cfg.rst:235
msgid "Error bit set"
msgstr ""

#: ../../../specs/fw_cfg.rst:236
msgid "Something went wrong."
msgstr ""

#: ../../../specs/fw_cfg.rst:237
msgid "All bits cleared"
msgstr ""

#: ../../../specs/fw_cfg.rst:238
msgid "Transfer finished successfully."
msgstr ""

#: ../../../specs/fw_cfg.rst:239
msgid "Otherwise"
msgstr ""

#: ../../../specs/fw_cfg.rst:240
msgid ""
"Transfer still in progress (doesn't happen today due to implementation not "
"being async, but may in the future)."
msgstr ""

#: ../../../specs/fw_cfg.rst:245
msgid "Externally Provided Items"
msgstr ""

#: ../../../specs/fw_cfg.rst:247
msgid ""
"Since v2.4, \"file\" fw_cfg items (i.e., items with selector keys above "
"``FW_CFG_FILE_FIRST``, and with a corresponding entry in the fw_cfg file "
"directory structure) may be inserted via the QEMU command line, using the "
"following syntax::"
msgstr ""

#: ../../../specs/fw_cfg.rst:252
msgid "-fw_cfg [name=]<item_name>,file=<path>"
msgstr ""

#: ../../../specs/fw_cfg.rst:254
msgid "Or::"
msgstr ""

#: ../../../specs/fw_cfg.rst:256
msgid "-fw_cfg [name=]<item_name>,string=<string>"
msgstr ""

#: ../../../specs/fw_cfg.rst:258
msgid ""
"Since v5.1, QEMU allows some objects to generate fw_cfg-specific content, "
"the content is then associated with a \"file\" item using the 'gen_id' "
"option in the command line, using the following syntax::"
msgstr ""

#: ../../../specs/fw_cfg.rst:262
msgid ""
"-object <generator-type>,id=<generated_id>,[generator-specific-options] \\\n"
"-fw_cfg [name=]<item_name>,gen_id=<generated_id>"
msgstr ""

#: ../../../specs/fw_cfg.rst:265
msgid "See QEMU man page for more documentation."
msgstr ""

#: ../../../specs/fw_cfg.rst:267
msgid "Using item_name with plain ASCII characters only is recommended."
msgstr ""

#: ../../../specs/fw_cfg.rst:269
msgid ""
"Item names beginning with ``opt/`` are reserved for users.  QEMU will never "
"create entries with such names unless explicitly ordered by the user."
msgstr ""

#: ../../../specs/fw_cfg.rst:273
msgid ""
"To avoid clashes among different users, it is strongly recommended that you "
"use names beginning with ``opt/RFQDN/``, where RFQDN is a reverse fully "
"qualified domain name you control.  For instance, if SeaBIOS wanted to "
"define additional names, the prefix ``opt/org.seabios/`` would be "
"appropriate."
msgstr ""

#: ../../../specs/fw_cfg.rst:279
msgid "For historical reasons, ``opt/ovmf/`` is reserved for OVMF firmware."
msgstr ""

#: ../../../specs/fw_cfg.rst:281
msgid "Prefix ``opt/org.qemu/`` is reserved for QEMU itself."
msgstr ""

#: ../../../specs/fw_cfg.rst:283
msgid ""
"Use of names not beginning with ``opt/`` is potentially dangerous and "
"entirely unsupported.  QEMU will warn if you try."
msgstr ""

#: ../../../specs/fw_cfg.rst:286
msgid ""
"Use of names not beginning with ``opt/`` is tolerated with 'gen_id' (that "
"is, the warning is suppressed), but you must know exactly what you're doing."
msgstr ""

#: ../../../specs/fw_cfg.rst:290
msgid "All externally provided fw_cfg items are read-only to the guest."
msgstr ""
