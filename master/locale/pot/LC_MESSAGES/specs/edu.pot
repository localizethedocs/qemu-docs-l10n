# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../specs/edu.rst:3
msgid "EDU device"
msgstr ""

#: ../../../specs/edu.rst:10
msgid ""
"This is an educational device for writing (kernel) drivers. Its original "
"intention was to support the Linux kernel lectures taught at the Masaryk "
"University. Students are given this virtual device and are expected to write "
"a driver with I/Os, IRQs, DMAs and such."
msgstr ""

#: ../../../specs/edu.rst:15
msgid ""
"The devices behaves very similar to the PCI bridge present in the COMBO6 "
"cards developed under the Liberouter wings. Both PCI device ID and PCI space "
"is inherited from that device."
msgstr ""

#: ../../../specs/edu.rst:20
msgid "Command line switches"
msgstr ""

#: ../../../specs/edu.rst:22
msgid "``-device edu[,dma_mask=mask]``"
msgstr ""

#: ../../../specs/edu.rst:23
msgid ""
"``dma_mask`` makes the virtual device work with DMA addresses with the given "
"mask. For educational purposes, the device supports only 28 bits (256 MiB) "
"by default. Students shall set dma_mask for the device in the OS driver "
"properly."
msgstr ""

#: ../../../specs/edu.rst:29
msgid "PCI specs"
msgstr ""

#: ../../../specs/edu.rst:31
msgid "PCI ID:"
msgstr ""

#: ../../../specs/edu.rst:32
msgid "``1234:11e8``"
msgstr ""

#: ../../../specs/edu.rst:34
msgid "PCI Region 0:"
msgstr ""

#: ../../../specs/edu.rst:35
msgid ""
"I/O memory, 1 MB in size. Users are supposed to communicate with the card "
"through this memory."
msgstr ""

#: ../../../specs/edu.rst:39
msgid "MMIO area spec"
msgstr ""

#: ../../../specs/edu.rst:41
msgid ""
"Only ``size == 4`` accesses are allowed for addresses ``< 0x80``. ``size == "
"4`` or ``size == 8`` for the rest."
msgstr ""

#: ../../../specs/edu.rst:44
msgid "0x00 (RO)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "identification"
msgstr ""

#: ../../../specs/edu.rst:45
msgid ""
"Value is in the form ``0xRRrr00edu`` where: - ``RR`` -- major version - "
"``rr`` -- minor version"
msgstr ""

#: ../../../specs/edu.rst:49
msgid "0x04 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "card liveness check"
msgstr ""

#: ../../../specs/edu.rst:50
msgid "It is a simple value inversion (``~`` C operator)."
msgstr ""

#: ../../../specs/edu.rst:52
msgid "0x08 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "factorial computation"
msgstr ""

#: ../../../specs/edu.rst:53
msgid ""
"The stored value is taken and factorial of it is put back here. This happens "
"only after factorial bit in the status register (0x20 below) is cleared."
msgstr ""

#: ../../../specs/edu.rst:57
msgid "0x20 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "status register"
msgstr ""

#: ../../../specs/edu.rst:58 ../../../specs/edu.rst:88
msgid "Bitwise OR of:"
msgstr ""

#: ../../../specs/edu.rst:60 ../../../specs/edu.rst:90
msgid "0x01"
msgstr ""

#: ../../../specs/edu.rst:61
msgid "computing factorial (RO)"
msgstr ""

#: ../../../specs/edu.rst:62
msgid "0x80"
msgstr ""

#: ../../../specs/edu.rst:63
msgid "raise interrupt after finishing factorial computation"
msgstr ""

#: ../../../specs/edu.rst:65
msgid "0x24 (RO)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "interrupt status register"
msgstr ""

#: ../../../specs/edu.rst:66
msgid ""
"It contains values which raised the interrupt (see interrupt raise register "
"below)."
msgstr ""

#: ../../../specs/edu.rst:69
msgid "0x60 (WO)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "interrupt raise register"
msgstr ""

#: ../../../specs/edu.rst:70
msgid ""
"Raise an interrupt. The value will be put to the interrupt status register "
"(using bitwise OR)."
msgstr ""

#: ../../../specs/edu.rst:73
msgid "0x64 (WO)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "interrupt acknowledge register"
msgstr ""

#: ../../../specs/edu.rst:74
msgid ""
"Clear an interrupt. The value will be cleared from the interrupt status "
"register. This needs to be done from the ISR to stop generating interrupts."
msgstr ""

#: ../../../specs/edu.rst:78
msgid "0x80 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "DMA source address"
msgstr ""

#: ../../../specs/edu.rst:79
msgid "Where to perform the DMA from."
msgstr ""

#: ../../../specs/edu.rst:81
msgid "0x88 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "DMA destination address"
msgstr ""

#: ../../../specs/edu.rst:82
msgid "Where to perform the DMA to."
msgstr ""

#: ../../../specs/edu.rst:84
msgid "0x90 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "DMA transfer count"
msgstr ""

#: ../../../specs/edu.rst:85
msgid "The size of the area to perform the DMA on."
msgstr ""

#: ../../../specs/edu.rst:87
msgid "0x98 (RW)"
msgstr ""

#: ../../../specs/edu.rst:-1
msgid "DMA command register"
msgstr ""

#: ../../../specs/edu.rst:91
msgid "start transfer"
msgstr ""

#: ../../../specs/edu.rst:92
msgid "0x02"
msgstr ""

#: ../../../specs/edu.rst:93
msgid "direction (0: from RAM to EDU, 1: from EDU to RAM)"
msgstr ""

#: ../../../specs/edu.rst:94
msgid "0x04"
msgstr ""

#: ../../../specs/edu.rst:95
msgid "raise interrupt 0x100 after finishing the DMA"
msgstr ""

#: ../../../specs/edu.rst:98
msgid "IRQ controller"
msgstr ""

#: ../../../specs/edu.rst:100
msgid ""
"An IRQ is generated when written to the interrupt raise register. The value "
"appears in interrupt status register when the interrupt is raised and has to "
"be written to the interrupt acknowledge register to lower it."
msgstr ""

#: ../../../specs/edu.rst:104
msgid ""
"The device supports both INTx and MSI interrupt. By default, INTx is used. "
"Even if the driver disabled INTx and only uses MSI, it still needs to update "
"the acknowledge register at the end of the IRQ handler routine."
msgstr ""

#: ../../../specs/edu.rst:110
msgid "DMA controller"
msgstr ""

#: ../../../specs/edu.rst:112
msgid ""
"One has to specify, source, destination, size, and start the transfer. One "
"4096 bytes long buffer at offset 0x40000 is available in the EDU device. I."
"e. one can perform DMA to/from this space when programmed properly."
msgstr ""

#: ../../../specs/edu.rst:116
msgid ""
"Example of transferring a 100 byte block to and from the buffer using a "
"given PCI address ``addr``:"
msgstr ""

#: ../../../specs/edu.rst:121
msgid ""
"addr     -> DMA source address\n"
"0x40000  -> DMA destination address\n"
"100      -> DMA transfer count\n"
"1        -> DMA command register\n"
"while (DMA command register & 1)\n"
"    ;"
msgstr ""

#: ../../../specs/edu.rst:130
msgid ""
"0x40000  -> DMA source address\n"
"addr+100 -> DMA destination address\n"
"100      -> DMA transfer count\n"
"3        -> DMA command register\n"
"while (DMA command register & 1)\n"
"    ;"
msgstr ""
