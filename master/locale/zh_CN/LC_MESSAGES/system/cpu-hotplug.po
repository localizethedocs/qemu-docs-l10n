# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-03 08:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../system/cpu-hotplug.rst:3
msgid "Virtual CPU hotplug"
msgstr ""

#: ../../../system/cpu-hotplug.rst:5
msgid ""
"A complete example of vCPU hotplug (and hot-unplug) using QMP ``device_add`` "
"and ``device_del``."
msgstr ""

#: ../../../system/cpu-hotplug.rst:9
msgid "vCPU hotplug"
msgstr ""

#: ../../../system/cpu-hotplug.rst:11
msgid ""
"Launch QEMU as follows (note that the \"maxcpus\" is mandatory to allow vCPU "
"hotplug)::"
msgstr ""

#: ../../../system/cpu-hotplug.rst:14
msgid ""
"$ qemu-system-x86_64 -display none -no-user-config -m 2048 \\\n"
"    -nodefaults -monitor stdio -machine pc,accel=kvm,usb=off \\\n"
"    -smp 1,maxcpus=2 -cpu IvyBridge-IBRS \\\n"
"    -qmp unix:/tmp/qmp-sock,server=on,wait=off"
msgstr ""

#: ../../../system/cpu-hotplug.rst:19
msgid ""
"Run 'qmp-shell' (located in the source tree, under: \"scripts/qmp/) to "
"connect to the just-launched QEMU::"
msgstr ""

#: ../../../system/cpu-hotplug.rst:22
msgid ""
"$> ./qmp-shell -p -v /tmp/qmp-sock\n"
"[...]\n"
"(QEMU)"
msgstr ""

#: ../../../system/cpu-hotplug.rst:26
msgid "Find out which CPU types could be plugged, and into which sockets::"
msgstr ""

#: ../../../system/cpu-hotplug.rst:28
msgid ""
"(QEMU) query-hotpluggable-cpus\n"
"{\n"
"    \"execute\": \"query-hotpluggable-cpus\",\n"
"    \"arguments\": {}\n"
"}\n"
"{\n"
"    \"return\": [\n"
"        {\n"
"            \"props\": {\n"
"                \"core-id\": 1,\n"
"                \"socket-id\": 0,\n"
"                \"thread-id\": 0\n"
"            },\n"
"            \"type\": \"IvyBridge-IBRS-x86_64-cpu\",\n"
"            \"vcpus-count\": 1\n"
"        },\n"
"        {\n"
"            \"props\": {\n"
"                \"core-id\": 0,\n"
"                \"socket-id\": 0,\n"
"                \"thread-id\": 0\n"
"            },\n"
"            \"qom-path\": \"/machine/unattached/device[0]\",\n"
"            \"type\": \"IvyBridge-IBRS-x86_64-cpu\",\n"
"            \"vcpus-count\": 1\n"
"        }\n"
"    ]\n"
"}\n"
"(QEMU)"
msgstr ""

#: ../../../system/cpu-hotplug.rst:58
msgid ""
"The ``query-hotpluggable-cpus`` command returns an object for CPUs that are "
"present (containing a \"qom-path\" member) or which may be hot-plugged (no "
"\"qom-path\" member).  From its output in step (3), we can see that "
"``IvyBridge-IBRS-x86_64-cpu`` is present in socket 0 core 0, while hot-"
"plugging a CPU into socket 0 core 1 requires passing the listed properties "
"to QMP ``device_add``::"
msgstr ""

#: ../../../system/cpu-hotplug.rst:65
msgid ""
"(QEMU) device_add id=cpu-2 driver=IvyBridge-IBRS-x86_64-cpu socket-id=0 core-"
"id=1 thread-id=0\n"
"{\n"
"    \"execute\": \"device_add\",\n"
"    \"arguments\": {\n"
"        \"core-id\": 1,\n"
"        \"driver\": \"IvyBridge-IBRS-x86_64-cpu\",\n"
"        \"id\": \"cpu-2\",\n"
"        \"socket-id\": 0,\n"
"        \"thread-id\": 0\n"
"    }\n"
"}\n"
"{\n"
"    \"return\": {}\n"
"}\n"
"(QEMU)"
msgstr ""

#: ../../../system/cpu-hotplug.rst:81
msgid ""
"Optionally, run QMP ``query-cpus-fast`` for some details about the vCPUs::"
msgstr ""

#: ../../../system/cpu-hotplug.rst:84
msgid ""
"(QEMU) query-cpus-fast\n"
"{\n"
"    \"arguments\": {}\n"
"    \"execute\": \"query-cpus-fast\",\n"
"}\n"
"{\n"
"    \"return\": [\n"
"        {\n"
"            \"cpu-index\": 0,\n"
"            \"props\": {\n"
"                \"core-id\": 0,\n"
"                \"socket-id\": 0,\n"
"                \"thread-id\": 0\n"
"            },\n"
"            \"qom-path\": \"/machine/unattached/device[0]\",\n"
"            \"target\": \"x86_64\",\n"
"            \"thread-id\": 28957\n"
"        },\n"
"        {\n"
"            \"cpu-index\": 1,\n"
"            \"props\": {\n"
"                \"core-id\": 1,\n"
"                \"socket-id\": 0,\n"
"                \"thread-id\": 0\n"
"            },\n"
"            \"qom-path\": \"/machine/peripheral/cpu-2\",\n"
"            \"target\": \"x86_64\",\n"
"            \"thread-id\": 29095\n"
"        }\n"
"    ]\n"
"}\n"
"(QEMU)"
msgstr ""

#: ../../../system/cpu-hotplug.rst:118
msgid "vCPU hot-unplug"
msgstr ""

#: ../../../system/cpu-hotplug.rst:120
msgid "From the 'qmp-shell', invoke the QMP ``device_del`` command::"
msgstr ""

#: ../../../system/cpu-hotplug.rst:122
msgid ""
"(QEMU) device_del id=cpu-2\n"
"{\n"
"    \"arguments\": {\n"
"        \"id\": \"cpu-2\"\n"
"    }\n"
"    \"execute\": \"device_del\",\n"
"}\n"
"{\n"
"    \"return\": {}\n"
"}\n"
"(QEMU)"
msgstr ""

#: ../../../system/cpu-hotplug.rst:135
msgid ""
"vCPU hot-unplug requires guest cooperation; so the ``device_del`` command "
"above does not guarantee vCPU removal -- it's a \"request to unplug\".  At "
"this point, the guest will get a System Control Interrupt (SCI) and calls "
"the ACPI handler for the affected vCPU device.  Then the guest kernel will "
"bring the vCPU offline and tell QEMU to unplug it."
msgstr ""
