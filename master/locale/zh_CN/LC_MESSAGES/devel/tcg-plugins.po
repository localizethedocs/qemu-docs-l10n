# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-03 08:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/tcg-plugins.rst:9
msgid "QEMU TCG Plugins"
msgstr ""

#: ../../../devel/tcg-plugins.rst:13
msgid "Writing plugins"
msgstr ""

#: ../../../devel/tcg-plugins.rst:16
msgid "API versioning"
msgstr ""

#: ../../../devel/tcg-plugins.rst:18
msgid ""
"This is a new feature for QEMU and it does allow people to develop out-of-"
"tree plugins that can be dynamically linked into a running QEMU process. "
"However the project reserves the right to change or break the API should it "
"need to do so. The best way to avoid this is to submit your plugin upstream "
"so they can be updated if/when the API changes."
msgstr ""

#: ../../../devel/tcg-plugins.rst:24
msgid ""
"All plugins need to declare a symbol which exports the plugin API version "
"they were built against. This can be done simply by::"
msgstr ""

#: ../../../devel/tcg-plugins.rst:27
msgid "QEMU_PLUGIN_EXPORT int qemu_plugin_version = QEMU_PLUGIN_VERSION;"
msgstr ""

#: ../../../devel/tcg-plugins.rst:29
msgid ""
"The core code will refuse to load a plugin that doesn't export a "
"``qemu_plugin_version`` symbol or if plugin version is outside of QEMU's "
"supported range of API versions."
msgstr ""

#: ../../../devel/tcg-plugins.rst:33
msgid ""
"Additionally the ``qemu_info_t`` structure which is passed to the "
"``qemu_plugin_install`` method of a plugin will detail the minimum and "
"current API versions supported by QEMU. The API version will be incremented "
"if new APIs are added. The minimum API version will be incremented if "
"existing APIs are changed or removed."
msgstr ""

#: ../../../devel/tcg-plugins.rst:40
msgid "Lifetime of the query handle"
msgstr ""

#: ../../../devel/tcg-plugins.rst:42
msgid ""
"Each callback provides an opaque anonymous information handle which can "
"usually be further queried to find out information about a translation, "
"instruction or operation. The handles themselves are only valid during the "
"lifetime of the callback so it is important that any information that is "
"needed is extracted during the callback and saved by the plugin."
msgstr ""

#: ../../../devel/tcg-plugins.rst:50
msgid "Plugin life cycle"
msgstr ""

#: ../../../devel/tcg-plugins.rst:52
msgid ""
"First the plugin is loaded and the public qemu_plugin_install function is "
"called. The plugin will then register callbacks for various plugin events. "
"Generally plugins will register a handler for the *atexit* if they want to "
"dump a summary of collected information once the program/system has finished "
"running."
msgstr ""

#: ../../../devel/tcg-plugins.rst:58
msgid ""
"When a registered event occurs the plugin callback is invoked. The callbacks "
"may provide additional information. In the case of a translation event the "
"plugin has an option to enumerate the instructions in a block of "
"instructions and optionally register callbacks to some or all instructions "
"when they are executed."
msgstr ""

#: ../../../devel/tcg-plugins.rst:64
msgid ""
"There is also a facility to add inline instructions doing various "
"operations, like adding or storing an immediate value. It is also possible "
"to execute a callback conditionally, with condition being evaluated inline. "
"All those inline operations are associated to a ``scoreboard``, which is a "
"thread-local storage automatically expanded when new cores/threads are "
"created and that can be accessed/modified in a thread-safe way without any "
"lock needed. Combining inline operations and conditional callbacks offer a "
"more efficient way to instrument binaries, compared to classic callbacks."
msgstr ""

#: ../../../devel/tcg-plugins.rst:73
msgid ""
"Finally when QEMU exits all the registered *atexit* callbacks are invoked."
msgstr ""

#: ../../../devel/tcg-plugins.rst:77
msgid "Exposure of QEMU internals"
msgstr ""

#: ../../../devel/tcg-plugins.rst:79
msgid ""
"The plugin architecture actively avoids leaking implementation details about "
"how QEMU's translation works to the plugins. While there are conceptions "
"such as translation time and translation blocks the details are opaque to "
"plugins. The plugin is able to query select details of instructions and "
"system configuration only through the exported *qemu_plugin* functions."
msgstr ""

#: ../../../devel/tcg-plugins.rst:86
msgid "However the following assumptions can be made:"
msgstr ""

#: ../../../devel/tcg-plugins.rst:89
msgid "Translation Blocks"
msgstr ""

#: ../../../devel/tcg-plugins.rst:91
msgid ""
"All code will go through a translation phase although not all translations "
"will be necessarily be executed. You need to instrument actual executions to "
"track what is happening."
msgstr ""

#: ../../../devel/tcg-plugins.rst:95
msgid ""
"It is quite normal to see the same address translated multiple times. If you "
"want to track the code in system emulation you should examine the underlying "
"physical address (``qemu_plugin_insn_haddr``) to take into account the "
"effects of virtual memory although if the system does paging this will "
"change too."
msgstr ""

#: ../../../devel/tcg-plugins.rst:101
msgid ""
"Not all instructions in a block will always execute so if its important to "
"track individual instruction execution you need to instrument them directly. "
"However asynchronous interrupts will not change control flow mid-block."
msgstr ""

#: ../../../devel/tcg-plugins.rst:107
msgid "Instructions"
msgstr ""

#: ../../../devel/tcg-plugins.rst:109
msgid ""
"Instruction instrumentation runs before the instruction executes. You can be "
"can be sure the instruction will be dispatched, but you can't be sure it "
"will complete. Generally this will be because of a synchronous exception (e."
"g. SIGILL) triggered by the instruction attempting to execute. If you want "
"to be sure you will need to instrument the next instruction as well. See the "
"``execlog.c`` plugin for examples of how to track this and finalise details "
"after execution."
msgstr ""

#: ../../../devel/tcg-plugins.rst:118
msgid "Memory Accesses"
msgstr ""

#: ../../../devel/tcg-plugins.rst:120
msgid ""
"Memory callbacks are called after a successful load or store. Unsuccessful "
"operations (i.e. faults) will not be visible to memory instrumentation "
"although the execution side effects can be observed (e.g. entering a "
"exception handler)."
msgstr ""

#: ../../../devel/tcg-plugins.rst:126
msgid "System Idle and Resume States"
msgstr ""

#: ../../../devel/tcg-plugins.rst:128
msgid ""
"The ``qemu_plugin_register_vcpu_idle_cb`` and "
"``qemu_plugin_register_vcpu_resume_cb`` functions can be used to track when "
"CPUs go into and return from sleep states when waiting for external I/O. Be "
"aware though that these may occur less frequently than in real HW due to the "
"inefficiencies of emulation giving less chance for the CPU to idle."
msgstr ""

#: ../../../devel/tcg-plugins.rst:136
msgid "Internals"
msgstr ""

#: ../../../devel/tcg-plugins.rst:139
msgid "Locking"
msgstr ""

#: ../../../devel/tcg-plugins.rst:141
msgid ""
"We have to ensure we cannot deadlock, particularly under MTTCG. For this we "
"acquire a lock when called from plugin code. We also keep the list of "
"callbacks under RCU so that we do not have to hold the lock when calling the "
"callbacks. This is also for performance, since some callbacks (e.g. memory "
"access callbacks) might be called very frequently."
msgstr ""

#: ../../../devel/tcg-plugins.rst:148
msgid ""
"A consequence of this is that we keep our own list of CPUs, so that we do "
"not have to worry about locking order wrt cpu_list_lock."
msgstr ""

#: ../../../devel/tcg-plugins.rst:150
msgid ""
"Use a recursive lock, since we can get registration calls from callbacks."
msgstr ""

#: ../../../devel/tcg-plugins.rst:153
msgid ""
"As a result registering/unregistering callbacks is \"slow\", since it takes "
"a lock. But this is very infrequent; we want performance when calling (or "
"not calling) callbacks, not when registering them. Using RCU is great for "
"this."
msgstr ""

#: ../../../devel/tcg-plugins.rst:158
msgid ""
"We support the uninstallation of a plugin at any time (e.g. from plugin "
"callbacks). This allows plugins to remove themselves if they no longer want "
"to instrument the code. This operation is asynchronous which means callbacks "
"may still occur after the uninstall operation is requested. The plugin isn't "
"completely uninstalled until the safe work has executed while all vCPUs are "
"quiescent."
msgstr ""

#: ../../../devel/tcg-plugins.rst:166
msgid "Plugin API"
msgstr ""

#: ../../../devel/tcg-plugins.rst:168
msgid ""
"The following API is generated from the inline documentation in ``include/"
"qemu/qemu-plugin.h``. Please ensure any updates to the API include the full "
"kernel-doc annotations."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:41
msgid "Unique plugin ID"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:82
msgid "system information for plugins"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:86
msgid "**Definition**::"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:88
msgid ""
"struct qemu_info_t {\n"
"    const char *target_name;\n"
"    struct {\n"
"        int min;\n"
"        int cur;\n"
"    } version;\n"
"    bool system_emulation;\n"
"    union {\n"
"        struct {\n"
"            int smp_vcpus;\n"
"            int max_vcpus;\n"
"        } system;\n"
"    };\n"
"};"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:103
msgid "**Members**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:90
msgid "``target_name``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:91
msgid "string describing architecture"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:92
msgid "``version``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:93
msgid "minimum and current plugin API level"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:97
msgid "``system_emulation``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:98
msgid "is this a full system emulation?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:2
msgid "anonymous"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:100
msgid "``system``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:101
msgid "information relevant to system emulation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:3
#: ../../../../include/qemu/qemu-plugin.h:104
#: ../../../../include/qemu/qemu-plugin.h:117
#: ../../../../include/qemu/qemu-plugin.h:135
#: ../../../../include/qemu/qemu-plugin.h:195
#: ../../../../include/qemu/qemu-plugin.h:213
#: ../../../../include/qemu/qemu-plugin.h:227
#: ../../../../include/qemu/qemu-plugin.h:241
#: ../../../../include/qemu/qemu-plugin.h:254
#: ../../../../include/qemu/qemu-plugin.h:267
#: ../../../../include/qemu/qemu-plugin.h:278
#: ../../../../include/qemu/qemu-plugin.h:290
#: ../../../../include/qemu/qemu-plugin.h:310
#: ../../../../include/qemu/qemu-plugin.h:396
#: ../../../../include/qemu/qemu-plugin.h:414
#: ../../../../include/qemu/qemu-plugin.h:432
#: ../../../../include/qemu/qemu-plugin.h:467
#: ../../../../include/qemu/qemu-plugin.h:483
#: ../../../../include/qemu/qemu-plugin.h:501
#: ../../../../include/qemu/qemu-plugin.h:525
#: ../../../../include/qemu/qemu-plugin.h:557
#: ../../../../include/qemu/qemu-plugin.h:573
#: ../../../../include/qemu/qemu-plugin.h:609
#: ../../../../include/qemu/qemu-plugin.h:663
#: ../../../../include/qemu/qemu-plugin.h:685
#: ../../../../include/qemu/qemu-plugin.h:695
#: ../../../../include/qemu/qemu-plugin.h:730
#: ../../../../include/qemu/qemu-plugin.h:757
#: ../../../../include/qemu/qemu-plugin.h:785
#: ../../../../include/qemu/qemu-plugin.h:819
#: ../../../../include/qemu/qemu-plugin.h:829
#: ../../../../include/qemu/qemu-plugin.h:840
#: ../../../../include/qemu/qemu-plugin.h:858
#: ../../../../include/qemu/qemu-plugin.h:888
#: ../../../../include/qemu/qemu-plugin.h:967
#: ../../../../include/qemu/qemu-plugin.h:988
#: ../../../../include/qemu/qemu-plugin.h:1013
#: ../../../../include/qemu/qemu-plugin.h:1034
#: ../../../../include/qemu/qemu-plugin.h:1075
#: ../../../../include/qemu/qemu-plugin.h:1100
#: ../../../../include/qemu/qemu-plugin.h:1134
#: ../../../../include/qemu/qemu-plugin.h:1147
#: ../../../../include/qemu/qemu-plugin.h:1165
msgid "**Description**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:83
msgid ""
"This structure provides for some limited information about the system to "
"allow the plugin to make decisions on how to proceed. For example it might "
"only be suitable for running on some guest architectures or when under full "
"system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:111
msgid "Install a plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:115
#: ../../../../include/qemu/qemu-plugin.h:143
#: ../../../../include/qemu/qemu-plugin.h:151
#: ../../../../include/qemu/qemu-plugin.h:159
#: ../../../../include/qemu/qemu-plugin.h:167
#: ../../../../include/qemu/qemu-plugin.h:198
#: ../../../../include/qemu/qemu-plugin.h:213
#: ../../../../include/qemu/qemu-plugin.h:227
#: ../../../../include/qemu/qemu-plugin.h:241
#: ../../../../include/qemu/qemu-plugin.h:254
#: ../../../../include/qemu/qemu-plugin.h:267
#: ../../../../include/qemu/qemu-plugin.h:278
#: ../../../../include/qemu/qemu-plugin.h:289
#: ../../../../include/qemu/qemu-plugin.h:395
#: ../../../../include/qemu/qemu-plugin.h:396
#: ../../../../include/qemu/qemu-plugin.h:412
#: ../../../../include/qemu/qemu-plugin.h:427
#: ../../../../include/qemu/qemu-plugin.h:465
#: ../../../../include/qemu/qemu-plugin.h:481
#: ../../../../include/qemu/qemu-plugin.h:496
#: ../../../../include/qemu/qemu-plugin.h:523
#: ../../../../include/qemu/qemu-plugin.h:539
#: ../../../../include/qemu/qemu-plugin.h:548
#: ../../../../include/qemu/qemu-plugin.h:557
#: ../../../../include/qemu/qemu-plugin.h:572
#: ../../../../include/qemu/qemu-plugin.h:584
#: ../../../../include/qemu/qemu-plugin.h:593
#: ../../../../include/qemu/qemu-plugin.h:602
#: ../../../../include/qemu/qemu-plugin.h:621
#: ../../../../include/qemu/qemu-plugin.h:629
#: ../../../../include/qemu/qemu-plugin.h:637
#: ../../../../include/qemu/qemu-plugin.h:645
#: ../../../../include/qemu/qemu-plugin.h:654
#: ../../../../include/qemu/qemu-plugin.h:663
#: ../../../../include/qemu/qemu-plugin.h:686
#: ../../../../include/qemu/qemu-plugin.h:696
#: ../../../../include/qemu/qemu-plugin.h:722
#: ../../../../include/qemu/qemu-plugin.h:727
#: ../../../../include/qemu/qemu-plugin.h:754
#: ../../../../include/qemu/qemu-plugin.h:773
#: ../../../../include/qemu/qemu-plugin.h:785
#: ../../../../include/qemu/qemu-plugin.h:820
#: ../../../../include/qemu/qemu-plugin.h:830
#: ../../../../include/qemu/qemu-plugin.h:840
#: ../../../../include/qemu/qemu-plugin.h:857
#: ../../../../include/qemu/qemu-plugin.h:878
#: ../../../../include/qemu/qemu-plugin.h:885
#: ../../../../include/qemu/qemu-plugin.h:899
#: ../../../../include/qemu/qemu-plugin.h:910
#: ../../../../include/qemu/qemu-plugin.h:919
#: ../../../../include/qemu/qemu-plugin.h:928
#: ../../../../include/qemu/qemu-plugin.h:954
#: ../../../../include/qemu/qemu-plugin.h:966
#: ../../../../include/qemu/qemu-plugin.h:987
#: ../../../../include/qemu/qemu-plugin.h:1011
#: ../../../../include/qemu/qemu-plugin.h:1033
#: ../../../../include/qemu/qemu-plugin.h:1073
#: ../../../../include/qemu/qemu-plugin.h:1099
#: ../../../../include/qemu/qemu-plugin.h:1133
#: ../../../../include/qemu/qemu-plugin.h:1147
#: ../../../../include/qemu/qemu-plugin.h:1158
#: ../../../../include/qemu/qemu-plugin.h:1165
#: ../../../../include/qemu/qemu-plugin.h:1183
#: ../../../../include/qemu/qemu-plugin.h:1193
#: ../../../../include/qemu/qemu-plugin.h:1201
#: ../../../../include/qemu/qemu-plugin.h:1211
msgid "**Parameters**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:117
#: ../../../../include/qemu/qemu-plugin.h:145
#: ../../../../include/qemu/qemu-plugin.h:153
#: ../../../../include/qemu/qemu-plugin.h:161
#: ../../../../include/qemu/qemu-plugin.h:200
#: ../../../../include/qemu/qemu-plugin.h:215
#: ../../../../include/qemu/qemu-plugin.h:229
#: ../../../../include/qemu/qemu-plugin.h:243
#: ../../../../include/qemu/qemu-plugin.h:256
#: ../../../../include/qemu/qemu-plugin.h:269
#: ../../../../include/qemu/qemu-plugin.h:280
#: ../../../../include/qemu/qemu-plugin.h:291
#: ../../../../include/qemu/qemu-plugin.h:397
#: ../../../../include/qemu/qemu-plugin.h:398
#: ../../../../include/qemu/qemu-plugin.h:842
#: ../../../../include/qemu/qemu-plugin.h:859
msgid "``qemu_plugin_id_t id``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:112
#: ../../../../include/qemu/qemu-plugin.h:210
#: ../../../../include/qemu/qemu-plugin.h:224
msgid "this plugin's opaque ID"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:114
msgid "``const qemu_info_t *info``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:113
msgid "a block describing some details about the guest"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:115
msgid "``int argc``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:114
msgid "number of arguments"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:116
msgid "``char **argv``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:115
msgid "array of arguments (**argc** elements)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:116
msgid ""
"All plugins must export this symbol which is called when the plugin is first "
"loaded. Calling qemu_plugin_uninstall() from this function is a bug."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:120
#: ../../../../include/qemu/qemu-plugin.h:216
msgid "**Note**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:121
msgid ""
"**info** is only live during the call. Copy any information we want to keep. "
"**argv** remains valid throughout the lifetime of the loaded plugin."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:125
#: ../../../../include/qemu/qemu-plugin.h:538
#: ../../../../include/qemu/qemu-plugin.h:547
#: ../../../../include/qemu/qemu-plugin.h:560
#: ../../../../include/qemu/qemu-plugin.h:583
#: ../../../../include/qemu/qemu-plugin.h:592
#: ../../../../include/qemu/qemu-plugin.h:601
#: ../../../../include/qemu/qemu-plugin.h:620
#: ../../../../include/qemu/qemu-plugin.h:628
#: ../../../../include/qemu/qemu-plugin.h:636
#: ../../../../include/qemu/qemu-plugin.h:644
#: ../../../../include/qemu/qemu-plugin.h:653
msgid "**Return**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:125
msgid "0 on successful loading, !0 for an error."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:134
msgid "**Typedef**: simple callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:137
#: ../../../../include/qemu/qemu-plugin.h:145
#: ../../../../include/qemu/qemu-plugin.h:153
#: ../../../../include/qemu/qemu-plugin.h:161
#: ../../../../include/qemu/qemu-plugin.h:192
#: ../../../../include/qemu/qemu-plugin.h:389
#: ../../../../include/qemu/qemu-plugin.h:716
msgid "**Syntax**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:139
msgid "``void qemu_plugin_simple_cb_t (qemu_plugin_id_t id)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:133
#: ../../../../include/qemu/qemu-plugin.h:141
#: ../../../../include/qemu/qemu-plugin.h:149
msgid "the unique qemu_plugin_id_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:134
msgid "This callback passes no information aside from the unique **id**."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:142
msgid "**Typedef**: callback with user data"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:147
msgid "``void qemu_plugin_udata_cb_t (qemu_plugin_id_t id, void *userdata)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:143
#: ../../../../include/qemu/qemu-plugin.h:159
#: ../../../../include/qemu/qemu-plugin.h:413
#: ../../../../include/qemu/qemu-plugin.h:430
#: ../../../../include/qemu/qemu-plugin.h:482
#: ../../../../include/qemu/qemu-plugin.h:500
#: ../../../../include/qemu/qemu-plugin.h:716
#: ../../../../include/qemu/qemu-plugin.h:729
#: ../../../../include/qemu/qemu-plugin.h:857
msgid "``void *userdata``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:142
#: ../../../../include/qemu/qemu-plugin.h:158
msgid "a pointer to some user data supplied when the callback was registered."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:150
#: ../../../../include/qemu/qemu-plugin.h:158
msgid "**Typedef**: vcpu callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:155
msgid ""
"``void qemu_plugin_vcpu_simple_cb_t (qemu_plugin_id_t id, unsigned int "
"vcpu_index)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:151
#: ../../../../include/qemu/qemu-plugin.h:169
#: ../../../../include/qemu/qemu-plugin.h:190
#: ../../../../include/qemu/qemu-plugin.h:724
#: ../../../../include/qemu/qemu-plugin.h:1164
#: ../../../../include/qemu/qemu-plugin.h:1182
#: ../../../../include/qemu/qemu-plugin.h:1192
#: ../../../../include/qemu/qemu-plugin.h:1200
msgid "``unsigned int vcpu_index``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:150
#: ../../../../include/qemu/qemu-plugin.h:157
#: ../../../../include/qemu/qemu-plugin.h:189
msgid "the current vcpu context"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:163
msgid ""
"``void qemu_plugin_vcpu_udata_cb_t (unsigned int vcpu_index, void "
"*userdata)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:166
msgid "type of a (potential) PC discontinuity"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:170
#: ../../../../include/qemu/qemu-plugin.h:323
#: ../../../../include/qemu/qemu-plugin.h:365
#: ../../../../include/qemu/qemu-plugin.h:453
#: ../../../../include/qemu/qemu-plugin.h:1054
msgid "**Constants**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:172
msgid "``QEMU_PLUGIN_DISCON_INTERRUPT``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:173
msgid ""
"an interrupt, defined across all architectures as an asynchronous event, "
"usually originating from outside the CPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:177
msgid "``QEMU_PLUGIN_DISCON_EXCEPTION``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:178
msgid ""
"an exception, defined across all architectures as a synchronous event in "
"response to a specific instruction being executed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:182
msgid "``QEMU_PLUGIN_DISCON_HOSTCALL``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:183
msgid ""
"a host call, functionally a special kind of exception that is not handled by "
"code run by the vCPU but machinery outside the vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:187
msgid "``QEMU_PLUGIN_DISCON_ALL``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:188
msgid "all types of disconinuity events currently covered"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:189
msgid "**Typedef**: vcpu discontinuity callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:194
msgid ""
"``void qemu_plugin_vcpu_discon_cb_t (qemu_plugin_id_t id, unsigned int "
"vcpu_index, enum qemu_plugin_discon_type type, uint64_t from_pc, uint64_t "
"to_pc)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:188
#: ../../../../include/qemu/qemu-plugin.h:238
#: ../../../../include/qemu/qemu-plugin.h:251
#: ../../../../include/qemu/qemu-plugin.h:264
#: ../../../../include/qemu/qemu-plugin.h:275
#: ../../../../include/qemu/qemu-plugin.h:286
#: ../../../../include/qemu/qemu-plugin.h:393
#: ../../../../include/qemu/qemu-plugin.h:837
#: ../../../../include/qemu/qemu-plugin.h:854
msgid "plugin ID"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:191
#: ../../../../include/qemu/qemu-plugin.h:288
msgid "``enum qemu_plugin_discon_type type``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:190
msgid "the type of discontinuity"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:192
msgid "``uint64_t from_pc``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:191
msgid "the source of the discontinuity, e.g. the PC before the transition"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:194
msgid "``uint64_t to_pc``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:193
msgid "the PC pointing to the next instruction to be executed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:194
msgid ""
"The exact semantics of **from_pc** depends on the **type** of discontinuity. "
"For interrupts, **from_pc** will point to the next instruction which would "
"have been executed. For exceptions and host calls, **from_pc** will point to "
"the instruction that caused the exception or issued the host call. Note that "
"in the case of exceptions, the instruction may not be retired and thus not "
"observable via general instruction exec callbacks. The same may be the case "
"for some host calls such as hypervisor call \"exceptions\"."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:209
msgid "Uninstall a plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:212
#: ../../../../include/qemu/qemu-plugin.h:226
msgid "``qemu_plugin_simple_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:211
msgid "callback to be called once the plugin has been removed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:212
msgid ""
"Do NOT assume that the plugin has been uninstalled once this function "
"returns. Plugins are uninstalled asynchronously, and therefore the given "
"plugin receives callbacks until **cb** is called."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:217
msgid "Calling this function from qemu_plugin_install() is a bug."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:223
msgid "Reset a plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:225
msgid "callback to be called once the plugin has been reset"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:226
msgid "Unregisters all callbacks for the plugin given by **id**."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:228
msgid ""
"Do NOT assume that the plugin has been reset once this function returns. "
"Plugins are reset asynchronously, and therefore the given plugin receives "
"callbacks until **cb** is called."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:237
msgid "register a vCPU initialization callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:240
#: ../../../../include/qemu/qemu-plugin.h:253
#: ../../../../include/qemu/qemu-plugin.h:266
#: ../../../../include/qemu/qemu-plugin.h:277
#: ../../../../include/qemu/qemu-plugin.h:839
msgid "``qemu_plugin_vcpu_simple_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:239
#: ../../../../include/qemu/qemu-plugin.h:252
#: ../../../../include/qemu/qemu-plugin.h:265
#: ../../../../include/qemu/qemu-plugin.h:276
#: ../../../../include/qemu/qemu-plugin.h:288
#: ../../../../include/qemu/qemu-plugin.h:394
#: ../../../../include/qemu/qemu-plugin.h:410
#: ../../../../include/qemu/qemu-plugin.h:425
#: ../../../../include/qemu/qemu-plugin.h:479
#: ../../../../include/qemu/qemu-plugin.h:494
#: ../../../../include/qemu/qemu-plugin.h:838
msgid "callback function"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:240
msgid "The **cb** function is called every time a vCPU is initialized."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:242
msgid "See also: qemu_plugin_register_vcpu_exit_cb()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:250
msgid "register a vCPU exit callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:253
msgid "The **cb** function is called every time a vCPU exits."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:255
#: ../../../../include/qemu/qemu-plugin.h:841
msgid "See also: qemu_plugin_register_vcpu_init_cb()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:263
msgid "register a vCPU idle callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:266
msgid "The **cb** function is called every time a vCPU idles."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:274
msgid "register a vCPU resume callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:277
msgid "The **cb** function is called every time a vCPU resumes execution."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:285
msgid "register a discontinuity callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:287
msgid "types of discontinuities for which to call the callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:289
msgid "``qemu_plugin_vcpu_discon_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:289
msgid ""
"The **cb** function is called every time a vCPU receives a discontinuity "
"event of the specified type(s), after the vCPU was prepared to handle the "
"event. Preparation entails updating the PC, usually to some interrupt "
"handler or trap vector entry."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:308
msgid "uint64_t member of an entry in a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:309
msgid ""
"This field allows to access a specific uint64_t member in one given entry, "
"located at a specified offset. Inline operations expect this as entry."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:319
msgid "type of callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:325
msgid "``QEMU_PLUGIN_CB_NO_REGS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:326
msgid "callback does not access the CPU's regs"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:328
msgid "``QEMU_PLUGIN_CB_R_REGS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:329
msgid "callback reads the CPU's regs"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:331
msgid "``QEMU_PLUGIN_CB_RW_REGS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:332
msgid "callback reads and writes the CPU's regs"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:361
#: ../../../../include/qemu/qemu-plugin.h:426
#: ../../../../include/qemu/qemu-plugin.h:496
msgid "condition to enable callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:367
msgid "``QEMU_PLUGIN_COND_NEVER``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:368
msgid "false"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:370
msgid "``QEMU_PLUGIN_COND_ALWAYS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:371
msgid "true"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:373
msgid "``QEMU_PLUGIN_COND_EQ``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:374
msgid "is equal?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:376
msgid "``QEMU_PLUGIN_COND_NE``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:377
msgid "is not equal?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:379
msgid "``QEMU_PLUGIN_COND_LT``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:380
msgid "is less than?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:382
msgid "``QEMU_PLUGIN_COND_LE``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:383
msgid "is less than or equal?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:385
msgid "``QEMU_PLUGIN_COND_GT``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:386
msgid "is greater than?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:388
msgid "``QEMU_PLUGIN_COND_GE``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:389
msgid "is greater than or equal?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:386
msgid "**Typedef**: translation callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:391
msgid ""
"``void qemu_plugin_vcpu_tb_trans_cb_t (qemu_plugin_id_t id, struct "
"qemu_plugin_tb *tb)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:385
msgid "unique plugin id"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:387
#: ../../../../include/qemu/qemu-plugin.h:414
#: ../../../../include/qemu/qemu-plugin.h:429
#: ../../../../include/qemu/qemu-plugin.h:467
msgid "``struct qemu_plugin_tb *tb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:386
msgid "opaque handle used for querying and instrumenting a block."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:392
msgid "register a translate cb"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:395
msgid "``qemu_plugin_vcpu_tb_trans_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:395
msgid ""
"The **cb** function is called every time a translation occurs. The **cb** "
"function is passed an opaque qemu_plugin_type which it can query for "
"additional information including the list of translated instructions. At "
"this point the plugin can register further callbacks to be triggered when "
"the block or individual instruction executes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:408
msgid "register execution callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:409
#: ../../../../include/qemu/qemu-plugin.h:424
#: ../../../../include/qemu/qemu-plugin.h:462
msgid "the opaque qemu_plugin_tb handle for the translation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:411
#: ../../../../include/qemu/qemu-plugin.h:426
#: ../../../../include/qemu/qemu-plugin.h:480
#: ../../../../include/qemu/qemu-plugin.h:495
msgid "``qemu_plugin_vcpu_udata_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:412
#: ../../../../include/qemu/qemu-plugin.h:427
#: ../../../../include/qemu/qemu-plugin.h:481
#: ../../../../include/qemu/qemu-plugin.h:496
#: ../../../../include/qemu/qemu-plugin.h:727
msgid "``enum qemu_plugin_cb_flags flags``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:411
#: ../../../../include/qemu/qemu-plugin.h:429
#: ../../../../include/qemu/qemu-plugin.h:480
#: ../../../../include/qemu/qemu-plugin.h:495
msgid "does the plugin read or write the CPU's registers?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:412
#: ../../../../include/qemu/qemu-plugin.h:430
#: ../../../../include/qemu/qemu-plugin.h:481
#: ../../../../include/qemu/qemu-plugin.h:499
msgid "any plugin data to pass to the **cb**?"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:413
msgid "The **cb** function is called every time a translated unit executes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:423
msgid "register conditional callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:431
#: ../../../../include/qemu/qemu-plugin.h:497
msgid "``enum qemu_plugin_cond cond``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:428
#: ../../../../include/qemu/qemu-plugin.h:465
#: ../../../../include/qemu/qemu-plugin.h:498
#: ../../../../include/qemu/qemu-plugin.h:523
#: ../../../../include/qemu/qemu-plugin.h:755
#: ../../../../include/qemu/qemu-plugin.h:1185
#: ../../../../include/qemu/qemu-plugin.h:1195
#: ../../../../include/qemu/qemu-plugin.h:1203
#: ../../../../include/qemu/qemu-plugin.h:1213
msgid "``qemu_plugin_u64 entry``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:427
#: ../../../../include/qemu/qemu-plugin.h:497
msgid "first operand for condition"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:429
#: ../../../../include/qemu/qemu-plugin.h:466
#: ../../../../include/qemu/qemu-plugin.h:499
#: ../../../../include/qemu/qemu-plugin.h:524
#: ../../../../include/qemu/qemu-plugin.h:756
msgid "``uint64_t imm``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:428
#: ../../../../include/qemu/qemu-plugin.h:498
msgid "second operand for condition"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:431
msgid ""
"The **cb** function is called when a translated unit executes if entry "
"**cond** imm is true. If condition is QEMU_PLUGIN_COND_ALWAYS, condition is "
"never interpreted and this function is equivalent to "
"qemu_plugin_register_vcpu_tb_exec_cb. If condition QEMU_PLUGIN_COND_NEVER, "
"condition is never interpreted and callback is never installed."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:449
msgid "describes an inline op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:455
msgid "``QEMU_PLUGIN_INLINE_ADD_U64``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:456
msgid "add an immediate value uint64_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:458
msgid "``QEMU_PLUGIN_INLINE_STORE_U64``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:459
msgid "store an immediate value uint64_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:461
msgid "execution inline op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:464
#: ../../../../include/qemu/qemu-plugin.h:522
#: ../../../../include/qemu/qemu-plugin.h:754
msgid "``enum qemu_plugin_op op``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:463
#: ../../../../include/qemu/qemu-plugin.h:521
msgid "the type of qemu_plugin_op (e.g. ADD_U64)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:464
#: ../../../../include/qemu/qemu-plugin.h:522
#: ../../../../include/qemu/qemu-plugin.h:754
msgid "entry to run op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:465
#: ../../../../include/qemu/qemu-plugin.h:523
msgid "the op data (e.g. 1)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:466
msgid "Insert an inline op on a given scoreboard entry."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:477
msgid "register insn execution cb"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:483
#: ../../../../include/qemu/qemu-plugin.h:498
#: ../../../../include/qemu/qemu-plugin.h:525
#: ../../../../include/qemu/qemu-plugin.h:729
#: ../../../../include/qemu/qemu-plugin.h:756
msgid "``struct qemu_plugin_insn *insn``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:478
#: ../../../../include/qemu/qemu-plugin.h:493
#: ../../../../include/qemu/qemu-plugin.h:520
msgid "the opaque qemu_plugin_insn handle for an instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:482
msgid "The **cb** function is called every time an instruction is executed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:492
msgid "conditional insn execution cb"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:500
msgid ""
"The **cb** function is called when an instruction executes if entry **cond** "
"imm is true. If condition is QEMU_PLUGIN_COND_ALWAYS, condition is never "
"interpreted and this function is equivalent to "
"qemu_plugin_register_vcpu_insn_exec_cb. If condition QEMU_PLUGIN_COND_NEVER, "
"condition is never interpreted and callback is never installed."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:519
msgid "insn exec inline op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:524
msgid "Insert an inline op to every time an instruction executes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:535
msgid "query helper for number of insns in TB"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:541
#: ../../../../include/qemu/qemu-plugin.h:550
#: ../../../../include/qemu/qemu-plugin.h:559
msgid "``const struct qemu_plugin_tb *tb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:536
#: ../../../../include/qemu/qemu-plugin.h:545
#: ../../../../include/qemu/qemu-plugin.h:554
msgid "opaque handle to TB passed to callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:538
msgid "number of instructions in this block"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:544
msgid "query helper for vaddr of TB start"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:547
msgid "virtual address of block start"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:553
msgid "retrieve handle for instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:556
msgid "``size_t idx``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:555
msgid "instruction number, 0 indexed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:556
msgid ""
"The returned handle can be used in follow up helper queries as well as when "
"instrumenting an instruction. It is only valid for the lifetime of the "
"callback."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:561
msgid "opaque handle to instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:568
msgid "copy instruction data"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:574
#: ../../../../include/qemu/qemu-plugin.h:586
#: ../../../../include/qemu/qemu-plugin.h:595
#: ../../../../include/qemu/qemu-plugin.h:604
#: ../../../../include/qemu/qemu-plugin.h:822
#: ../../../../include/qemu/qemu-plugin.h:832
msgid "``const struct qemu_plugin_insn *insn``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:569
#: ../../../../include/qemu/qemu-plugin.h:581
#: ../../../../include/qemu/qemu-plugin.h:590
#: ../../../../include/qemu/qemu-plugin.h:599
msgid "opaque instruction handle from qemu_plugin_tb_get_insn()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:571
msgid "``void *dest``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:570
msgid "destination into which data is copied"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:572
#: ../../../../include/qemu/qemu-plugin.h:1012
#: ../../../../include/qemu/qemu-plugin.h:1074
msgid "``size_t len``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:571
msgid "length of dest"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:572
msgid "Returns the number of bytes copied, minimum of **len** and insn size."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:580
msgid "return size of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:583
msgid "size of instruction in bytes"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:589
msgid "return vaddr of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:592
msgid "virtual address of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:598
msgid "return hardware addr of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:601
msgid "hardware (physical) target address of instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:607
#: ../../../../include/qemu/qemu-plugin.h:618
#: ../../../../include/qemu/qemu-plugin.h:626
#: ../../../../include/qemu/qemu-plugin.h:634
#: ../../../../include/qemu/qemu-plugin.h:642
#: ../../../../include/qemu/qemu-plugin.h:651
msgid "opaque memory transaction handle"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:608
msgid ""
"This can be further queried using the qemu_plugin_mem_* query functions."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:617
msgid "get size of access"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:623
#: ../../../../include/qemu/qemu-plugin.h:631
#: ../../../../include/qemu/qemu-plugin.h:639
#: ../../../../include/qemu/qemu-plugin.h:647
#: ../../../../include/qemu/qemu-plugin.h:656
#: ../../../../include/qemu/qemu-plugin.h:665
#: ../../../../include/qemu/qemu-plugin.h:714
msgid "``qemu_plugin_meminfo_t info``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:620
msgid "size of access in ^2 (0=byte, 1=16bit, 2=32bit etc...)"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:625
msgid "was the access sign extended"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:628
#: ../../../../include/qemu/qemu-plugin.h:636
#: ../../../../include/qemu/qemu-plugin.h:644
msgid "true if it was, otherwise false"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:633
msgid "was the access big endian"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:641
msgid "was the access a store"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:650
msgid "return last value loaded/stored"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:653
msgid "memory value"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:659
msgid "return handle for memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:660
msgid "opaque memory info structure"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:662
#: ../../../../include/qemu/qemu-plugin.h:715
#: ../../../../include/qemu/qemu-plugin.h:1135
msgid "``uint64_t vaddr``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:661
msgid "the virtual address of the memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:662
msgid ""
"For system emulation returns a qemu_plugin_hwaddr handle to query details "
"about the actual physical address backing the virtual address. For linux-"
"user guests it just returns NULL."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:666
msgid ""
"This handle is *only* valid for the duration of the callback. Any "
"information about the handle should be recovered before the callback returns."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:682
msgid "query whether memory operation is IO"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:688
#: ../../../../include/qemu/qemu-plugin.h:698
msgid "``const struct qemu_plugin_hwaddr *haddr``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:683
#: ../../../../include/qemu/qemu-plugin.h:693
msgid "address handle from qemu_plugin_get_hwaddr()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:684
msgid ""
"Returns true if the handle's memory operation is to memory-mapped IO, or "
"false if it is to RAM"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:692
msgid "query physical address for memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:694
msgid "Returns the physical address associated with the memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:696
msgid ""
"Note that the returned physical address may not be unique if you are dealing "
"with multiple address spaces."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:713
msgid "**Typedef**: memory callback function type"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:718
msgid ""
"``void qemu_plugin_vcpu_mem_cb_t (unsigned int vcpu_index, "
"qemu_plugin_meminfo_t info, uint64_t vaddr, void *userdata)``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:712
msgid "the executing vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:713
msgid "an opaque handle for further queries about the memory"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:714
msgid "the virtual address of the transaction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:715
msgid "any user data attached to the callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:723
msgid "register memory access callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:724
#: ../../../../include/qemu/qemu-plugin.h:751
msgid "handle for instruction to instrument"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:726
msgid "``qemu_plugin_vcpu_mem_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:725
msgid "callback of type qemu_plugin_vcpu_mem_cb_t"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:726
msgid "(currently unused) callback flags"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:728
#: ../../../../include/qemu/qemu-plugin.h:753
msgid "``enum qemu_plugin_mem_rw rw``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:727
msgid "monitor reads, writes or both"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:728
msgid "opaque pointer for userdata"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:729
msgid ""
"This registers a full callback for every memory access generated by an "
"instruction. If the instruction doesn't access memory no callback will be "
"made."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:733
msgid ""
"The callback reports the vCPU the access took place on, the virtual address "
"of the access and a handle for further queries. The user can attach some "
"userdata to the callback for additional purposes."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:737
msgid ""
"Other execution threads will continue to execute during the callback so the "
"plugin is responsible for ensuring it doesn't get confused by making "
"appropriate use of locking if required."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:750
msgid "inline op for mem access"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:752
msgid "apply to reads, writes or both"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:753
msgid "the op, of type qemu_plugin_op"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:755
msgid "immediate data for **op**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:756
msgid ""
"This registers a inline op every memory access generated by the instruction."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:769
msgid "request the ability to control time"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:775
#: ../../../../include/qemu/qemu-plugin.h:901
#: ../../../../include/qemu/qemu-plugin.h:912
#: ../../../../include/qemu/qemu-plugin.h:921
#: ../../../../include/qemu/qemu-plugin.h:930
#: ../../../../include/qemu/qemu-plugin.h:956
msgid "``void``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1
msgid "no arguments"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:770
msgid ""
"This grants the plugin the ability to control system time. Only one plugin "
"can control time so if multiple plugins request the ability all but the "
"first will fail."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:774
msgid "Returns an opaque handle or NULL if fails"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:781
msgid "update system emulation time"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:787
msgid "``const void *handle``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:782
msgid "opaque handle returned by qemu_plugin_request_time_control()"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:784
msgid "``int64_t time``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:783
msgid "time in nanoseconds"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:784
msgid ""
"This allows an appropriately authorised plugin (i.e. holding the time "
"control handle) to move system time forward to **time**. For user-mode "
"emulation the time is not changed by this as all reported time comes from "
"the host kernel."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:789
msgid "Start time is 0."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:816
msgid "return disassembly string for instruction"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:817
#: ../../../../include/qemu/qemu-plugin.h:827
msgid "instruction reference"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:818
msgid "Returns an allocated string containing the disassembly"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:826
msgid "best effort symbol lookup"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:828
msgid ""
"Return a static string referring to the symbol. This is dependent on the "
"binary QEMU is running having provided a symbol table."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:836
msgid "iterate over the existing vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:839
msgid "The **cb** function is called once for each existing vCPU."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:853
msgid "register exit callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:856
msgid "``qemu_plugin_udata_cb_t cb``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:855
msgid "callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:856
msgid "user data for callback"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:857
msgid ""
"The **cb** function is called once execution has finished. Plugins should be "
"able to free all their resources at this point much like after a reset/"
"uninstall callback is called."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:861
msgid ""
"In user-mode it is possible a few un-instrumented instructions from child "
"threads may run before the host kernel reaps the threads."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:874
msgid "output string via QEMU's logging system"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:880
msgid "``const char *string``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:875
msgid "a string"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:881
msgid ""
"parses a boolean argument in the form of \"<argname>=[on|yes|true|off|no|"
"false]\""
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:887
msgid "``const char *name``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:884
msgid "argument name, the part before the equals sign"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:886
msgid "``const char *val``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:885
msgid "argument value, what's after the equals sign"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:887
msgid "``bool *ret``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:886
msgid "output return value"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:887
msgid ""
"returns true if the combination **name**=**val** parses correctly to a "
"boolean argument, and false otherwise"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:895
msgid "path to binary file being executed"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:896
msgid ""
"Return a string representing the path to the binary. For user-mode this is "
"the main executable. For system emulation we currently return NULL. The user "
"should g_free() the string once no longer needed."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:906
msgid "returns start of text segment"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:907
msgid ""
"Returns the nominal start address of the main text segment in user-mode. "
"Currently returns 0 for system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:915
msgid "returns end of text segment"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:916
msgid ""
"Returns the nominal end address of the main text segment in user-mode. "
"Currently returns 0 for system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:924
msgid "returns start address for module"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:925
msgid ""
"Returns the nominal entry address of the main text segment in user-mode. "
"Currently returns 0 for system emulation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:936
msgid "register descriptions"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:950
msgid "return register list for current vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:951
msgid ""
"Returns a potentially empty GArray of qemu_plugin_reg_descriptor. Caller "
"frees the array (but not the const strings)."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:954
msgid ""
"Should be used from a qemu_plugin_register_vcpu_init_cb() callback after the "
"vCPU is initialised, i.e. in the vCPU context."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:962
msgid "read register for current vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:968
#: ../../../../include/qemu/qemu-plugin.h:989
msgid "``struct qemu_plugin_register *handle``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:964
#: ../../../../include/qemu/qemu-plugin.h:985
msgid "a **qemu_plugin_reg_handle** handle"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:966
#: ../../../../include/qemu/qemu-plugin.h:987
msgid "``GByteArray *buf``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:965
#: ../../../../include/qemu/qemu-plugin.h:986
msgid "A GByteArray for the data owned by the plugin"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:966
msgid ""
"This function is only available in a context that register read access is "
"explicitly requested via the QEMU_PLUGIN_CB_R_REGS flag, if called inside a "
"callback that can be registered with a qemu_plugin_cb_flags argument. This "
"function can also be used in any callback context that does not use a flags "
"argument, such as in a callback registered with "
"qemu_plugin_register_vcpu_init_cb(), except for callbacks registered with "
"qemu_plugin_register_atexit_cb() and qemu_plugin_register_flush_cb()."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:974
msgid ""
"Returns the size of the read register. The content of **buf** is in target "
"byte order. On failure returns -1."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:983
msgid "write register for current vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:987
msgid ""
"This function is only available in a context that register read access is "
"explicitly requested via the QEMU_PLUGIN_CB_RW_REGS flag, if called inside a "
"callback that can be registered with a qemu_plugin_cb_flags argument. This "
"function can also be used in any callback context that does not use a flags "
"argument, such as in a callback registered with "
"qemu_plugin_register_vcpu_init_cb(), except for callbacks registered with "
"qemu_plugin_register_atexit_cb() and qemu_plugin_register_flush_cb()."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:995
msgid ""
"The size of **buf** must be at least the size of the requested register. "
"Attempting to write a register with **buf** smaller than the register size "
"will result in a crash or other undesired behavior."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:999
msgid "Returns the number of bytes written. On failure returns 0."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1007
msgid "read from memory using a virtual address"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1013
#: ../../../../include/qemu/qemu-plugin.h:1035
#: ../../../../include/qemu/qemu-plugin.h:1075
#: ../../../../include/qemu/qemu-plugin.h:1101
msgid "``uint64_t addr``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1009
msgid "A virtual address to read from"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1011
#: ../../../../include/qemu/qemu-plugin.h:1033
#: ../../../../include/qemu/qemu-plugin.h:1073
#: ../../../../include/qemu/qemu-plugin.h:1099
msgid "``GByteArray *data``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1010
#: ../../../../include/qemu/qemu-plugin.h:1072
msgid "A byte array to store data into"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1011
#: ../../../../include/qemu/qemu-plugin.h:1073
msgid "The number of bytes to read, starting from **addr**"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1012
msgid ""
"**len** bytes of data is read starting at **addr** and stored into **data**. "
"If **data** is not large enough to hold **len** bytes, it will be expanded "
"to the necessary size, reallocating if necessary. **len** must be greater "
"than 0."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1016
#: ../../../../include/qemu/qemu-plugin.h:1079
msgid ""
"This function does not ensure writes are flushed prior to reading, so "
"callers should take care when calling this function in plugin callbacks to "
"avoid attempting to read data which may not yet be written and should use "
"the memory callback API instead."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1021
#: ../../../../include/qemu/qemu-plugin.h:1042
#: ../../../../include/qemu/qemu-plugin.h:1136
msgid "Returns true on success and false on failure."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1029
msgid "write to memory using a virtual address"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1031
msgid "A virtual address to write to"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1032
#: ../../../../include/qemu/qemu-plugin.h:1098
msgid "A byte array containing the data to write"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1033
msgid ""
"The contents of **data** will be written to memory starting at the virtual "
"address **addr**."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1036
msgid ""
"This function does not guarantee consistency of writes, nor does it ensure "
"that pending writes are flushed either before or after the write takes "
"place, so callers should take care to only call this function in vCPU "
"context (i.e. in callbacks) and avoid depending on the existence of data "
"written using this function which may be overwritten afterward."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1050
msgid "result of a memory operation"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1056
msgid "``QEMU_PLUGIN_HWADDR_OPERATION_OK``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1057
msgid "hwaddr operation succeeded"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1059
msgid "``QEMU_PLUGIN_HWADDR_OPERATION_ERROR``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1060
msgid "unexpected error occurred"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1062
msgid "``QEMU_PLUGIN_HWADDR_OPERATION_DEVICE_ERROR``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1063
msgid "error in memory device"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1065
msgid "``QEMU_PLUGIN_HWADDR_OPERATION_ACCESS_DENIED``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1066
msgid "permission error"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1068
msgid "``QEMU_PLUGIN_HWADDR_OPERATION_INVALID_ADDRESS``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1069
msgid "address was invalid"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1071
msgid "``QEMU_PLUGIN_HWADDR_OPERATION_INVALID_ADDRESS_SPACE``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1072
msgid "invalid address space"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1069
msgid "read from memory using a hardware address"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1071
msgid "The physical address to read from"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1074
msgid ""
"**len** bytes of data is read from the current memory space for the current "
"vCPU starting at **addr** and stored into **data**. If **data** is not large "
"enough to hold **len** bytes, it will be expanded to the necessary size, "
"reallocating if necessary. **len** must be greater than 0."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1084
#: ../../../../include/qemu/qemu-plugin.h:1118
msgid "This function is only valid for softmmu targets."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1086
#: ../../../../include/qemu/qemu-plugin.h:1120
msgid ""
"Returns a qemu_plugin_hwaddr_operation_result indicating the result of the "
"operation."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1095
msgid "write to memory using a hardware address"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1097
msgid "A physical address to write to"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1099
msgid ""
"The contents of **data** will be written to memory starting at the hardware "
"address **addr** in the current address space for the current vCPU."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1102
msgid ""
"This function does not guarantee consistency of writes, nor does it ensure "
"that pending writes are flushed either before or after the write takes "
"place, so callers should take care when calling this function in plugin "
"callbacks to avoid depending on the existence of data written using this "
"function which may be overwritten afterward. In addition, this function "
"requires that the pages containing the address are not locked. Practically, "
"this means that you should not write instruction memory in a current "
"translation block inside a callback registered with "
"qemu_plugin_register_vcpu_tb_trans_cb."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1111
msgid ""
"You can, for example, write instruction memory in a current translation "
"block in a callback registered with qemu_plugin_register_vcpu_tb_exec_cb, "
"although be aware that the write will not be flushed until after the "
"translation block has finished executing.  In general, this function should "
"be used to write data memory or to patch code at a known address, not in a "
"current translation block."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1129
msgid "translate virtual address for current vCPU"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1131
msgid "virtual address to translate"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1133
msgid "``uint64_t *hwaddr``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1132
msgid "pointer to store the physical address"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1133
msgid ""
"This function is only valid in vCPU context (i.e. in callbacks) and is only "
"valid for softmmu targets."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1143
msgid "alloc a new scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1149
msgid "``size_t element_size``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1145
msgid "size (in bytes) for one entry"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1146
msgid ""
"Returns a pointer to a new scoreboard. It must be freed using "
"qemu_plugin_scoreboard_free."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1154
msgid "free a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1160
#: ../../../../include/qemu/qemu-plugin.h:1167
msgid "``struct qemu_plugin_scoreboard *score``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1155
msgid "scoreboard to free"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1161
msgid "get pointer to an entry of a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1162
msgid "scoreboard to query"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1163
#: ../../../../include/qemu/qemu-plugin.h:1181
#: ../../../../include/qemu/qemu-plugin.h:1191
#: ../../../../include/qemu/qemu-plugin.h:1199
msgid "entry index"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1164
msgid ""
"Returns address of entry of a scoreboard matching a given vcpu_index. This "
"address can be modified later if scoreboard is resized."
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1179
msgid "add a value to a qemu_plugin_u64 for a given vcpu"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1180
#: ../../../../include/qemu/qemu-plugin.h:1190
#: ../../../../include/qemu/qemu-plugin.h:1198
msgid "entry to query"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1183
msgid "``uint64_t added``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1182
msgid "value to add"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1189
msgid "get value of a qemu_plugin_u64 for a given vcpu"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1197
msgid "set value of a qemu_plugin_u64 for a given vcpu"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1201
msgid "``uint64_t val``"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1200
msgid "new value"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1207
msgid "return sum of all vcpu entries in a scoreboard"
msgstr ""

#: ../../../../include/qemu/qemu-plugin.h:1208
msgid "entry to sum"
msgstr ""
