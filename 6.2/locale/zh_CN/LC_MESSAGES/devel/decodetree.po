# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 6.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/decodetree.rst:3
msgid "Decodetree Specification"
msgstr ""

#: ../../../devel/decodetree.rst:5
msgid ""
"A *decodetree* is built from instruction *patterns*.  A pattern may "
"represent a single architectural instruction or a group of same, depending "
"on what is convenient for further processing."
msgstr ""

#: ../../../devel/decodetree.rst:9
msgid ""
"Each pattern has both *fixedbits* and *fixedmask*, the combination of which "
"describes the condition under which the pattern is matched::"
msgstr ""

#: ../../../devel/decodetree.rst:12
msgid "(insn & fixedmask) == fixedbits"
msgstr ""

#: ../../../devel/decodetree.rst:14
msgid ""
"Each pattern may have *fields*, which are extracted from the insn and passed "
"along to the translator.  Examples of such are registers, immediates, and "
"sub-opcodes."
msgstr ""

#: ../../../devel/decodetree.rst:18
msgid ""
"In support of patterns, one may declare *fields*, *argument sets*, and "
"*formats*, each of which may be re-used to simplify further definitions."
msgstr ""

#: ../../../devel/decodetree.rst:22
msgid "Fields"
msgstr ""

#: ../../../devel/decodetree.rst:24 ../../../devel/decodetree.rst:63
#: ../../../devel/decodetree.rst:97 ../../../devel/decodetree.rst:144
#: ../../../devel/decodetree.rst:177
msgid "Syntax::"
msgstr ""

#: ../../../devel/decodetree.rst:26
msgid ""
"field_def     := '%' identifier ( unnamed_field )* ( !"
"function=identifier )?\n"
"unnamed_field := number ':' ( 's' ) number"
msgstr ""

#: ../../../devel/decodetree.rst:29
msgid ""
"For *unnamed_field*, the first number is the least-significant bit position "
"of the field and the second number is the length of the field.  If the 's' "
"is present, the field is considered signed.  If multiple ``unnamed_fields`` "
"are present, they are concatenated.  In this way one can define disjoint "
"fields."
msgstr ""

#: ../../../devel/decodetree.rst:34
msgid ""
"If ``!function`` is specified, the concatenated result is passed through the "
"named function, taking and returning an integral value."
msgstr ""

#: ../../../devel/decodetree.rst:37
msgid ""
"One may use ``!function`` with zero ``unnamed_fields``.  This case is called "
"a *parameter*, and the named function is only passed the ``DisasContext`` "
"and returns an integral value extracted from there."
msgstr ""

#: ../../../devel/decodetree.rst:41
msgid "A field with no ``unnamed_fields`` and no ``!function`` is in error."
msgstr ""

#: ../../../devel/decodetree.rst:43
msgid "Field examples:"
msgstr ""

#: ../../../devel/decodetree.rst:46
msgid "Input"
msgstr ""

#: ../../../devel/decodetree.rst:46
msgid "Generated code"
msgstr ""

#: ../../../devel/decodetree.rst:48
msgid "%disp   0:s16"
msgstr ""

#: ../../../devel/decodetree.rst:48
msgid "sextract(i, 0, 16)"
msgstr ""

#: ../../../devel/decodetree.rst:50
msgid "%imm9   16:6 10:3"
msgstr ""

#: ../../../devel/decodetree.rst:50
msgid "extract(i, 16, 6) << 3 | extract(i, 10, 3)"
msgstr ""

#: ../../../devel/decodetree.rst:52
msgid "%disp12 0:s1 1:1 2:10"
msgstr ""

#: ../../../devel/decodetree.rst:52
msgid "sextract(i, 0, 1) << 11 |"
msgstr ""

#: ../../../devel/decodetree.rst:53
msgid "extract(i, 1, 1) << 10 | extract(i, 2, 10)"
msgstr ""

#: ../../../devel/decodetree.rst:56
msgid "%shimm8 5:s8 13:1"
msgstr ""

#: ../../../devel/decodetree.rst:57
msgid "!function=expand_shimm8"
msgstr ""

#: ../../../devel/decodetree.rst:56
msgid "expand_shimm8(sextract(i, 5, 8) << 1 |"
msgstr ""

#: ../../../devel/decodetree.rst:57
msgid "extract(i, 13, 1))"
msgstr ""

#: ../../../devel/decodetree.rst:61
msgid "Argument Sets"
msgstr ""

#: ../../../devel/decodetree.rst:65
msgid ""
"args_def    := '&' identifier ( args_elt )+ ( !extern )?\n"
"args_elt    := identifier (':' identifier)?"
msgstr ""

#: ../../../devel/decodetree.rst:68
msgid ""
"Each *args_elt* defines an argument within the argument set. If the form of "
"the *args_elt* contains a colon, the first identifier is the argument name "
"and the second identifier is the argument type.  If the colon is missing, "
"the argument type will be ``int``."
msgstr ""

#: ../../../devel/decodetree.rst:74
msgid ""
"Each argument set will be rendered as a C structure \"arg_$name\" with each "
"of the fields being one of the member arguments."
msgstr ""

#: ../../../devel/decodetree.rst:77
msgid ""
"If ``!extern`` is specified, the backing structure is assumed to have been "
"already declared, typically via a second decoder."
msgstr ""

#: ../../../devel/decodetree.rst:80
msgid ""
"Argument sets are useful when one wants to define helper functions for the "
"translator functions that can perform operations on a common set of "
"arguments.  This can ensure, for instance, that the ``AND`` pattern and the "
"``OR`` pattern put their operands into the same named structure, so that a "
"common ``gen_logic_insn`` may be able to handle the operations common "
"between the two."
msgstr ""

#: ../../../devel/decodetree.rst:87
msgid "Argument set examples::"
msgstr ""

#: ../../../devel/decodetree.rst:89
msgid ""
"&reg3       ra rb rc\n"
"&loadstore  reg base offset\n"
"&longldst   reg base offset:int64_t"
msgstr ""

#: ../../../devel/decodetree.rst:95
msgid "Formats"
msgstr ""

#: ../../../devel/decodetree.rst:99
msgid ""
"fmt_def      := '@' identifier ( fmt_elt )+\n"
"fmt_elt      := fixedbit_elt | field_elt | field_ref | args_ref\n"
"fixedbit_elt := [01.-]+\n"
"field_elt    := identifier ':' 's'? number\n"
"field_ref    := '%' identifier | identifier '=' '%' identifier\n"
"args_ref     := '&' identifier"
msgstr ""

#: ../../../devel/decodetree.rst:106
msgid ""
"Defining a format is a handy way to avoid replicating groups of fields "
"across many instruction patterns."
msgstr ""

#: ../../../devel/decodetree.rst:109
msgid ""
"A *fixedbit_elt* describes a contiguous sequence of bits that must be 1, 0, "
"or don't care.  The difference between '.' and '-' is that '.' means that "
"the bit will be covered with a field or a final 0 or 1 from the pattern, and "
"'-' means that the bit is really ignored by the cpu and will not be "
"specified."
msgstr ""

#: ../../../devel/decodetree.rst:115
msgid ""
"A *field_elt* describes a simple field only given a width; the position of "
"the field is implied by its position with respect to other *fixedbit_elt* "
"and *field_elt*."
msgstr ""

#: ../../../devel/decodetree.rst:119
msgid ""
"If any *fixedbit_elt* or *field_elt* appear, then all bits must be defined. "
"Padding with a *fixedbit_elt* of all '.' is an easy way to accomplish that."
msgstr ""

#: ../../../devel/decodetree.rst:122
msgid ""
"A *field_ref* incorporates a field by reference.  This is the only way to "
"add a complex field to a format.  A field may be renamed in the process via "
"assignment to another identifier.  This is intended to allow the same "
"argument set be used with disjoint named fields."
msgstr ""

#: ../../../devel/decodetree.rst:127
msgid ""
"A single *args_ref* may specify an argument set to use for the format. The "
"set of fields in the format must be a subset of the arguments in the "
"argument set.  If an argument set is not specified, one will be inferred "
"from the set of fields."
msgstr ""

#: ../../../devel/decodetree.rst:132
msgid ""
"It is recommended, but not required, that all *field_ref* and *args_ref* "
"appear at the end of the line, not interleaving with *fixedbit_elf* or "
"*field_elt*."
msgstr ""

#: ../../../devel/decodetree.rst:136
msgid "Format examples::"
msgstr ""

#: ../../../devel/decodetree.rst:138
msgid ""
"@opr    ...... ra:5 rb:5 ... 0 ....... rc:5\n"
"@opi    ...... ra:5 lit:8    1 ....... rc:5"
msgstr ""

#: ../../../devel/decodetree.rst:142
msgid "Patterns"
msgstr ""

#: ../../../devel/decodetree.rst:146
msgid ""
"pat_def      := identifier ( pat_elt )+\n"
"pat_elt      := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | "
"const_elt\n"
"fmt_ref      := '@' identifier\n"
"const_elt    := identifier '=' number"
msgstr ""

#: ../../../devel/decodetree.rst:151
msgid ""
"The *fixedbit_elt* and *field_elt* specifiers are unchanged from formats. A "
"pattern that does not specify a named format will have one inferred from a "
"referenced argument set (if present) and the set of fields."
msgstr ""

#: ../../../devel/decodetree.rst:155
msgid ""
"A *const_elt* allows a argument to be set to a constant value.  This may "
"come in handy when fields overlap between patterns and one has to include "
"the values in the *fixedbit_elt* instead."
msgstr ""

#: ../../../devel/decodetree.rst:159
msgid "The decoder will call a translator function for each pattern matched."
msgstr ""

#: ../../../devel/decodetree.rst:161
msgid "Pattern examples::"
msgstr ""

#: ../../../devel/decodetree.rst:163
msgid ""
"addl_r   010000 ..... ..... .... 0000000 ..... @opr\n"
"addl_i   010000 ..... ..... .... 0000000 ..... @opi"
msgstr ""

#: ../../../devel/decodetree.rst:166
msgid "which will, in part, invoke::"
msgstr ""

#: ../../../devel/decodetree.rst:168
msgid "trans_addl_r(ctx, &arg_opr, insn)"
msgstr ""

#: ../../../devel/decodetree.rst:170
msgid "and::"
msgstr ""

#: ../../../devel/decodetree.rst:172
msgid "trans_addl_i(ctx, &arg_opi, insn)"
msgstr ""

#: ../../../devel/decodetree.rst:175
msgid "Pattern Groups"
msgstr ""

#: ../../../devel/decodetree.rst:179
msgid ""
"group            := overlap_group | no_overlap_group\n"
"overlap_group    := '{' ( pat_def | group )+ '}'\n"
"no_overlap_group := '[' ( pat_def | group )+ ']'"
msgstr ""

#: ../../../devel/decodetree.rst:183
msgid ""
"A *group* begins with a lone open-brace or open-bracket, with all subsequent "
"lines indented two spaces, and ending with a lone close-brace or close-"
"bracket.  Groups may be nested, increasing the required indentation of the "
"lines within the nested group to two spaces per nesting level."
msgstr ""

#: ../../../devel/decodetree.rst:189
msgid ""
"Patterns within overlap groups are allowed to overlap.  Conflicts are "
"resolved by selecting the patterns in order.  If all of the fixedbits for a "
"pattern match, its translate function will be called.  If the translate "
"function returns false, then subsequent patterns within the group will be "
"matched."
msgstr ""

#: ../../../devel/decodetree.rst:195
msgid ""
"Patterns within no-overlap groups are not allowed to overlap, just the same "
"as ungrouped patterns.  Thus no-overlap groups are intended to be nested "
"inside overlap groups."
msgstr ""

#: ../../../devel/decodetree.rst:199
msgid ""
"The following example from PA-RISC shows specialization of the *or* "
"instruction::"
msgstr ""

#: ../../../devel/decodetree.rst:202
msgid ""
"{\n"
"  {\n"
"    nop   000010 ----- ----- 0000 001001 0 00000\n"
"    copy  000010 00000 r1:5  0000 001001 0 rt:5\n"
"  }\n"
"  or      000010 rt2:5 r1:5  cf:4 001001 0 rt:5\n"
"}"
msgstr ""

#: ../../../devel/decodetree.rst:210
msgid ""
"When the *cf* field is zero, the instruction has no side effects, and may be "
"specialized.  When the *rt* field is zero, the output is discarded and so "
"the instruction has no effect.  When the *rt2* field is zero, the operation "
"is ``reg[r1] | 0`` and so encodes the canonical register copy operation."
msgstr ""

#: ../../../devel/decodetree.rst:216
msgid "The output from the generator might look like::"
msgstr ""

#: ../../../devel/decodetree.rst:218
msgid ""
"switch (insn & 0xfc000fe0) {\n"
"case 0x08000240:\n"
"  /* 000010.. ........ ....0010 010..... */\n"
"  if ((insn & 0x0000f000) == 0x00000000) {\n"
"      /* 000010.. ........ 00000010 010..... */\n"
"      if ((insn & 0x0000001f) == 0x00000000) {\n"
"          /* 000010.. ........ 00000010 01000000 */\n"
"          extract_decode_Fmt_0(&u.f_decode0, insn);\n"
"          if (trans_nop(ctx, &u.f_decode0)) return true;\n"
"      }\n"
"      if ((insn & 0x03e00000) == 0x00000000) {\n"
"          /* 00001000 000..... 00000010 010..... */\n"
"          extract_decode_Fmt_1(&u.f_decode1, insn);\n"
"          if (trans_copy(ctx, &u.f_decode1)) return true;\n"
"      }\n"
"  }\n"
"  extract_decode_Fmt_2(&u.f_decode2, insn);\n"
"  if (trans_or(ctx, &u.f_decode2)) return true;\n"
"  return false;\n"
"}"
msgstr ""
