# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/replay.rst:7
msgid "Execution Record/Replay"
msgstr ""

#: ../../../devel/replay.rst:10
msgid "Core concepts"
msgstr ""

#: ../../../devel/replay.rst:12
msgid ""
"Record/replay functions are used for the deterministic replay of qemu "
"execution. Execution recording writes a non-deterministic events log, which "
"can be later used for replaying the execution anywhere and for unlimited "
"number of times. Execution replaying reads the log and replays all non-"
"deterministic events including external input, hardware clocks, and "
"interrupts."
msgstr ""

#: ../../../devel/replay.rst:19
msgid ""
"Several parts of QEMU include function calls to make event log recording and "
"replaying. Devices' models that have non-deterministic input from external "
"devices were changed to write every external event into the execution log "
"immediately. E.g. network packets are written into the log when they arrive "
"into the virtual network adapter."
msgstr ""

#: ../../../devel/replay.rst:26
msgid ""
"All non-deterministic events are coming from these devices. But to replay "
"them we need to know at which moments they occur. We specify these moments "
"by counting the number of instructions executed between every pair of "
"consecutive events."
msgstr ""

#: ../../../devel/replay.rst:31
msgid ""
"Academic papers with description of deterministic replay implementation:"
msgstr ""

#: ../../../devel/replay.rst:33
msgid ""
"`Deterministic Replay of System's Execution with Multi-target QEMU Simulator "
"for Dynamic Analysis and Reverse Debugging <https://www.computer.org/csdl/"
"proceedings/csmr/2012/4666/00/4666a553-abs.html>`_"
msgstr ""

#: ../../../devel/replay.rst:34
msgid ""
"`Don't panic: reverse debugging of kernel drivers <https://dl.acm.org/"
"citation.cfm?id=2786805.2803179>`_"
msgstr ""

#: ../../../devel/replay.rst:36
msgid "Modifications of qemu include:"
msgstr ""

#: ../../../devel/replay.rst:38
msgid ""
"wrappers for clock and time functions to save their return values in the log"
msgstr ""

#: ../../../devel/replay.rst:39
msgid ""
"saving different asynchronous events (e.g. system shutdown) into the log"
msgstr ""

#: ../../../devel/replay.rst:40
msgid "synchronization of the bottom halves execution"
msgstr ""

#: ../../../devel/replay.rst:41
msgid "synchronization of the threads from thread pool"
msgstr ""

#: ../../../devel/replay.rst:42
msgid "recording/replaying user input (mouse, keyboard, and microphone)"
msgstr ""

#: ../../../devel/replay.rst:43
msgid "adding internal checkpoints for cpu and io synchronization"
msgstr ""

#: ../../../devel/replay.rst:44
msgid "network filter for recording and replaying the packets"
msgstr ""

#: ../../../devel/replay.rst:45
msgid "block driver for making block layer deterministic"
msgstr ""

#: ../../../devel/replay.rst:46
msgid "serial port input record and replay"
msgstr ""

#: ../../../devel/replay.rst:47
msgid "recording of random numbers obtained from the external sources"
msgstr ""

#: ../../../devel/replay.rst:50
msgid "Instruction counting"
msgstr ""

#: ../../../devel/replay.rst:52
msgid ""
"QEMU should work in icount mode to use record/replay feature. icount was "
"designed to allow deterministic execution in absence of external inputs of "
"the virtual machine. We also use icount to control the occurrence of the non-"
"deterministic events. The number of instructions elapsed from the last event "
"is written to the log while recording the execution. In replay mode we can "
"predict when to inject that event using the instruction counter."
msgstr ""

#: ../../../devel/replay.rst:60
msgid "Locking and thread synchronisation"
msgstr ""

#: ../../../devel/replay.rst:62
msgid ""
"Previously the synchronisation of the main thread and the vCPU thread was "
"ensured by the holding of the BQL. However the trend has been to reduce the "
"time the BQL was held across the system including under TCG system "
"emulation. As it is important that batches of events are kept in sequence (e."
"g. expiring timers and checkpoints in the main thread while instruction "
"checkpoints are written by the vCPU thread) we need another lock to keep "
"things in lock-step. This role is now handled by the replay_mutex_lock. It "
"used to be held only for each event being written but now it is held for a "
"whole execution period. This results in a deterministic ping-pong between "
"the two main threads."
msgstr ""

#: ../../../devel/replay.rst:73
msgid ""
"As the BQL is now a finer grained lock than the replay_lock it is almost "
"certainly a bug, and a source of deadlocks, to take the replay_mutex_lock "
"while the BQL is held. This is enforced by an assert. While the unlocks are "
"usually in the reverse order, this is not necessary; you can drop the "
"replay_lock while holding the BQL, without doing a more complicated "
"unlock_iothread/replay_unlock/lock_iothread sequence."
msgstr ""

#: ../../../devel/replay.rst:82
msgid "Checkpoints"
msgstr ""

#: ../../../devel/replay.rst:84
msgid ""
"Replaying the execution of virtual machine is bound by sources of non-"
"determinism. These are inputs from clock and peripheral devices, and QEMU "
"thread scheduling. Thread scheduling affect on processing events from "
"timers, asynchronous input-output, and bottom halves."
msgstr ""

#: ../../../devel/replay.rst:89
msgid ""
"Invocations of timers are coupled with clock reads and changing the state of "
"the virtual machine. Reads produce non-deterministic data taken from host "
"clock. And VM state changes should preserve their order. Their relative "
"order in replay mode must replicate the order of callbacks in record mode. "
"To preserve this order we use checkpoints. When a specific clock is "
"processed in record mode we save to the log special \"checkpoint\" event. "
"Checkpoints here do not refer to virtual machine snapshots. They are just "
"record/replay events used for synchronization."
msgstr ""

#: ../../../devel/replay.rst:98
msgid ""
"QEMU in replay mode will try to invoke timers processing in random moment of "
"time. That's why we do not process a group of timers until the checkpoint "
"event will be read from the log. Such an event allows synchronizing CPU "
"execution and timer events."
msgstr ""

#: ../../../devel/replay.rst:103
msgid ""
"Two other checkpoints govern the \"warping\" of the virtual clock. While the "
"virtual machine is idle, the virtual clock increments at 1 ns per *real "
"time* nanosecond.  This is done by setting up a timer (called the warp "
"timer) on the virtual real time clock, so that the timer fires at the next "
"deadline of the virtual clock; the virtual clock is then incremented (which "
"is called \"warping\" the virtual clock) as soon as the timer fires or the "
"CPUs need to go out of the idle state. Two functions are used for this "
"purpose; because these actions change virtual machine state and must be "
"deterministic, each of them creates a checkpoint. "
"``icount_start_warp_timer`` checks if the CPUs are idle and if so starts "
"accounting real time to virtual clock. ``icount_account_warp_timer`` is "
"called when the CPUs get an interrupt or when the warp timer fires, and it "
"warps the virtual clock by the amount of real time that has passed since "
"``icount_start_warp_timer``."
msgstr ""

#: ../../../devel/replay.rst:119
msgid "Virtual devices"
msgstr ""

#: ../../../devel/replay.rst:121
msgid ""
"Record/replay mechanism, that could be enabled through icount mode, expects "
"the virtual devices to satisfy the following requirement: everything that "
"affects the guest state during execution in icount mode should be "
"deterministic."
msgstr ""

#: ../../../devel/replay.rst:127
msgid "Timers"
msgstr ""

#: ../../../devel/replay.rst:129
msgid ""
"Timers are used to execute callbacks from different subsystems of QEMU at "
"the specified moments of time. There are several kinds of timers:"
msgstr ""

#: ../../../devel/replay.rst:132
msgid ""
"Real time clock. Based on host time and used only for callbacks that do not "
"change the virtual machine state. For this reason real time clock and timers "
"does not affect deterministic replay at all."
msgstr ""

#: ../../../devel/replay.rst:135
msgid ""
"Virtual clock. These timers run only during the emulation. In icount mode "
"virtual clock value is calculated using executed instructions counter. That "
"is why it is completely deterministic and does not have to be recorded."
msgstr ""

#: ../../../devel/replay.rst:138
msgid ""
"Host clock. This clock is used by device models that simulate real time "
"sources (e.g. real time clock chip). Host clock is the one of the sources of "
"non-determinism. Host clock read operations should be logged to make the "
"execution deterministic."
msgstr ""

#: ../../../devel/replay.rst:142
msgid ""
"Virtual real time clock. This clock is similar to real time clock but it is "
"used only for increasing virtual clock while virtual machine is sleeping. "
"Due to its nature it is also non-deterministic as the host clock and has to "
"be logged too."
msgstr ""

#: ../../../devel/replay.rst:147
msgid ""
"All virtual devices should use virtual clock for timers that change the "
"guest state. Virtual clock is deterministic, therefore such timers are "
"deterministic too."
msgstr ""

#: ../../../devel/replay.rst:151
msgid ""
"Virtual devices can also use realtime clock for the events that do not "
"change the guest state directly. When the clock ticking should depend on VM "
"execution speed, use virtual clock with EXTERNAL attribute. It is not "
"deterministic, but its speed depends on the guest execution. This clock is "
"used by the virtual devices (e.g., slirp routing device) that lie outside "
"the replayed guest."
msgstr ""

#: ../../../devel/replay.rst:159
msgid "Block devices"
msgstr ""

#: ../../../devel/replay.rst:161
msgid ""
"Block devices record/replay module (``blkreplay``) intercepts calls of bdrv "
"coroutine functions at the top of block drivers stack."
msgstr ""

#: ../../../devel/replay.rst:164
msgid ""
"All block completion operations are added to the queue in the coroutines. "
"When the queue is flushed the information about processed requests is "
"recorded to the log. In replay phase the queue is matched with events read "
"from the log. Therefore block devices requests are processed "
"deterministically."
msgstr ""

#: ../../../devel/replay.rst:171
msgid "Bottom halves"
msgstr ""

#: ../../../devel/replay.rst:173
msgid ""
"Bottom half callbacks, that affect the guest state, should be invoked "
"through ``replay_bh_schedule_event`` or ``replay_bh_schedule_oneshot_event`` "
"functions. Their invocations are saved in record mode and synchronized with "
"the existing log in replay mode."
msgstr ""

#: ../../../devel/replay.rst:178
msgid ""
"Disk I/O events are completely deterministic in our model, because in both "
"record and replay modes we start virtual machine from the same disk state. "
"But callbacks that virtual disk controller uses for reading and writing the "
"disk may occur at different moments of time in record and replay modes."
msgstr ""

#: ../../../devel/replay.rst:184
msgid ""
"Reading and writing requests are created by CPU thread of QEMU. Later these "
"requests proceed to block layer which creates \"bottom halves\". Bottom "
"halves consist of callback and its parameters. They are processed when main "
"loop locks the global mutex. These locks are not synchronized with replaying "
"process because main loop also processes the events that do not affect the "
"virtual machine state (like user interaction with monitor)."
msgstr ""

#: ../../../devel/replay.rst:191
msgid ""
"That is why we had to implement saving and replaying bottom halves callbacks "
"synchronously to the CPU execution. When the callback is about to execute it "
"is added to the queue in the replay module. This queue is written to the log "
"when its callbacks are executed. In replay mode callbacks are not processed "
"until the corresponding event is read from the events log file."
msgstr ""

#: ../../../devel/replay.rst:197
msgid ""
"Sometimes the block layer uses asynchronous callbacks for its internal "
"purposes (like reading or writing VM snapshots or disk image cluster "
"tables). In this case bottom halves are not marked as \"replayable\" and do "
"not saved into the log."
msgstr ""

#: ../../../devel/replay.rst:203
msgid "Saving/restoring the VM state"
msgstr ""

#: ../../../devel/replay.rst:205
msgid ""
"All fields in the device state structure (including virtual timers) should "
"be restored by loadvm to the same values they had before savevm."
msgstr ""

#: ../../../devel/replay.rst:208
msgid ""
"Avoid accessing other devices' state, because the order of saving/restoring "
"is not defined. It means that you should not call functions like "
"``update_irq`` in ``post_load`` callback. Save everything explicitly to "
"avoid the dependencies that may make restoring the VM state non-"
"deterministic."
msgstr ""

#: ../../../devel/replay.rst:214
msgid "Stopping the VM"
msgstr ""

#: ../../../devel/replay.rst:216
msgid ""
"Stopping the guest should not interfere with its state (with the exception "
"of the network connections, that could be broken by the remote timeouts). VM "
"can be stopped at any moment of replay by the user. Restarting the VM after "
"that stop should not break the replay by the unneeded guest state change."
msgstr ""

#: ../../../devel/replay.rst:222
msgid "Replay log format"
msgstr ""

#: ../../../devel/replay.rst:224
msgid ""
"Record/replay log consists of the header and the sequence of execution "
"events. The header includes 4-byte replay version id and 8-byte reserved "
"field. Version is updated every time replay log format changes to prevent "
"using replay log created by another build of qemu."
msgstr ""

#: ../../../devel/replay.rst:229
msgid ""
"The sequence of the events describes virtual machine state changes. It "
"includes all non-deterministic inputs of VM, synchronization marks and "
"instruction counts used to correctly inject inputs at replay."
msgstr ""

#: ../../../devel/replay.rst:233
msgid ""
"Synchronization marks (checkpoints) are used for synchronizing qemu threads "
"that perform operations with virtual hardware. These operations may change "
"system's state (e.g., change some register or generate interrupt) and "
"therefore should execute synchronously with CPU thread."
msgstr ""

#: ../../../devel/replay.rst:238
msgid ""
"Every event in the log includes 1-byte event id and optional arguments. When "
"argument is an array, it is stored as 4-byte array length and corresponding "
"number of bytes with data. Here is the list of events that are written into "
"the log:"
msgstr ""

#: ../../../devel/replay.rst:243
msgid "EVENT_INSTRUCTION. Instructions executed since last event. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:245
msgid "4-byte number of executed instructions."
msgstr ""

#: ../../../devel/replay.rst:247
msgid "EVENT_INTERRUPT. Used to synchronize interrupt processing."
msgstr ""

#: ../../../devel/replay.rst:248
msgid "EVENT_EXCEPTION. Used to synchronize exception handling."
msgstr ""

#: ../../../devel/replay.rst:249
msgid ""
"EVENT_ASYNC. This is a group of events. When such an event is generated, it "
"is stored in the queue and processed in icount_account_warp_timer(). Every "
"such event has it's own id from the following list:"
msgstr ""

#: ../../../devel/replay.rst:253
msgid ""
"REPLAY_ASYNC_EVENT_BH. Bottom-half callback. This event synchronizes "
"callbacks that affect virtual machine state, but normally called "
"asynchronously. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:257 ../../../devel/replay.rst:275
msgid "8-byte operation id."
msgstr ""

#: ../../../devel/replay.rst:259
msgid ""
"REPLAY_ASYNC_EVENT_INPUT. Input device event. Contains parameters of "
"keyboard and mouse input operations (key press/release, mouse pointer "
"movement). Followed by:"
msgstr ""

#: ../../../devel/replay.rst:263
msgid "9-16 bytes depending of input event."
msgstr ""

#: ../../../devel/replay.rst:265
msgid "REPLAY_ASYNC_EVENT_INPUT_SYNC. Internal input synchronization event."
msgstr ""

#: ../../../devel/replay.rst:266
msgid ""
"REPLAY_ASYNC_EVENT_CHAR_READ. Character (e.g., serial port) device input "
"initiated by the sender. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:269
msgid "1-byte character device id."
msgstr ""

#: ../../../devel/replay.rst:270
msgid "Array with bytes were read."
msgstr ""

#: ../../../devel/replay.rst:272
msgid ""
"REPLAY_ASYNC_EVENT_BLOCK. Block device operation. Used to synchronize "
"operations with disk and flash drives with CPU. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:277
msgid "REPLAY_ASYNC_EVENT_NET. Incoming network packet. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:279
msgid "1-byte network adapter id."
msgstr ""

#: ../../../devel/replay.rst:280
msgid "4-byte packet flags."
msgstr ""

#: ../../../devel/replay.rst:281
msgid "Array with packet bytes."
msgstr ""

#: ../../../devel/replay.rst:283
msgid ""
"EVENT_SHUTDOWN. Occurs when user sends shutdown event to qemu, e.g., by "
"closing the window."
msgstr ""

#: ../../../devel/replay.rst:285
msgid ""
"EVENT_CHAR_WRITE. Used to synchronize character output operations. Followed "
"by:"
msgstr ""

#: ../../../devel/replay.rst:287
msgid "4-byte output function return value."
msgstr ""

#: ../../../devel/replay.rst:288
msgid "4-byte offset in the output array."
msgstr ""

#: ../../../devel/replay.rst:290
msgid ""
"EVENT_CHAR_READ_ALL. Used to synchronize character input operations, "
"initiated by qemu. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:293
msgid "Array with bytes that were read."
msgstr ""

#: ../../../devel/replay.rst:295
msgid ""
"EVENT_CHAR_READ_ALL_ERROR. Unsuccessful character input operation, initiated "
"by qemu. Followed by:"
msgstr ""

#: ../../../devel/replay.rst:298
msgid "4-byte error code."
msgstr ""

#: ../../../devel/replay.rst:300
msgid ""
"EVENT_CLOCK + clock_id. Group of events for host clock read operations. "
"Followed by:"
msgstr ""

#: ../../../devel/replay.rst:302
msgid "8-byte clock value."
msgstr ""

#: ../../../devel/replay.rst:304
msgid ""
"EVENT_CHECKPOINT + checkpoint_id. Checkpoint for synchronization of CPU, "
"internal threads, and asynchronous input events."
msgstr ""

#: ../../../devel/replay.rst:306
msgid "EVENT_END. Last event in the log."
msgstr ""
