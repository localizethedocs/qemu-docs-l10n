# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../system/devices/usb.rst:2
msgid "USB emulation"
msgstr ""

#: ../../../system/devices/usb.rst:4
msgid ""
"QEMU can emulate a PCI UHCI, OHCI, EHCI or XHCI USB controller. You can plug "
"virtual USB devices or real host USB devices (only works with certain host "
"operating systems). QEMU will automatically create and connect virtual USB "
"hubs as necessary to connect multiple USB devices."
msgstr ""

#: ../../../system/devices/usb.rst:10
msgid "USB controllers"
msgstr ""

#: ../../../system/devices/usb.rst:13
msgid "XHCI controller support"
msgstr ""

#: ../../../system/devices/usb.rst:15
msgid ""
"QEMU has XHCI host adapter support.  The XHCI hardware design is much more "
"virtualization-friendly when compared to EHCI and UHCI, thus XHCI emulation "
"uses less resources (especially CPU).  So if your guest supports XHCI (which "
"should be the case for any operating system released around 2010 or later) "
"we recommend using it:"
msgstr ""

#: ../../../system/devices/usb.rst:21
msgid "qemu -device qemu-xhci"
msgstr ""

#: ../../../system/devices/usb.rst:23
msgid ""
"XHCI supports USB 1.1, USB 2.0 and USB 3.0 devices, so this is the only "
"controller you need.  With only a single USB controller (and therefore only "
"a single USB bus) present in the system there is no need to use the bus= "
"parameter when adding USB devices."
msgstr ""

#: ../../../system/devices/usb.rst:30
msgid "EHCI controller support"
msgstr ""

#: ../../../system/devices/usb.rst:32
msgid ""
"The QEMU EHCI Adapter supports USB 2.0 devices.  It can be used either "
"standalone or with companion controllers (UHCI, OHCI) for USB 1.1 devices.  "
"The companion controller setup is more convenient to use because it provides "
"a single USB bus supporting both USB 2.0 and USB 1.1 devices.  See next "
"section for details."
msgstr ""

#: ../../../system/devices/usb.rst:38
msgid ""
"When running EHCI in standalone mode you can add UHCI or OHCI controllers "
"for USB 1.1 devices too.  Each controller creates its own bus though, so "
"there are two completely separate USB buses: One USB 1.1 bus driven by the "
"UHCI controller and one USB 2.0 bus driven by the EHCI controller.  Devices "
"must be attached to the correct controller manually."
msgstr ""

#: ../../../system/devices/usb.rst:45
msgid ""
"The easiest way to add a UHCI controller to a ``pc`` machine is the ``-usb`` "
"switch.  QEMU will create the UHCI controller as function of the PIIX3 "
"chipset.  The USB 1.1 bus will carry the name ``usb-bus.0``."
msgstr ""

#: ../../../system/devices/usb.rst:49
msgid ""
"You can use the standard ``-device`` switch to add a EHCI controller to your "
"virtual machine.  It is strongly recommended to specify an ID for the "
"controller so the USB 2.0 bus gets an individual name, for example ``-device "
"usb-ehci,id=ehci``.  This will give you a USB 2.0 bus named ``ehci.0``."
msgstr ""

#: ../../../system/devices/usb.rst:55
msgid ""
"When adding USB devices using the ``-device`` switch you can specify the bus "
"they should be attached to.  Here is a complete example:"
msgstr ""

#: ../../../system/devices/usb.rst:60
msgid ""
"|qemu_system| -M pc ${otheroptions}                        \\\\\n"
"    -drive if=none,id=usbstick,format=raw,file=/path/to/image   \\\\\n"
"    -usb                                                        \\\\\n"
"    -device usb-ehci,id=ehci                                    \\\\\n"
"    -device usb-tablet,bus=usb-bus.0                            \\\\\n"
"    -device usb-storage,bus=ehci.0,drive=usbstick"
msgstr ""

#: ../../../system/devices/usb.rst:67
msgid ""
"This attaches a USB tablet to the UHCI adapter and a USB mass storage device "
"to the EHCI adapter."
msgstr ""

#: ../../../system/devices/usb.rst:72
msgid "Companion controller support"
msgstr ""

#: ../../../system/devices/usb.rst:74
msgid ""
"The UHCI and OHCI controllers can attach to a USB bus created by EHCI as "
"companion controllers.  This is done by specifying the ``masterbus`` and "
"``firstport`` properties.  ``masterbus`` specifies the bus name the "
"controller should attach to.  ``firstport`` specifies the first port the "
"controller should attach to, which is needed as usually one EHCI controller "
"with six ports has three UHCI companion controllers with two ports each."
msgstr ""

#: ../../../system/devices/usb.rst:82
msgid ""
"There is a config file in docs which will do all this for you, which you can "
"use like this:"
msgstr ""

#: ../../../system/devices/usb.rst:87
msgid "|qemu_system| -readconfig docs/config/ich9-ehci-uhci.cfg"
msgstr ""

#: ../../../system/devices/usb.rst:89
msgid "Then use ``bus=ehci.0`` to assign your USB devices to that bus."
msgstr ""

#: ../../../system/devices/usb.rst:91
msgid ""
"Using the ``-usb`` switch for ``q35`` machines will create a similar USB "
"controller configuration."
msgstr ""

#: ../../../system/devices/usb.rst:98
msgid "Connecting USB devices"
msgstr ""

#: ../../../system/devices/usb.rst:100
msgid ""
"USB devices can be connected with the ``-device usb-...`` command line "
"option or the ``device_add`` monitor command. Available devices are:"
msgstr ""

#: ../../../system/devices/usb.rst:103
msgid "``usb-mouse``"
msgstr ""

#: ../../../system/devices/usb.rst:104
msgid ""
"Virtual Mouse. This will override the PS/2 mouse emulation when activated."
msgstr ""

#: ../../../system/devices/usb.rst:107
msgid "``usb-tablet``"
msgstr ""

#: ../../../system/devices/usb.rst:108
msgid ""
"Pointer device that uses absolute coordinates (like a touchscreen). This "
"means QEMU is able to report the mouse position without having to grab the "
"mouse. Also overrides the PS/2 mouse emulation when activated."
msgstr ""

#: ../../../system/devices/usb.rst:113
msgid "``usb-storage,drive=drive_id``"
msgstr ""

#: ../../../system/devices/usb.rst:114
msgid ""
"Mass storage device backed by drive_id (see the :ref:`disk images` chapter "
"in the System Emulation Users Guide). This is the classic bulk-only "
"transport protocol used by 99% of USB sticks. This example shows it "
"connected to an XHCI USB controller and with a drive backed by a raw format "
"disk image:"
msgstr ""

#: ../../../system/devices/usb.rst:122
msgid ""
"|qemu_system| [...]                                   \\\\\n"
" -drive if=none,id=stick,format=raw,file=/path/to/file.img \\\\\n"
" -device nec-usb-xhci,id=xhci                              \\\\\n"
" -device usb-storage,bus=xhci.0,drive=stick"
msgstr ""

#: ../../../system/devices/usb.rst:127
msgid "``usb-uas``"
msgstr ""

#: ../../../system/devices/usb.rst:128
msgid ""
"USB attached SCSI device. This does not create a SCSI disk, so you need to "
"explicitly create a ``scsi-hd`` or ``scsi-cd`` device on the command line, "
"as well as using the ``-drive`` option to specify what those disks are "
"backed by. One ``usb-uas`` device can handle multiple logical units (disks). "
"This example creates three logical units: two disks and one cdrom drive:"
msgstr ""

#: ../../../system/devices/usb.rst:137
msgid ""
"|qemu_system| [...]                                         \\\\\n"
" -drive if=none,id=uas-disk1,format=raw,file=/path/to/file1.img  \\\\\n"
" -drive if=none,id=uas-disk2,format=raw,file=/path/to/file2.img  \\\\\n"
" -drive if=none,id=uas-cdrom,media=cdrom,format=raw,file=/path/to/image.iso "
"\\\\\n"
" -device nec-usb-xhci,id=xhci                                    \\\\\n"
" -device usb-uas,id=uas,bus=xhci.0                               \\\\\n"
" -device scsi-hd,bus=uas.0,scsi-id=0,lun=0,drive=uas-disk1       \\\\\n"
" -device scsi-hd,bus=uas.0,scsi-id=0,lun=1,drive=uas-disk2       \\\\\n"
" -device scsi-cd,bus=uas.0,scsi-id=0,lun=5,drive=uas-cdrom"
msgstr ""

#: ../../../system/devices/usb.rst:147
msgid "``usb-bot``"
msgstr ""

#: ../../../system/devices/usb.rst:148
msgid ""
"Bulk-only transport storage device. This presents the guest with the same "
"USB bulk-only transport protocol interface as ``usb-storage``, but the QEMU "
"command line option works like ``usb-uas`` and does not automatically create "
"SCSI disks for you. ``usb-bot`` supports up to 16 LUNs. Unlike ``usb-uas``, "
"the LUN numbers must be continuous, i.e. for three devices you must use "
"0+1+2. The 0+1+5 numbering from the ``usb-uas`` example above won't work "
"with ``usb-bot``."
msgstr ""

#: ../../../system/devices/usb.rst:156
msgid "``usb-mtp,rootdir=dir``"
msgstr ""

#: ../../../system/devices/usb.rst:157
msgid ""
"Media transfer protocol device, using dir as root of the file tree that is "
"presented to the guest."
msgstr ""

#: ../../../system/devices/usb.rst:160
msgid "``usb-host,hostbus=bus,hostaddr=addr``"
msgstr ""

#: ../../../system/devices/usb.rst:161
msgid "Pass through the host device identified by bus and addr"
msgstr ""

#: ../../../system/devices/usb.rst:163
msgid "``usb-host,vendorid=vendor,productid=product``"
msgstr ""

#: ../../../system/devices/usb.rst:164
msgid "Pass through the host device identified by vendor and product ID"
msgstr ""

#: ../../../system/devices/usb.rst:166
msgid "``usb-wacom-tablet``"
msgstr ""

#: ../../../system/devices/usb.rst:167
msgid ""
"Virtual Wacom PenPartner tablet. This device is similar to the ``tablet`` "
"above but it can be used with the tslib library because in addition to touch "
"coordinates it reports touch pressure."
msgstr ""

#: ../../../system/devices/usb.rst:171
msgid "``usb-kbd``"
msgstr ""

#: ../../../system/devices/usb.rst:172
msgid "Standard USB keyboard. Will override the PS/2 keyboard (if present)."
msgstr ""

#: ../../../system/devices/usb.rst:174
msgid "``usb-serial,chardev=id``"
msgstr ""

#: ../../../system/devices/usb.rst:175
msgid ""
"Serial converter. This emulates an FTDI FT232BM chip connected to host "
"character device id."
msgstr ""

#: ../../../system/devices/usb.rst:178
msgid "``usb-braille,chardev=id``"
msgstr ""

#: ../../../system/devices/usb.rst:179
msgid ""
"Braille device. This emulates a Baum Braille device USB port. id has to "
"specify a character device defined with ``-chardev …,id=id``.  One will "
"normally use BrlAPI to display the braille output on a BRLTTY-supported "
"device with"
msgstr ""

#: ../../../system/devices/usb.rst:186
msgid ""
"|qemu_system| [...] -chardev braille,id=brl -device usb-braille,chardev=brl"
msgstr ""

#: ../../../system/devices/usb.rst:188
msgid "or alternatively, use the following equivalent shortcut:"
msgstr ""

#: ../../../system/devices/usb.rst:192
msgid "|qemu_system| [...] -usbdevice braille"
msgstr ""

#: ../../../system/devices/usb.rst:194
msgid "``usb-net[,netdev=id]``"
msgstr ""

#: ../../../system/devices/usb.rst:195
msgid ""
"Network adapter that supports CDC ethernet and RNDIS protocols. id specifies "
"a netdev defined with ``-netdev …,id=id``. For instance, user-mode "
"networking can be used with"
msgstr ""

#: ../../../system/devices/usb.rst:201
msgid "|qemu_system| [...] -netdev user,id=net0 -device usb-net,netdev=net0"
msgstr ""

#: ../../../system/devices/usb.rst:203
msgid "``usb-ccid``"
msgstr ""

#: ../../../system/devices/usb.rst:204
msgid "Smartcard reader device"
msgstr ""

#: ../../../system/devices/usb.rst:206
msgid "``usb-audio``"
msgstr ""

#: ../../../system/devices/usb.rst:207
msgid "USB audio device"
msgstr ""

#: ../../../system/devices/usb.rst:209
msgid "``u2f-{emulated,passthru}``"
msgstr ""

#: ../../../system/devices/usb.rst:210
msgid ":doc:`usb-u2f`"
msgstr ""

#: ../../../system/devices/usb.rst:212
msgid "``canokey``"
msgstr ""

#: ../../../system/devices/usb.rst:213
msgid ""
"An Open-source Secure Key implementing FIDO2, OpenPGP, PIV and more. For "
"more information, see :ref:`canokey`."
msgstr ""

#: ../../../system/devices/usb.rst:217
msgid "Physical port addressing"
msgstr ""

#: ../../../system/devices/usb.rst:219
msgid ""
"For all the above USB devices, by default QEMU will plug the device into the "
"next available port on the specified USB bus, or onto some available USB bus "
"if you didn't specify one explicitly. If you need to, you can also specify "
"the physical port where the device will show up in the guest.  This can be "
"done using the ``port`` property.  UHCI has two root ports (1,2).  EHCI has "
"six root ports (1-6), and the emulated (1.1) USB hub has eight ports."
msgstr ""

#: ../../../system/devices/usb.rst:227
msgid "Plugging a tablet into UHCI port 1 works like this::"
msgstr ""

#: ../../../system/devices/usb.rst:229
msgid "-device usb-tablet,bus=usb-bus.0,port=1"
msgstr ""

#: ../../../system/devices/usb.rst:231
msgid "Plugging a hub into UHCI port 2 works like this::"
msgstr ""

#: ../../../system/devices/usb.rst:233
msgid "-device usb-hub,bus=usb-bus.0,port=2"
msgstr ""

#: ../../../system/devices/usb.rst:235
msgid ""
"Plugging a virtual USB stick into port 4 of the hub just plugged works this "
"way::"
msgstr ""

#: ../../../system/devices/usb.rst:238
msgid "-device usb-storage,bus=usb-bus.0,port=2.4,drive=..."
msgstr ""

#: ../../../system/devices/usb.rst:240
msgid ""
"In the monitor, the ``device_add` command also accepts a ``port`` property "
"specification. If you want to unplug devices too you should specify some "
"unique id which you can use to refer to the device. You can then use "
"``device_del`` to unplug the device later. For example::"
msgstr ""

#: ../../../system/devices/usb.rst:246
msgid ""
"(qemu) device_add usb-tablet,bus=usb-bus.0,port=1,id=my-tablet\n"
"(qemu) device_del my-tablet"
msgstr ""

#: ../../../system/devices/usb.rst:250
msgid "Hotplugging USB storage"
msgstr ""

#: ../../../system/devices/usb.rst:252
msgid ""
"The ``usb-bot`` and ``usb-uas`` devices can be hotplugged.  In the hotplug "
"case they are added with ``attached = false`` so the guest will not see the "
"device until the ``attached`` property is explicitly set to true. That "
"allows you to attach one or more scsi devices before making the device "
"visible to the guest. The workflow looks like this:"
msgstr ""

#: ../../../system/devices/usb.rst:258
msgid "``device-add usb-bot,id=foo``"
msgstr ""

#: ../../../system/devices/usb.rst:259
msgid "``device-add scsi-{hd,cd},bus=foo.0,lun=0``"
msgstr ""

#: ../../../system/devices/usb.rst:260
msgid "optionally add more devices (luns 1 ... 15)"
msgstr ""

#: ../../../system/devices/usb.rst:261
msgid "``scripts/qmp/qom-set foo.attached = true``"
msgstr ""

#: ../../../system/devices/usb.rst:266
msgid "Using host USB devices on a Linux host"
msgstr ""

#: ../../../system/devices/usb.rst:268
msgid ""
"WARNING: this is an experimental feature. QEMU will slow down when using it. "
"USB devices requiring real time streaming (i.e. USB Video Cameras) are not "
"supported yet."
msgstr ""

#: ../../../system/devices/usb.rst:272
msgid ""
"If you use an early Linux 2.4 kernel, verify that no Linux driver is "
"actually using the USB device. A simple way to do that is simply to disable "
"the corresponding kernel module by renaming it from ``mydriver.o`` to "
"``mydriver.o.disabled``."
msgstr ""

#: ../../../system/devices/usb.rst:277
msgid ""
"Verify that ``/proc/bus/usb`` is working (most Linux distributions should "
"enable it by default). You should see something like that:"
msgstr ""

#: ../../../system/devices/usb.rst:282
msgid ""
"ls /proc/bus/usb\n"
"001  devices  drivers"
msgstr ""

#: ../../../system/devices/usb.rst:285
msgid ""
"Since only root can access to the USB devices directly, you can either "
"launch QEMU as root or change the permissions of the USB devices you want to "
"use. For testing, the following suffices:"
msgstr ""

#: ../../../system/devices/usb.rst:291
msgid "chown -R myuid /proc/bus/usb"
msgstr ""

#: ../../../system/devices/usb.rst:293
msgid "Launch QEMU and do in the monitor:"
msgstr ""

#: ../../../system/devices/usb.rst:297
msgid ""
"info usbhost\n"
"  Device 1.2, speed 480 Mb/s\n"
"    Class 00: USB device 1234:5678, USB DISK"
msgstr ""

#: ../../../system/devices/usb.rst:301
msgid ""
"You should see the list of the devices you can use (Never try to use hubs, "
"it won't work)."
msgstr ""

#: ../../../system/devices/usb.rst:304
msgid "Add the device in QEMU by using:"
msgstr ""

#: ../../../system/devices/usb.rst:308
msgid "device_add usb-host,vendorid=0x1234,productid=0x5678"
msgstr ""

#: ../../../system/devices/usb.rst:310
msgid ""
"Normally the guest OS should report that a new USB device is plugged. You "
"can use the option ``-device usb-host,...`` to do the same."
msgstr ""

#: ../../../system/devices/usb.rst:313
msgid "Now you can try to use the host USB device in QEMU."
msgstr ""

#: ../../../system/devices/usb.rst:315
msgid ""
"When relaunching QEMU, you may have to unplug and plug again the USB device "
"to make it work again (this is a bug)."
msgstr ""

#: ../../../system/devices/usb.rst:319
msgid "``usb-host`` properties for specifying the host device"
msgstr ""

#: ../../../system/devices/usb.rst:321
msgid ""
"The example above uses the ``vendorid`` and ``productid`` to specify which "
"host device to pass through, but this is not the only way to specify the "
"host device. ``usb-host`` supports the following properties:"
msgstr ""

#: ../../../system/devices/usb.rst:326
msgid "``hostbus=<nr>``"
msgstr ""

#: ../../../system/devices/usb.rst:327
msgid "Specifies the bus number the device must be attached to"
msgstr ""

#: ../../../system/devices/usb.rst:328
msgid "``hostaddr=<nr>``"
msgstr ""

#: ../../../system/devices/usb.rst:329
msgid "Specifies the device address the device got assigned by the guest os"
msgstr ""

#: ../../../system/devices/usb.rst:330
msgid "``hostport=<str>``"
msgstr ""

#: ../../../system/devices/usb.rst:331
msgid "Specifies the physical port the device is attached to"
msgstr ""

#: ../../../system/devices/usb.rst:332
msgid "``vendorid=<hexnr>``"
msgstr ""

#: ../../../system/devices/usb.rst:333
msgid "Specifies the vendor ID of the device"
msgstr ""

#: ../../../system/devices/usb.rst:334
msgid "``productid=<hexnr>``"
msgstr ""

#: ../../../system/devices/usb.rst:335
msgid "Specifies the product ID of the device."
msgstr ""

#: ../../../system/devices/usb.rst:337
msgid ""
"In theory you can combine all these properties as you like.  In practice "
"only a few combinations are useful:"
msgstr ""

#: ../../../system/devices/usb.rst:340
msgid ""
"``vendorid`` and ``productid`` -- match for a specific device, pass it to "
"the guest when it shows up somewhere in the host."
msgstr ""

#: ../../../system/devices/usb.rst:343
msgid ""
"``hostbus`` and ``hostport`` -- match for a specific physical port in the "
"host, any device which is plugged in there gets passed to the guest."
msgstr ""

#: ../../../system/devices/usb.rst:347
msgid ""
"``hostbus`` and ``hostaddr`` -- most useful for ad-hoc pass through as the "
"hostaddr isn't stable. The next time you plug the device into the host it "
"will get a new hostaddr."
msgstr ""

#: ../../../system/devices/usb.rst:351
msgid ""
"Note that on the host USB 1.1 devices are handled by UHCI/OHCI and USB 2.0 "
"by EHCI.  That means different USB devices plugged into the very same "
"physical port on the host may show up on different host buses depending on "
"the speed. Supposing that devices plugged into a given physical port appear "
"as bus 1 + port 1 for 2.0 devices and bus 3 + port 1 for 1.1 devices, you "
"can pass through any device plugged into that port and also assign it to the "
"correct USB bus in QEMU like this:"
msgstr ""

#: ../../../system/devices/usb.rst:361
msgid ""
"|qemu_system| -M pc [...]                            \\\\\n"
"     -usb                                                 \\\\\n"
"     -device usb-ehci,id=ehci                             \\\\\n"
"     -device usb-host,bus=usb-bus.0,hostbus=3,hostport=1  \\\\\n"
"     -device usb-host,bus=ehci.0,hostbus=1,hostport=1"
msgstr ""

#: ../../../system/devices/usb.rst:368
msgid "``usb-host`` properties for reset behavior"
msgstr ""

#: ../../../system/devices/usb.rst:370
msgid ""
"The ``guest-reset`` and ``guest-reset-all`` properties control whenever the "
"guest is allowed to reset the physical usb device on the host.  There are "
"three cases:"
msgstr ""

#: ../../../system/devices/usb.rst:374
msgid "``guest-reset=false``"
msgstr ""

#: ../../../system/devices/usb.rst:375
msgid "The guest is not allowed to reset the (physical) usb device."
msgstr ""

#: ../../../system/devices/usb.rst:377
msgid "``guest-reset=true,guest-resets-all=false``"
msgstr ""

#: ../../../system/devices/usb.rst:378
msgid ""
"The guest is allowed to reset the device when it is not yet initialized (aka "
"no usb bus address assigned).  Usually this results in one guest reset being "
"allowed.  This is the default behavior."
msgstr ""

#: ../../../system/devices/usb.rst:382
msgid "``guest-reset=true,guest-resets-all=true``"
msgstr ""

#: ../../../system/devices/usb.rst:383
msgid "The guest is allowed to reset the device as it pleases."
msgstr ""

#: ../../../system/devices/usb.rst:385
msgid ""
"The reason for this existing are broken usb devices.  In theory one should "
"be able to reset (and re-initialize) usb devices at any time. In practice "
"that may result in shitty usb device firmware crashing and the device not "
"responding any more until you power-cycle (aka un-plug and re-plug) it."
msgstr ""

#: ../../../system/devices/usb.rst:391
msgid ""
"What works best pretty much depends on the behavior of the specific usb "
"device at hand, so it's a trial-and-error game.  If the default doesn't "
"work, try another option and see whenever the situation improves."
msgstr ""

#: ../../../system/devices/usb.rst:397
msgid "record usb transfers"
msgstr ""

#: ../../../system/devices/usb.rst:399
msgid ""
"All usb devices have support for recording the usb traffic.  This can be "
"enabled using the ``pcap=<file>`` property, for example:"
msgstr ""

#: ../../../system/devices/usb.rst:402
msgid "``-device usb-mouse,pcap=mouse.pcap``"
msgstr ""

#: ../../../system/devices/usb.rst:404
msgid ""
"The pcap files are compatible with the linux kernels usbmon.  Many tools, "
"including ``wireshark``, can decode and inspect these trace files."
msgstr ""
