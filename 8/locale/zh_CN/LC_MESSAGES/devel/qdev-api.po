# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/qdev-api.rst:5
msgid "QEMU Device (qdev) API Reference"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1
msgid "**The QEMU Device API**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:15
msgid ""
"All modern devices should represented as a derived QOM class of TYPE_DEVICE. "
"The device API introduces the additional methods of **realize** and "
"**unrealize** to represent additional stages in a device objects life cycle."
msgstr ""

#: ../../../../include/hw/qdev-core.h:23
msgid "Devices are constructed in two stages:"
msgstr ""

#: ../../../../include/hw/qdev-core.h:25
msgid "object instantiation via object_initialize() and"
msgstr ""

#: ../../../../include/hw/qdev-core.h:26
msgid ""
"device realization via the :c:type:`DeviceState.realized <DeviceState>` "
"property"
msgstr ""

#: ../../../../include/hw/qdev-core.h:28
msgid ""
"The former may not fail (and must not abort or exit, since it is called "
"during device introspection already), and the latter may return error "
"information to the caller and must be re-entrant. Trivial field "
"initializations should go into :c:type:`TypeInfo.instance_init <TypeInfo>`. "
"Operations depending on **props** static properties should go into "
"**realize**. After successful realization, setting static properties will "
"fail."
msgstr ""

#: ../../../../include/hw/qdev-core.h:35
msgid ""
"As an interim step, the :c:type:`DeviceState.realized <DeviceState>` "
"property can also be set with qdev_realize(). In the future, devices will "
"propagate this state change to their children and along busses they expose. "
"The point in time will be deferred to machine creation, so that values set "
"in **realize** will not be introspectable beforehand. Therefore devices must "
"not create children during **realize**; they should initialize them via "
"object_initialize() in their own :c:type:`TypeInfo.instance_init <TypeInfo>` "
"and forward the realization events appropriately."
msgstr ""

#: ../../../../include/hw/qdev-core.h:45
msgid ""
"Any type may override the **realize** and/or **unrealize** callbacks but "
"needs to call the parent type's implementation if keeping their "
"functionality is desired. Refer to QOM documentation for further discussion "
"and examples."
msgstr ""

#: ../../../../include/hw/qdev-core.h:50
msgid ""
"Since TYPE_DEVICE doesn't implement **realize** and **unrealize**, types "
"derived directly from it need not call their parent's **realize** and "
"**unrealize**. For other types consult the documentation and implementation "
"of the respective parent types."
msgstr ""

#: ../../../../include/hw/qdev-core.h:58
msgid ""
"To hide a device, a DeviceListener function hide_device() needs to be "
"registered. It can be used to defer adding a device and therefore hide it "
"from the guest. The handler registering to this DeviceListener can save the "
"QOpts passed to it for re-using it later. It must return if it wants the "
"device to be hidden or visible. When the handler function decides the device "
"shall be visible it will be added with qdev_device_add() and realized as any "
"other device. Otherwise qdev_device_add() will return early without adding "
"the device. The guest will not see a \"hidden\" device until it was marked "
"visible and qdev_device_add called again."
msgstr ""

#: ../../../../include/hw/qdev-core.h:100
msgid "The base class for all devices."
msgstr ""

#: ../../../../include/hw/qdev-core.h:102
#: ../../../../include/hw/qdev-core.h:212
#: ../../../../include/hw/qdev-core.h:365
msgid "**Definition**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:106
msgid ""
"struct DeviceClass {\n"
"  unsigned long categories[BITS_TO_LONGS(DEVICE_CATEGORY_MAX)];\n"
"  const char *fw_name;\n"
"  const char *desc;\n"
"  Property *props_;\n"
"  bool user_creatable;\n"
"  bool hotpluggable;\n"
"  DeviceReset reset;\n"
"  DeviceRealize realize;\n"
"  DeviceUnrealize unrealize;\n"
"  const VMStateDescription *vmsd;\n"
"  const char *bus_type;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:120
#: ../../../../include/hw/qdev-core.h:237
#: ../../../../include/hw/qdev-core.h:382
msgid "**Members**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:117
msgid "``categories``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:118
msgid "device categories device belongs to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:121
msgid "``fw_name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:122
msgid "name used to identify device to firmware interfaces"
msgstr ""

#: ../../../../include/hw/qdev-core.h:125
msgid "``desc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:126
msgid "human readable description of device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:130
msgid "``props_``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:131
msgid ""
"properties associated with device, should only be assigned by using "
"device_class_set_props(). The underscore ensures a compile-time error if "
"someone attempts to assign dc->props directly."
msgstr ""

#: ../../../../include/hw/qdev-core.h:138
msgid "``user_creatable``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:139
msgid "Can user instantiate with -device / device_add?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:141
msgid ""
"All devices should support instantiation with device_add, and this flag "
"should not exist.  But we're not there, yet.  Some devices fail to "
"instantiate with cryptic error messages. Others instantiate, but don't "
"work.  Exposing users to such behavior would be cruel; clearing this flag "
"will protect them. It should never be cleared without a comment explaining "
"why it is cleared."
msgstr ""

#: ../../../../include/hw/qdev-core.h:149
msgid "TODO remove once we're there"
msgstr ""

#: ../../../../include/hw/qdev-core.h:106
msgid "``hotpluggable``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:107
msgid ""
"indicates if :c:type:`DeviceClass <DeviceClass>` is hotpluggable, available "
"as readonly \"hotpluggable\" property of :c:type:`DeviceState <DeviceState>` "
"instance"
msgstr ""

#: ../../../../include/hw/qdev-core.h:155
#: ../../../../include/hw/qdev-core.h:282
#: ../../../../include/hw/qdev-core.h:396
msgid "``reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:156
msgid "deprecated device reset method pointer"
msgstr ""

#: ../../../../include/hw/qdev-core.h:158
msgid ""
"Modern code should use the ResettableClass interface to implement a multi-"
"phase reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:161
msgid "TODO: remove once every reset callback is unused"
msgstr ""

#: ../../../../include/hw/qdev-core.h:102
msgid "``realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:103
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``true``."
msgstr ""

#: ../../../../include/hw/qdev-core.h:104
msgid "``unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:105
msgid ""
"Callback function invoked when the :c:type:`DeviceState <DeviceState>`:"
"realized property is changed to ``false``."
msgstr ""

#: ../../../../include/hw/qdev-core.h:167
msgid "``vmsd``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:168
msgid "device state serialisation description for migration/save/restore"
msgstr ""

#: ../../../../include/hw/qdev-core.h:173
msgid "``bus_type``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:174
msgid "bus type private: to qdev / bus."
msgstr ""

#: ../../../../include/hw/qdev-core.h:210
msgid "common device state, accessed with qdev helpers"
msgstr ""

#: ../../../../include/hw/qdev-core.h:216
msgid ""
"struct DeviceState {\n"
"  char *id;\n"
"  char *canonical_path;\n"
"  bool realized;\n"
"  bool pending_deleted_event;\n"
"  int64_t pending_deleted_expires_ms;\n"
"  QDict *opts;\n"
"  int hotplugged;\n"
"  bool allow_unplug_during_migration;\n"
"  BusState *parent_bus;\n"
"  NamedGPIOListHead gpios;\n"
"  NamedClockListHead clocks;\n"
"  BusStateHead child_bus;\n"
"  int num_child_bus;\n"
"  int instance_id_alias;\n"
"  int alias_required_for_version;\n"
"  ResettableState reset;\n"
"  GSList *unplug_blockers;\n"
"  MemReentrancyGuard mem_reentrancy_guard;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:221
msgid "``id``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:222
msgid "global device id"
msgstr ""

#: ../../../../include/hw/qdev-core.h:225
msgid "``canonical_path``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:226
msgid "canonical path of realized device in the QOM tree"
msgstr ""

#: ../../../../include/hw/qdev-core.h:229
#: ../../../../include/hw/qdev-core.h:370
msgid "``realized``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:230
msgid "has device been realized?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:233
msgid "``pending_deleted_event``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:234
msgid "track pending deletion events during unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:237
msgid "``pending_deleted_expires_ms``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:238
msgid "optional timeout for deletion events"
msgstr ""

#: ../../../../include/hw/qdev-core.h:241
msgid "``opts``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:242
msgid "QDict of options for the device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:245
msgid "``hotplugged``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:246
msgid "was device added after PHASE_MACHINE_READY?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:249
msgid "``allow_unplug_during_migration``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:250
msgid "can device be unplugged during migration"
msgstr ""

#: ../../../../include/hw/qdev-core.h:253
msgid "``parent_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:254
msgid "bus this device belongs to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:257
msgid "``gpios``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:258
msgid "QLIST of named GPIOs the device provides."
msgstr ""

#: ../../../../include/hw/qdev-core.h:261
msgid "``clocks``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:262
msgid "QLIST of named clocks the device provides."
msgstr ""

#: ../../../../include/hw/qdev-core.h:265
msgid "``child_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:266
msgid "QLIST of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:269
msgid "``num_child_bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:270
msgid "number of **child_bus** entries"
msgstr ""

#: ../../../../include/hw/qdev-core.h:273
msgid "``instance_id_alias``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:274
msgid "device alias for handling legacy migration setups"
msgstr ""

#: ../../../../include/hw/qdev-core.h:277
msgid "``alias_required_for_version``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:278
msgid "indicates **instance_id_alias** is needed for migration"
msgstr ""

#: ../../../../include/hw/qdev-core.h:283
msgid "ResettableState for the device; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/qdev-core.h:286
msgid "``unplug_blockers``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:287
msgid "list of reasons to block unplugging of device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:290
msgid "``mem_reentrancy_guard``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:291
msgid "Is the device currently in mmio/pio/dma?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:293
msgid "Used to prevent re-entrancy confusing things."
msgstr ""

#: ../../../../include/hw/qdev-core.h:296
#: ../../../../include/hw/qdev-core.h:404
#: ../../../../include/hw/qdev-core.h:434
#: ../../../../include/hw/qdev-core.h:446
#: ../../../../include/hw/qdev-core.h:472
#: ../../../../include/hw/qdev-core.h:491
#: ../../../../include/hw/qdev-core.h:517
#: ../../../../include/hw/qdev-core.h:587
#: ../../../../include/hw/qdev-core.h:605
#: ../../../../include/hw/qdev-core.h:628
#: ../../../../include/hw/qdev-core.h:647
#: ../../../../include/hw/qdev-core.h:680
#: ../../../../include/hw/qdev-core.h:707
#: ../../../../include/hw/qdev-core.h:728
#: ../../../../include/hw/qdev-core.h:753
#: ../../../../include/hw/qdev-core.h:772
#: ../../../../include/hw/qdev-core.h:802
#: ../../../../include/hw/qdev-core.h:829
#: ../../../../include/hw/qdev-core.h:845
#: ../../../../include/hw/qdev-core.h:893
#: ../../../../include/hw/qdev-core.h:902
#: ../../../../include/hw/qdev-core.h:934
#: ../../../../include/hw/qdev-core.h:946
#: ../../../../include/hw/qdev-core.h:962
#: ../../../../include/hw/qdev-core.h:979
#: ../../../../include/hw/qdev-core.h:1026
#: ../../../../include/hw/qdev-core.h:1055
msgid "**Description**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:212
msgid ""
"This structure should not be accessed directly.  We declare it here so that "
"it can be embedded in individual device state structures."
msgstr ""

#: ../../../../include/hw/qdev-core.h:369
msgid ""
"struct BusState {\n"
"  DeviceState *parent;\n"
"  char *name;\n"
"  HotplugHandler *hotplug_handler;\n"
"  int max_index;\n"
"  bool realized;\n"
"  bool full;\n"
"  int num_children;\n"
"  BusChildHead children;\n"
"  BusStateEntry sibling;\n"
"  ResettableState reset;\n"
"};"
msgstr ""

#: ../../../../include/hw/qdev-core.h:366
msgid "``parent``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:367
msgid "parent Device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:367
msgid "``name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:368
msgid "name of bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:368
msgid "``hotplug_handler``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:369
msgid "link to a hotplug handler associated with bus."
msgstr ""

#: ../../../../include/hw/qdev-core.h:369
msgid "``max_index``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:370
msgid "max number of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:371
msgid "is the bus itself realized?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:371
msgid "``full``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:372
msgid "is the bus full?"
msgstr ""

#: ../../../../include/hw/qdev-core.h:372
msgid "``num_children``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:373
msgid "current number of child buses"
msgstr ""

#: ../../../../include/hw/qdev-core.h:387
msgid "``children``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:388
msgid ""
"an RCU protected QTAILQ, thus readers must use RCU to access it, and writers "
"must hold the big qemu lock"
msgstr ""

#: ../../../../include/hw/qdev-core.h:392
msgid "``sibling``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:393
msgid "next bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:397
msgid "ResettableState for the bus; handled by Resettable interface."
msgstr ""

#: ../../../../include/hw/qdev-core.h:402
msgid "a global property type"
msgstr ""

#: ../../../../include/hw/qdev-core.h:408
msgid ""
"An error is fatal for non-hotplugged devices, when the global is applied."
msgstr ""

#: ../../../../include/hw/qdev-core.h:431
msgid "Create a device on the heap"
msgstr ""

#: ../../../../include/hw/qdev-core.h:433
#: ../../../../include/hw/qdev-core.h:445
#: ../../../../include/hw/qdev-core.h:457
#: ../../../../include/hw/qdev-core.h:469
#: ../../../../include/hw/qdev-core.h:488
#: ../../../../include/hw/qdev-core.h:516
#: ../../../../include/hw/qdev-core.h:542
#: ../../../../include/hw/qdev-core.h:559
#: ../../../../include/hw/qdev-core.h:567
#: ../../../../include/hw/qdev-core.h:576
#: ../../../../include/hw/qdev-core.h:603
#: ../../../../include/hw/qdev-core.h:625
#: ../../../../include/hw/qdev-core.h:644
#: ../../../../include/hw/qdev-core.h:675
#: ../../../../include/hw/qdev-core.h:704
#: ../../../../include/hw/qdev-core.h:724
#: ../../../../include/hw/qdev-core.h:750
#: ../../../../include/hw/qdev-core.h:769
#: ../../../../include/hw/qdev-core.h:798
#: ../../../../include/hw/qdev-core.h:812
#: ../../../../include/hw/qdev-core.h:825
#: ../../../../include/hw/qdev-core.h:842
#: ../../../../include/hw/qdev-core.h:892
#: ../../../../include/hw/qdev-core.h:901
#: ../../../../include/hw/qdev-core.h:910
#: ../../../../include/hw/qdev-core.h:918
#: ../../../../include/hw/qdev-core.h:932
#: ../../../../include/hw/qdev-core.h:943
#: ../../../../include/hw/qdev-core.h:959
#: ../../../../include/hw/qdev-core.h:976
#: ../../../../include/hw/qdev-core.h:1025
#: ../../../../include/hw/qdev-core.h:1051
msgid "**Parameters**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:435
#: ../../../../include/hw/qdev-core.h:447
#: ../../../../include/hw/qdev-core.h:626
#: ../../../../include/hw/qdev-core.h:677
#: ../../../../include/hw/qdev-core.h:705
#: ../../../../include/hw/qdev-core.h:726
#: ../../../../include/hw/qdev-core.h:800
#: ../../../../include/hw/qdev-core.h:815
#: ../../../../include/hw/qdev-core.h:827
#: ../../../../include/hw/qdev-core.h:844
msgid "``const char *name``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:432
msgid "device type to create (we assert() that this type exists)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:434
msgid ""
"This only allocates the memory and initializes the device state structure, "
"ready for the caller to set properties if they wish. The device still needs "
"to be realized."
msgstr ""

#: ../../../../include/hw/qdev-core.h:438
#: ../../../../include/hw/qdev-core.h:449
#: ../../../../include/hw/qdev-core.h:460
#: ../../../../include/hw/qdev-core.h:481
#: ../../../../include/hw/qdev-core.h:509
#: ../../../../include/hw/qdev-core.h:546
#: ../../../../include/hw/qdev-core.h:579
#: ../../../../include/hw/qdev-core.h:618
#: ../../../../include/hw/qdev-core.h:637
#: ../../../../include/hw/qdev-core.h:717
#: ../../../../include/hw/qdev-core.h:738
#: ../../../../include/hw/qdev-core.h:911
#: ../../../../include/hw/qdev-core.h:919
#: ../../../../include/hw/qdev-core.h:1057
msgid "**Return**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:438
msgid "a derived DeviceState object with a reference count of 1."
msgstr ""

#: ../../../../include/hw/qdev-core.h:443
msgid "Try to create a device on the heap"
msgstr ""

#: ../../../../include/hw/qdev-core.h:444
msgid "device type to create"
msgstr ""

#: ../../../../include/hw/qdev-core.h:446
msgid ""
"This is like qdev_new(), except it returns ``NULL`` when type **name** does "
"not exist, rather than asserting."
msgstr ""

#: ../../../../include/hw/qdev-core.h:449
msgid ""
"a derived DeviceState object with a reference count of 1 or NULL if type "
"**name** does not exist."
msgstr ""

#: ../../../../include/hw/qdev-core.h:455
msgid "check if device is realized"
msgstr ""

#: ../../../../include/hw/qdev-core.h:459
#: ../../../../include/hw/qdev-core.h:471
#: ../../../../include/hw/qdev-core.h:490
#: ../../../../include/hw/qdev-core.h:518
#: ../../../../include/hw/qdev-core.h:544
#: ../../../../include/hw/qdev-core.h:561
#: ../../../../include/hw/qdev-core.h:569
#: ../../../../include/hw/qdev-core.h:578
#: ../../../../include/hw/qdev-core.h:605
#: ../../../../include/hw/qdev-core.h:627
#: ../../../../include/hw/qdev-core.h:646
#: ../../../../include/hw/qdev-core.h:677
#: ../../../../include/hw/qdev-core.h:706
#: ../../../../include/hw/qdev-core.h:726
#: ../../../../include/hw/qdev-core.h:752
#: ../../../../include/hw/qdev-core.h:771
#: ../../../../include/hw/qdev-core.h:800
#: ../../../../include/hw/qdev-core.h:814
#: ../../../../include/hw/qdev-core.h:827
#: ../../../../include/hw/qdev-core.h:844
#: ../../../../include/hw/qdev-core.h:894
#: ../../../../include/hw/qdev-core.h:912
msgid "``DeviceState *dev``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:456
msgid "The device to check."
msgstr ""

#: ../../../../include/hw/qdev-core.h:458
msgid "**Context**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:458
msgid "May be called outside big qemu lock."
msgstr ""

#: ../../../../include/hw/qdev-core.h:459
msgid "true if the device has been fully constructed, false otherwise."
msgstr ""

#: ../../../../include/hw/qdev-core.h:467
msgid "Realize **dev**."
msgstr ""

#: ../../../../include/hw/qdev-core.h:468
#: ../../../../include/hw/qdev-core.h:487
msgid "device to realize"
msgstr ""

#: ../../../../include/hw/qdev-core.h:470
#: ../../../../include/hw/qdev-core.h:489
#: ../../../../include/hw/qdev-core.h:903
#: ../../../../include/hw/qdev-core.h:920
#: ../../../../include/hw/qdev-core.h:1027
msgid "``BusState *bus``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:469
#: ../../../../include/hw/qdev-core.h:488
msgid "bus to plug it into (may be NULL)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:471
#: ../../../../include/hw/qdev-core.h:490
#: ../../../../include/hw/qdev-core.h:578
#: ../../../../include/hw/qdev-core.h:1054
msgid "``Error **errp``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:470
#: ../../../../include/hw/qdev-core.h:489
#: ../../../../include/hw/qdev-core.h:1053
msgid "pointer to error object"
msgstr ""

#: ../../../../include/hw/qdev-core.h:472
msgid ""
"\"Realize\" the device, i.e. perform the second phase of device "
"initialization. **dev** must not be plugged into a bus already. If **bus**, "
"plug **dev** into **bus**.  This takes a reference to **dev**. If **dev** "
"has no QOM parent, make one up, taking another reference."
msgstr ""

#: ../../../../include/hw/qdev-core.h:478
msgid ""
"If you created **dev** using qdev_new(), you probably want to use "
"qdev_realize_and_unref() instead."
msgstr ""

#: ../../../../include/hw/qdev-core.h:481
#: ../../../../include/hw/qdev-core.h:509
msgid "true on success, else false setting **errp** with error"
msgstr ""

#: ../../../../include/hw/qdev-core.h:486
msgid "Realize **dev** and drop a reference"
msgstr ""

#: ../../../../include/hw/qdev-core.h:491
msgid ""
"Realize **dev** and drop a reference. This is like qdev_realize(), except "
"the caller must hold a (private) reference, which is dropped on return "
"regardless of success or failure.  Intended use::"
msgstr ""

#: ../../../../include/hw/qdev-core.h:496
msgid ""
"dev = qdev_new();\n"
"[...]\n"
"qdev_realize_and_unref(dev, bus, errp);"
msgstr ""

#: ../../../../include/hw/qdev-core.h:500
msgid "Now **dev** can go away without further ado."
msgstr ""

#: ../../../../include/hw/qdev-core.h:502
msgid ""
"If you are embedding the device into some other QOM device and initialized "
"it via some variant on object_initialize_child() then do not use this "
"function, because that family of functions arrange for the only reference to "
"the child device to be held by the parent via the child<> property, and so "
"the reference-count-drop done here would be incorrect. For that use case you "
"want qdev_realize()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:514
msgid "Unrealize a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:515
msgid "device to unrealize"
msgstr ""

#: ../../../../include/hw/qdev-core.h:517
msgid ""
"This function will \"unrealize\" a device, which is the first phase of "
"correctly destroying a device that has been realized. It will:"
msgstr ""

#: ../../../../include/hw/qdev-core.h:520
msgid ""
"unrealize any child buses by calling qbus_unrealize() (this will recursively "
"unrealize any devices on those buses)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:522
msgid "call the unrealize method of **dev**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:524
msgid ""
"The device can then be freed by causing its reference count to go to zero."
msgstr ""

#: ../../../../include/hw/qdev-core.h:527
msgid ""
"Warning: most devices in QEMU do not expect to be unrealized.  Only devices "
"which are hot-unpluggable should be unrealized (as part of the unplugging "
"process); all other devices are expected to last for the life of the "
"simulation and should not be unrealized and freed."
msgstr ""

#: ../../../../include/hw/qdev-core.h:540
msgid "Get handler responsible for device wiring"
msgstr ""

#: ../../../../include/hw/qdev-core.h:541
msgid "the device we want the HOTPLUG_HANDLER for."
msgstr ""

#: ../../../../include/hw/qdev-core.h:543
msgid "**Note**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:543
msgid ""
"in case **dev** has a parent bus, it will be returned as handler unless "
"machine handler overrides it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:546
msgid ""
"pointer to object that implements TYPE_HOTPLUG_HANDLER interface or NULL if "
"there aren't any."
msgstr ""

#: ../../../../include/hw/qdev-core.h:557
msgid "Add an unplug blocker to a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:559
msgid "Device to be blocked from unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:561
#: ../../../../include/hw/qdev-core.h:569
msgid "``Error *reason``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:560
msgid "Reason for blocking"
msgstr ""

#: ../../../../include/hw/qdev-core.h:565
msgid "Remove an unplug blocker from a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:567
msgid "Device to be unblocked"
msgstr ""

#: ../../../../include/hw/qdev-core.h:568
msgid ""
"Pointer to the Error used with qdev_add_unplug_blocker. Used as a handle to "
"lookup the blocker for deletion."
msgstr ""

#: ../../../../include/hw/qdev-core.h:574
msgid "Confirm if a device is blocked from unplug"
msgstr ""

#: ../../../../include/hw/qdev-core.h:576
msgid "Device to be tested"
msgstr ""

#: ../../../../include/hw/qdev-core.h:577
msgid "The reasons why the device is blocked, if any"
msgstr ""

#: ../../../../include/hw/qdev-core.h:579
msgid ""
"true (also setting **errp**) if device is blocked from unplug, false "
"otherwise"
msgstr ""

#: ../../../../include/hw/qdev-core.h:585
msgid "Polarity of a GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:587
msgid ""
"GPIO lines use either positive (active-high) logic, or negative (active-low) "
"logic."
msgstr ""

#: ../../../../include/hw/qdev-core.h:590
msgid ""
"In active-high logic (``GPIO_POLARITY_ACTIVE_HIGH``), a pin is active when "
"the voltage on the pin is high (relative to ground); whereas in active-low "
"logic (``GPIO_POLARITY_ACTIVE_LOW``), a pin is active when the voltage on "
"the pin is low (or grounded)."
msgstr ""

#: ../../../../include/hw/qdev-core.h:601
msgid "Get one of a device's anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:602
#: ../../../../include/hw/qdev-core.h:624
msgid "Device whose GPIO we want"
msgstr ""

#: ../../../../include/hw/qdev-core.h:604
#: ../../../../include/hw/qdev-core.h:627
#: ../../../../include/hw/qdev-core.h:645
#: ../../../../include/hw/qdev-core.h:678
#: ../../../../include/hw/qdev-core.h:706
#: ../../../../include/hw/qdev-core.h:727
#: ../../../../include/hw/qdev-core.h:752
#: ../../../../include/hw/qdev-core.h:771
#: ../../../../include/hw/qdev-core.h:801
#: ../../../../include/hw/qdev-core.h:816
#: ../../../../include/hw/qdev-core.h:828
msgid "``int n``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:603
msgid "Number of the anonymous GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:605
msgid ""
"Returns the qemu_irq corresponding to an anonymous input GPIO line (which "
"the device has set up with qdev_init_gpio_in()). The index **n** of the GPIO "
"line must be valid (i.e. be at least 0 and less than the total number of "
"anonymous input GPIOs the device has); this function will assert() if passed "
"an invalid index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:611
msgid ""
"This function is intended to be used by board code or SoC \"container\" "
"device models to wire up the GPIO lines; usually the return value will be "
"passed to qdev_connect_gpio_out() or a similar function to connect another "
"device's output GPIO line to this input."
msgstr ""

#: ../../../../include/hw/qdev-core.h:616
msgid "For named input GPIO lines, use qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:618
msgid "qemu_irq corresponding to anonymous input GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:623
msgid "Get one of a device's named input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:625
msgid "Name of the input GPIO array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:626
msgid "Number of the GPIO line in that array (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:628
msgid ""
"Returns the qemu_irq corresponding to a named input GPIO line (which the "
"device has set up with qdev_init_gpio_in_named()). The **name** string must "
"correspond to an input GPIO array which exists on the device, and the index "
"**n** of the GPIO line must be valid (i.e. be at least 0 and less than the "
"total number of input GPIOs in that array); this function will assert() if "
"passed an invalid name or index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:635
msgid "For anonymous input GPIO lines, use qdev_get_gpio_in()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:637
msgid "qemu_irq corresponding to named input GPIO line"
msgstr ""

#: ../../../../include/hw/qdev-core.h:642
msgid "Connect one of a device's anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:643
#: ../../../../include/hw/qdev-core.h:675
msgid "Device whose GPIO to connect"
msgstr ""

#: ../../../../include/hw/qdev-core.h:644
#: ../../../../include/hw/qdev-core.h:677
msgid "Number of the anonymous output GPIO line (which must be in range)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:646
msgid "``qemu_irq pin``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:645
#: ../../../../include/hw/qdev-core.h:678
msgid "qemu_irq to connect the output line to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:647
msgid ""
"This function connects an anonymous output GPIO line on a device up to an "
"arbitrary qemu_irq, so that when the device asserts that output GPIO line, "
"the qemu_irq's callback is invoked. The index **n** of the GPIO line must be "
"valid (i.e. be at least 0 and less than the total number of anonymous output "
"GPIOs the device has created with qdev_init_gpio_out()); otherwise this "
"function will assert()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:654
#: ../../../../include/hw/qdev-core.h:688
msgid ""
"Outbound GPIO lines can be connected to any qemu_irq, but the common case is "
"connecting them to another device's inbound GPIO line, using the qemu_irq "
"returned by qdev_get_gpio_in() or qdev_get_gpio_in_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:658
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq. (Warning: "
"there is no assertion or other guard to catch this error: the model will "
"just not do the right thing.) Instead, for fan-out you can use the "
"TYPE_SPLIT_IRQ device: connect a device's outbound GPIO to the splitter's "
"input, and connect each of the splitter's outputs to a different device.  "
"For fan-in you can use the TYPE_OR_IRQ device, which is a model of a logical "
"OR gate with multiple inputs and one output."
msgstr ""

#: ../../../../include/hw/qdev-core.h:668
msgid "For named output GPIO lines, use qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:673
msgid "Connect one of a device's named output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:676
#: ../../../../include/hw/qdev-core.h:704
#: ../../../../include/hw/qdev-core.h:725
msgid "Name of the output GPIO array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:679
msgid "``qemu_irq input_pin``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:680
msgid ""
"This function connects an anonymous output GPIO line on a device up to an "
"arbitrary qemu_irq, so that when the device asserts that output GPIO line, "
"the qemu_irq's callback is invoked. The **name** string must correspond to "
"an output GPIO array which exists on the device, and the index **n** of the "
"GPIO line must be valid (i.e. be at least 0 and less than the total number "
"of input GPIOs in that array); this function will assert() if passed an "
"invalid name or index."
msgstr ""

#: ../../../../include/hw/qdev-core.h:692
msgid ""
"It is not valid to try to connect one outbound GPIO to multiple qemu_irqs at "
"once, or to connect multiple outbound GPIOs to the same qemu_irq; see "
"qdev_connect_gpio_out() for details."
msgstr ""

#: ../../../../include/hw/qdev-core.h:696
msgid "For anonymous output GPIO lines, use qdev_connect_gpio_out()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:702
msgid "Get the qemu_irq connected to an output GPIO"
msgstr ""

#: ../../../../include/hw/qdev-core.h:703
msgid "Device whose output GPIO we are interested in"
msgstr ""

#: ../../../../include/hw/qdev-core.h:705
msgid "Number of the output GPIO line within that array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:707
msgid ""
"Returns whatever qemu_irq is currently connected to the specified output "
"GPIO line of **dev**. This will be NULL if the output GPIO line has never "
"been wired up to the anything.  Note that the qemu_irq returned does not "
"belong to **dev** -- it will be the input GPIO or IRQ of whichever device "
"the board code has connected up to **dev**'s output GPIO."
msgstr ""

#: ../../../../include/hw/qdev-core.h:714
msgid ""
"You probably don't need to use this function -- it is used only by the "
"platform-bus subsystem."
msgstr ""

#: ../../../../include/hw/qdev-core.h:717
msgid "qemu_irq associated with GPIO or NULL if un-wired."
msgstr ""

#: ../../../../include/hw/qdev-core.h:722
msgid "Intercept an existing GPIO connection"
msgstr ""

#: ../../../../include/hw/qdev-core.h:723
msgid "Device to intercept the outbound GPIO line from"
msgstr ""

#: ../../../../include/hw/qdev-core.h:725
msgid "``qemu_irq icpt``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:724
msgid "New qemu_irq to connect instead"
msgstr ""

#: ../../../../include/hw/qdev-core.h:726
msgid "Number of the GPIO line in the array"
msgstr ""

#: ../../../../include/hw/qdev-core.h:729
msgid ""
"This function is provided only for use by the qtest testing framework and is "
"not suitable for use in non-testing parts of QEMU."
msgstr ""

#: ../../../../include/hw/qdev-core.h:732
msgid ""
"This function breaks an existing connection of an outbound GPIO line from "
"**dev**, and replaces it with the new qemu_irq **icpt**, as if "
"``qdev_connect_gpio_out_named(dev, icpt, name, n)`` had been called. The "
"previously connected qemu_irq is returned, so it can be restored by a second "
"call to qdev_intercept_gpio_out() if desired."
msgstr ""

#: ../../../../include/hw/qdev-core.h:738
msgid "old disconnected qemu_irq if one existed"
msgstr ""

#: ../../../../include/hw/qdev-core.h:748
msgid "create an array of anonymous input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:749
#: ../../../../include/hw/qdev-core.h:811
msgid "Device to create input GPIOs for"
msgstr ""

#: ../../../../include/hw/qdev-core.h:751
#: ../../../../include/hw/qdev-core.h:813
#: ../../../../include/hw/qdev-core.h:826
msgid "``qemu_irq_handler handler``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:750
#: ../../../../include/hw/qdev-core.h:812
msgid "Function to call when GPIO line value is set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:751
#: ../../../../include/hw/qdev-core.h:770
#: ../../../../include/hw/qdev-core.h:800
msgid "Number of GPIO lines to create"
msgstr ""

#: ../../../../include/hw/qdev-core.h:753
msgid ""
"Devices should use functions in the qdev_init_gpio_in* family in their "
"instance_init or realize methods to create any input GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO input whose "
"purpose is obvious. Note that input GPIO lines can serve as 'sinks' for IRQ "
"lines."
msgstr ""

#: ../../../../include/hw/qdev-core.h:761
msgid ""
"See qdev_get_gpio_in() for how code that uses such a device can get hold of "
"an input GPIO line to manipulate it."
msgstr ""

#: ../../../../include/hw/qdev-core.h:767
msgid "create an array of anonymous output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:768
#: ../../../../include/hw/qdev-core.h:797
msgid "Device to create output GPIOs for"
msgstr ""

#: ../../../../include/hw/qdev-core.h:770
#: ../../../../include/hw/qdev-core.h:799
msgid "``qemu_irq *pins``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:769
#: ../../../../include/hw/qdev-core.h:798
msgid "Pointer to qemu_irq or qemu_irq array for the GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:772
msgid ""
"Devices should use functions in the qdev_init_gpio_out* family in their "
"instance_init or realize methods to create any output GPIO lines they need. "
"There is no functional difference between anonymous and named GPIO lines. "
"Stylistically, named GPIOs are preferable (easier to understand at "
"callsites) unless a device has exactly one uniform kind of GPIO output whose "
"purpose is obvious."
msgstr ""

#: ../../../../include/hw/qdev-core.h:779
msgid ""
"The **pins** argument should be a pointer to either a \"qemu_irq\" (if **n** "
"== 1) or a \"qemu_irq []\" array (if **n** > 1) in the device's state "
"structure. The device implementation can then raise and lower the GPIO line "
"by calling qemu_set_irq(). (If anything is connected to the other end of the "
"GPIO this will cause the handler function for that input GPIO to be called.)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:786
msgid ""
"See qdev_connect_gpio_out() for how code that uses such a device can connect "
"to one of its output GPIO lines."
msgstr ""

#: ../../../../include/hw/qdev-core.h:789
msgid ""
"There is no need to release the **pins** allocated array because it will be "
"automatically released when **dev** calls its instance_finalize() handler."
msgstr ""

#: ../../../../include/hw/qdev-core.h:796
msgid "create an array of named output GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:799
msgid "Name to give this array of GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:802
msgid ""
"Like qdev_init_gpio_out(), but creates an array of GPIO output lines with a "
"name. Code using the device can then connect these GPIO lines using "
"qdev_connect_gpio_out_named()."
msgstr ""

#: ../../../../include/hw/qdev-core.h:810
#: ../../../../include/hw/qdev-core.h:823
msgid "create an array of input GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:814
msgid "``void *opaque``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:813
msgid "Opaque data pointer to pass to **handler**"
msgstr ""

#: ../../../../include/hw/qdev-core.h:814
#: ../../../../include/hw/qdev-core.h:826
msgid "Name of the GPIO input (must be unique for this device)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:815
#: ../../../../include/hw/qdev-core.h:827
msgid "Number of GPIO lines in this input set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:824
msgid "device to add array to"
msgstr ""

#: ../../../../include/hw/qdev-core.h:825
msgid "a &typedef qemu_irq_handler function to call when GPIO is set"
msgstr ""

#: ../../../../include/hw/qdev-core.h:829
msgid ""
"Like qdev_init_gpio_in_named_with_opaque(), but the opaque pointer passed to "
"the handler is **dev** (which is the most commonly desired behaviour)."
msgstr ""

#: ../../../../include/hw/qdev-core.h:840
msgid "create GPIO lines on container which pass through to device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:841
msgid "Device which has GPIO lines"
msgstr ""

#: ../../../../include/hw/qdev-core.h:843
msgid "``DeviceState *container``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:842
msgid "Container device which needs to expose them"
msgstr ""

#: ../../../../include/hw/qdev-core.h:843
msgid "Name of GPIO array to pass through (NULL for the anonymous GPIO array)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:845
msgid ""
"In QEMU, complicated devices like SoCs are often modelled with a "
"\"container\" QOM device which itself contains other QOM devices and which "
"wires them up appropriately. This function allows the container to create "
"GPIO arrays on itself which simply pass through to a GPIO array of one of "
"its internal devices."
msgstr ""

#: ../../../../include/hw/qdev-core.h:851
msgid ""
"If **dev** has both input and output GPIOs named **name** then both will be "
"passed through. It is not possible to pass a subset of the array with this "
"function."
msgstr ""

#: ../../../../include/hw/qdev-core.h:855
msgid ""
"To users of the container device, the GPIO array created on **container** "
"behaves exactly like any other."
msgstr ""

#: ../../../../include/hw/qdev-core.h:890
msgid "perform a recursive cold reset on a device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:891
msgid "device to reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:893
msgid ""
"Reset device **dev** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/qdev-core.h:899
msgid "perform a recursive cold reset on a bus"
msgstr ""

#: ../../../../include/hw/qdev-core.h:900
msgid "bus to reset"
msgstr ""

#: ../../../../include/hw/qdev-core.h:902
msgid ""
"Reset bus **bus** and perform a recursive processing using the resettable "
"interface. It triggers a RESET_TYPE_COLD."
msgstr ""

#: ../../../../include/hw/qdev-core.h:908
msgid "check device reset state"
msgstr ""

#: ../../../../include/hw/qdev-core.h:909
msgid "device to check"
msgstr ""

#: ../../../../include/hw/qdev-core.h:911
msgid "true if the device **dev** is currently being reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:916
msgid "check bus reset state"
msgstr ""

#: ../../../../include/hw/qdev-core.h:917
msgid "bus to check"
msgstr ""

#: ../../../../include/hw/qdev-core.h:919
msgid "true if the bus **bus** is currently being reset."
msgstr ""

#: ../../../../include/hw/qdev-core.h:930
msgid "add a set of properties to an device"
msgstr ""

#: ../../../../include/hw/qdev-core.h:934
#: ../../../../include/hw/qdev-core.h:945
#: ../../../../include/hw/qdev-core.h:961
#: ../../../../include/hw/qdev-core.h:978
msgid "``DeviceClass *dc``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:931
msgid "the parent DeviceClass all devices inherit"
msgstr ""

#: ../../../../include/hw/qdev-core.h:933
msgid "``Property *props``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:932
msgid "an array of properties, terminate by DEFINE_PROP_END_OF_LIST()"
msgstr ""

#: ../../../../include/hw/qdev-core.h:934
msgid ""
"This will add a set of properties to the object. It will fault if you "
"attempt to add an existing property defined by a parent class. To modify an "
"inherited property you need to use????"
msgstr ""

#: ../../../../include/hw/qdev-core.h:941
msgid "legacy set device reset handlers"
msgstr ""

#: ../../../../include/hw/qdev-core.h:942
msgid "device class"
msgstr ""

#: ../../../../include/hw/qdev-core.h:944
msgid "``DeviceReset dev_reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:943
msgid "function pointer to reset handler"
msgstr ""

#: ../../../../include/hw/qdev-core.h:945
msgid "``DeviceReset *parent_reset``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:944
msgid "function pointer to parents reset handler"
msgstr ""

#: ../../../../include/hw/qdev-core.h:946
msgid ""
"Modern code should use the ResettableClass interface to implement a multi-"
"phase reset instead."
msgstr ""

#: ../../../../include/hw/qdev-core.h:949
msgid ""
"TODO: remove the function when DeviceClass's reset method is not used "
"anymore."
msgstr ""

#: ../../../../include/hw/qdev-core.h:957
msgid "set up for chaining realize fns"
msgstr ""

#: ../../../../include/hw/qdev-core.h:958
#: ../../../../include/hw/qdev-core.h:975
msgid "The device class"
msgstr ""

#: ../../../../include/hw/qdev-core.h:960
msgid "``DeviceRealize dev_realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:959
#: ../../../../include/hw/qdev-core.h:976
msgid "the device realize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:961
msgid "``DeviceRealize *parent_realize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:960
msgid "somewhere to save the parents realize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:962
msgid ""
"This is intended to be used when the new realize function will eventually "
"call its parent realization function during creation. This requires storing "
"the function call somewhere (usually in the instance structure) so you can "
"eventually call dc->parent_realize(dev, errp)"
msgstr ""

#: ../../../../include/hw/qdev-core.h:974
msgid "set up for chaining unrealize fns"
msgstr ""

#: ../../../../include/hw/qdev-core.h:977
msgid "``DeviceUnrealize dev_unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:978
msgid "``DeviceUnrealize *parent_unrealize``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:977
msgid "somewhere to save the parents unrealize function"
msgstr ""

#: ../../../../include/hw/qdev-core.h:979
msgid ""
"This is intended to be used when the new unrealize function will eventually "
"call its parent unrealization function during the unrealize phase. This "
"requires storing the function call somewhere (usually in the instance "
"structure) so you can eventually call dc->parent_unrealize(dev);"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1023
msgid "Mark this bus as full, so no more devices can be attached"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1024
msgid "Bus to mark as full"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1026
msgid ""
"By default, QEMU will allow devices to be plugged into a bus up to the bus "
"class's device count limit. Calling this function marks a particular bus as "
"full, so that no more devices can be plugged into it. In particular this "
"means that the bus will not be considered as a candidate for plugging in "
"devices created by the user on the commandline or via the monitor. If a "
"machine has multiple buses of a given type, such as I2C, where some of those "
"buses in the real hardware are used only for internal devices and some are "
"exposed via expansion ports, you can use this function to mark the internal-"
"only buses as full after you have created all their internal devices. Then "
"user created devices will appear on the expansion-port bus where guest "
"software expects them."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1049
msgid "check if device should be hidden"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1053
msgid "``const QDict *opts``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1051
msgid "options QDict"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1053
msgid "``bool from_json``"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1052
msgid "true if **opts** entries are typed, false for all strings"
msgstr ""

#: ../../../../include/hw/qdev-core.h:1055
msgid "When a device is added via qdev_device_add() this will be called."
msgstr ""

#: ../../../../include/hw/qdev-core.h:1057
msgid "if the device should be added now or not."
msgstr ""
