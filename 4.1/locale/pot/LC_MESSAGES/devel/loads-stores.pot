# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 4.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/loads-stores.rst:7
msgid "Load and Store APIs"
msgstr ""

#: ../../../devel/loads-stores.rst:9
msgid ""
"QEMU internally has multiple families of functions for performing loads and "
"stores. This document attempts to enumerate them all and indicate when to "
"use them. It does not provide detailed documentation of each API -- for that "
"you should look at the documentation comments in the relevant header files."
msgstr ""

#: ../../../devel/loads-stores.rst:17
msgid "``ld*_p and st*_p``"
msgstr ""

#: ../../../devel/loads-stores.rst:19
msgid ""
"These functions operate on a host pointer, and should be used when you "
"already have a pointer into host memory (corresponding to guest ram or a "
"local buffer). They deal with doing accesses with the desired endianness and "
"with correctly handling potentially unaligned pointer values."
msgstr ""

#: ../../../devel/loads-stores.rst:25 ../../../devel/loads-stores.rst:95
#: ../../../devel/loads-stores.rst:137
msgid "Function names follow the pattern:"
msgstr ""

#: ../../../devel/loads-stores.rst:27
msgid "load: ``ld{type}{sign}{size}_{endian}_p(ptr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:29
msgid "store: ``st{type}{size}_{endian}_p(ptr, val)``"
msgstr ""

#: ../../../devel/loads-stores.rst:31
msgid "``type``"
msgstr ""

#: ../../../devel/loads-stores.rst:32
msgid "(empty) : integer access"
msgstr ""

#: ../../../devel/loads-stores.rst:33
msgid "``f`` : float access"
msgstr ""

#: ../../../devel/loads-stores.rst:35 ../../../devel/loads-stores.rst:101
#: ../../../devel/loads-stores.rst:178 ../../../devel/loads-stores.rst:233
#: ../../../devel/loads-stores.rst:289 ../../../devel/loads-stores.rst:387
msgid "``sign``"
msgstr ""

#: ../../../devel/loads-stores.rst:36
msgid "(empty) : for 32 or 64 bit sizes (including floats and doubles)"
msgstr ""

#: ../../../devel/loads-stores.rst:37 ../../../devel/loads-stores.rst:103
#: ../../../devel/loads-stores.rst:180 ../../../devel/loads-stores.rst:235
#: ../../../devel/loads-stores.rst:291 ../../../devel/loads-stores.rst:389
msgid "``u`` : unsigned"
msgstr ""

#: ../../../devel/loads-stores.rst:38 ../../../devel/loads-stores.rst:104
#: ../../../devel/loads-stores.rst:181
msgid "``s`` : signed"
msgstr ""

#: ../../../devel/loads-stores.rst:40 ../../../devel/loads-stores.rst:106
#: ../../../devel/loads-stores.rst:183 ../../../devel/loads-stores.rst:239
#: ../../../devel/loads-stores.rst:295 ../../../devel/loads-stores.rst:393
msgid "``size``"
msgstr ""

#: ../../../devel/loads-stores.rst:41 ../../../devel/loads-stores.rst:107
#: ../../../devel/loads-stores.rst:184 ../../../devel/loads-stores.rst:240
#: ../../../devel/loads-stores.rst:296 ../../../devel/loads-stores.rst:394
msgid "``b`` : 8 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:42 ../../../devel/loads-stores.rst:108
#: ../../../devel/loads-stores.rst:185 ../../../devel/loads-stores.rst:241
#: ../../../devel/loads-stores.rst:297 ../../../devel/loads-stores.rst:395
msgid "``w`` : 16 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:43 ../../../devel/loads-stores.rst:109
#: ../../../devel/loads-stores.rst:186 ../../../devel/loads-stores.rst:242
#: ../../../devel/loads-stores.rst:298 ../../../devel/loads-stores.rst:396
msgid "``l`` : 32 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:44 ../../../devel/loads-stores.rst:110
#: ../../../devel/loads-stores.rst:187 ../../../devel/loads-stores.rst:243
#: ../../../devel/loads-stores.rst:299 ../../../devel/loads-stores.rst:397
msgid "``q`` : 64 bits"
msgstr ""

#: ../../../devel/loads-stores.rst:46 ../../../devel/loads-stores.rst:189
#: ../../../devel/loads-stores.rst:245 ../../../devel/loads-stores.rst:301
#: ../../../devel/loads-stores.rst:399
msgid "``endian``"
msgstr ""

#: ../../../devel/loads-stores.rst:47
msgid "``he`` : host endian"
msgstr ""

#: ../../../devel/loads-stores.rst:48 ../../../devel/loads-stores.rst:191
#: ../../../devel/loads-stores.rst:247 ../../../devel/loads-stores.rst:303
#: ../../../devel/loads-stores.rst:401
msgid "``be`` : big endian"
msgstr ""

#: ../../../devel/loads-stores.rst:49 ../../../devel/loads-stores.rst:190
#: ../../../devel/loads-stores.rst:246 ../../../devel/loads-stores.rst:302
#: ../../../devel/loads-stores.rst:400
msgid "``le`` : little endian"
msgstr ""

#: ../../../devel/loads-stores.rst:51
msgid "The ``_{endian}`` infix is omitted for target-endian accesses."
msgstr ""

#: ../../../devel/loads-stores.rst:53
msgid ""
"The target endian accessors are only available to source files which are "
"built per-target."
msgstr ""

#: ../../../devel/loads-stores.rst:56
msgid "There are also functions which take the size as an argument:"
msgstr ""

#: ../../../devel/loads-stores.rst:58
msgid "load: ``ldn{endian}_p(ptr, sz)``"
msgstr ""

#: ../../../devel/loads-stores.rst:60
msgid ""
"which performs an unsigned load of ``sz`` bytes from ``ptr`` as an ``{endian}"
"`` order value and returns it in a uint64_t."
msgstr ""

#: ../../../devel/loads-stores.rst:63
msgid "store: ``stn{endian}_p(ptr, sz, val)``"
msgstr ""

#: ../../../devel/loads-stores.rst:65
msgid ""
"which stores ``val`` to ``ptr`` as an ``{endian}`` order value of size "
"``sz`` bytes."
msgstr ""

#: ../../../devel/loads-stores.rst:69 ../../../devel/loads-stores.rst:116
#: ../../../devel/loads-stores.rst:143 ../../../devel/loads-stores.rst:194
#: ../../../devel/loads-stores.rst:251 ../../../devel/loads-stores.rst:269
#: ../../../devel/loads-stores.rst:307 ../../../devel/loads-stores.rst:331
#: ../../../devel/loads-stores.rst:366 ../../../devel/loads-stores.rst:405
msgid "Regexes for git grep"
msgstr ""

#: ../../../devel/loads-stores.rst:70
msgid "``\\<ldf\\?[us]\\?[bwlq]\\(_[hbl]e\\)\\?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:71
msgid "``\\<stf\\?[bwlq]\\(_[hbl]e\\)\\?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:72
msgid "``\\<ldn_\\([hbl]e\\)?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:73
msgid "``\\<stn_\\([hbl]e\\)?_p\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:76
msgid "``cpu_{ld,st}_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:78
msgid ""
"These functions operate on a guest virtual address. Be aware that these "
"functions may cause a guest CPU exception to be taken (e.g. for an alignment "
"fault or MMU fault) which will result in guest CPU state being updated and "
"control longjumping out of the function call. They should therefore only be "
"used in code that is implementing emulation of the target CPU."
msgstr ""

#: ../../../devel/loads-stores.rst:85
msgid ""
"These functions may throw an exception (longjmp() back out to the top level "
"TCG loop). This means they must only be used from helper functions where the "
"translator has saved all necessary CPU state before generating the helper "
"function call. It's usually better to use the ``_ra`` variants described "
"below from helper functions, but these functions are the right choice for "
"calls made from hooks like the CPU do_interrupt hook or when you know for "
"certain that the translator had to save all the CPU state that "
"``cpu_restore_state()`` would restore anyway."
msgstr ""

#: ../../../devel/loads-stores.rst:97
msgid "load: ``cpu_ld{sign}{size}_{mmusuffix}(env, ptr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:99
msgid "store: ``cpu_st{size}_{mmusuffix}(env, ptr, val)``"
msgstr ""

#: ../../../devel/loads-stores.rst:102 ../../../devel/loads-stores.rst:179
#: ../../../devel/loads-stores.rst:234 ../../../devel/loads-stores.rst:290
#: ../../../devel/loads-stores.rst:388
msgid "(empty) : for 32 or 64 bit sizes"
msgstr ""

#: ../../../devel/loads-stores.rst:112
msgid ""
"``mmusuffix`` is one of the generic suffixes ``data`` or ``code``, or (for "
"softmmu configs) a target-specific MMU mode suffix as defined in the "
"target's ``cpu.h``."
msgstr ""

#: ../../../devel/loads-stores.rst:117
msgid "``\\<cpu_ld[us]\\?[bwlq]_[a-zA-Z0-9]\\+\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:118
msgid "``\\<cpu_st[bwlq]_[a-zA-Z0-9]\\+\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:121
msgid "``cpu_{ld,st}_*_ra``"
msgstr ""

#: ../../../devel/loads-stores.rst:123
msgid ""
"These functions work like the ``cpu_{ld,st}_*`` functions except that they "
"also take a ``retaddr`` argument. This extra argument allows for correct "
"unwinding of any exception that is taken, and should generally be the result "
"of GETPC() called directly from the top level HELPER(foo) function (i.e. the "
"return address in the generated code)."
msgstr ""

#: ../../../devel/loads-stores.rst:130
msgid ""
"These are generally the preferred way to do accesses by guest virtual "
"address from helper functions; see the documentation of the non-``_ra`` "
"variants for when those would be better."
msgstr ""

#: ../../../devel/loads-stores.rst:134
msgid ""
"Calling these functions with a ``retaddr`` argument of 0 is equivalent to "
"calling the non-``_ra`` version of the function."
msgstr ""

#: ../../../devel/loads-stores.rst:139
msgid "load: ``cpu_ld{sign}{size}_{mmusuffix}_ra(env, ptr, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:141
msgid "store: ``cpu_st{sign}{size}_{mmusuffix}_ra(env, ptr, val, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:144
msgid "``\\<cpu_ld[us]\\?[bwlq]_[a-zA-Z0-9]\\+_ra\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:145
msgid "``\\<cpu_st[bwlq]_[a-zA-Z0-9]\\+_ra\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:148
msgid "``helper_*_{ld,st}*mmu``"
msgstr ""

#: ../../../devel/loads-stores.rst:150
msgid ""
"These functions are intended primarily to be called by the code generated by "
"the TCG backend. They may also be called by target CPU helper function code. "
"Like the ``cpu_{ld,st}_*_ra`` functions they perform accesses by guest "
"virtual address; the difference is that these functions allow you to specify "
"an ``opindex`` parameter which encodes (among other things) the mmu index to "
"use for the access. This is necessary if your helper needs to make an access "
"via a specific mmu index (for instance, an \"always as non-privileged\" "
"access) rather than using the default mmu index for the current state of the "
"guest CPU."
msgstr ""

#: ../../../devel/loads-stores.rst:161
msgid ""
"The ``opindex`` parameter should be created by calling ``make_memop_idx()``."
msgstr ""

#: ../../../devel/loads-stores.rst:163
msgid ""
"The ``retaddr`` parameter should be the result of GETPC() called directly "
"from the top level HELPER(foo) function (or 0 if no guest CPU state "
"unwinding is required)."
msgstr ""

#: ../../../devel/loads-stores.rst:167
msgid ""
"**TODO** The names of these functions are a bit odd for historical reasons "
"because they were originally expected to be called only from within "
"generated code. We should rename them to bring them more in line with the "
"other memory access functions."
msgstr ""

#: ../../../devel/loads-stores.rst:172
msgid ""
"load: ``helper_{endian}_ld{sign}{size}_mmu(env, addr, opindex, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:174
msgid ""
"load (code): ``helper_{endian}_ld{sign}{size}_cmmu(env, addr, opindex, "
"retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:176
msgid ""
"store: ``helper_{endian}_st{size}_mmu(env, addr, val, opindex, retaddr)``"
msgstr ""

#: ../../../devel/loads-stores.rst:192
msgid "``ret`` : target endianness"
msgstr ""

#: ../../../devel/loads-stores.rst:195
msgid "``\\<helper_\\(le\\|be\\|ret\\)_ld[us]\\?[bwlq]_c\\?mmu\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:196
msgid "``\\<helper_\\(le\\|be\\|ret\\)_st[bwlq]_mmu\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:199
msgid "``address_space_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:201
msgid ""
"These functions are the primary ones to use when emulating CPU or device "
"memory accesses. They take an AddressSpace, which is the way QEMU defines "
"the view of memory that a device or CPU has. (They generally correspond to "
"being the \"master\" end of a hardware bus or bus fabric.)"
msgstr ""

#: ../../../devel/loads-stores.rst:207
msgid ""
"Each CPU has an AddressSpace. Some kinds of CPU have more than one "
"AddressSpace (for instance ARM guest CPUs have an AddressSpace for the "
"Secure world and one for NonSecure if they implement TrustZone). Devices "
"which can do DMA-type operations should generally have an AddressSpace. "
"There is also a \"system address space\" which typically has all the devices "
"and memory that all CPUs can see. (Some older device models use the \"system "
"address space\" rather than properly modelling that they have an "
"AddressSpace of their own.)"
msgstr ""

#: ../../../devel/loads-stores.rst:216
msgid ""
"Functions are provided for doing byte-buffer reads and writes, and also for "
"doing one-data-item loads and stores."
msgstr ""

#: ../../../devel/loads-stores.rst:219
msgid ""
"In all cases the caller provides a MemTxAttrs to specify bus transaction "
"attributes, and can check whether the memory transaction succeeded using a "
"MemTxResult return code."
msgstr ""

#: ../../../devel/loads-stores.rst:223
msgid "``address_space_read(address_space, addr, attrs, buf, len)``"
msgstr ""

#: ../../../devel/loads-stores.rst:225
msgid "``address_space_write(address_space, addr, attrs, buf, len)``"
msgstr ""

#: ../../../devel/loads-stores.rst:227
msgid "``address_space_rw(address_space, addr, attrs, buf, len, is_write)``"
msgstr ""

#: ../../../devel/loads-stores.rst:229
msgid ""
"``address_space_ld{sign}{size}_{endian}(address_space, addr, attrs, "
"txresult)``"
msgstr ""

#: ../../../devel/loads-stores.rst:231
msgid ""
"``address_space_st{size}_{endian}(address_space, addr, val, attrs, "
"txresult)``"
msgstr ""

#: ../../../devel/loads-stores.rst:237 ../../../devel/loads-stores.rst:293
#: ../../../devel/loads-stores.rst:391
msgid "(No signed load operations are provided.)"
msgstr ""

#: ../../../devel/loads-stores.rst:249
msgid "The ``_{endian}`` suffix is omitted for byte accesses."
msgstr ""

#: ../../../devel/loads-stores.rst:252
msgid "``\\<address_space_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:253
msgid "``\\<address_space_ldu\\?[bwql]\\(_[lb]e\\)\\?\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:254
msgid "``\\<address_space_st[bwql]\\(_[lb]e\\)\\?\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:257 ../../../devel/loads-stores.rst:270
msgid "``address_space_write_rom``"
msgstr ""

#: ../../../devel/loads-stores.rst:259
msgid ""
"This function performs a write by physical address like "
"``address_space_write``, except that if the write is to a ROM then the ROM "
"contents will be modified, even though a write by the guest CPU to the ROM "
"would be ignored. This is used for non-guest writes like writes from the gdb "
"debug stub or initial loading of ROM contents."
msgstr ""

#: ../../../devel/loads-stores.rst:265
msgid ""
"Note that portions of the write which attempt to write data to a device will "
"be silently ignored -- only real RAM and ROM will be written to."
msgstr ""

#: ../../../devel/loads-stores.rst:273
msgid "``{ld,st}*_phys``"
msgstr ""

#: ../../../devel/loads-stores.rst:275
msgid ""
"These are functions which are identical to ``address_space_{ld,st}*``, "
"except that they always pass ``MEMTXATTRS_UNSPECIFIED`` for the transaction "
"attributes, and ignore whether the transaction succeeded or failed."
msgstr ""

#: ../../../devel/loads-stores.rst:280
msgid ""
"The fact that they ignore whether the transaction succeeded means they "
"should not be used in new code, unless you know for certain that your code "
"will only be used in a context where the CPU or device doing the access has "
"no way to report such an error."
msgstr ""

#: ../../../devel/loads-stores.rst:285
msgid "``load: ld{sign}{size}_{endian}_phys``"
msgstr ""

#: ../../../devel/loads-stores.rst:287
msgid "``store: st{size}_{endian}_phys``"
msgstr ""

#: ../../../devel/loads-stores.rst:305 ../../../devel/loads-stores.rst:403
msgid "The ``_{endian}_`` infix is omitted for byte accesses."
msgstr ""

#: ../../../devel/loads-stores.rst:308
msgid "``\\<ldu\\?[bwlq]\\(_[bl]e\\)\\?_phys\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:309
msgid "``\\<st[bwlq]\\(_[bl]e\\)\\?_phys\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:312
msgid "``cpu_physical_memory_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:314
msgid ""
"These are convenience functions which are identical to ``address_space_*`` "
"but operate specifically on the system address space, always pass a "
"``MEMTXATTRS_UNSPECIFIED`` set of memory attributes and ignore whether the "
"memory transaction succeeded or failed. For new code they are better avoided:"
msgstr ""

#: ../../../devel/loads-stores.rst:320
msgid ""
"there is likely to be behaviour you need to model correctly for a failed "
"read or write operation"
msgstr ""

#: ../../../devel/loads-stores.rst:322
msgid ""
"a device should usually perform operations on its own AddressSpace rather "
"than using the system address space"
msgstr ""

#: ../../../devel/loads-stores.rst:325
msgid "``cpu_physical_memory_read``"
msgstr ""

#: ../../../devel/loads-stores.rst:327
msgid "``cpu_physical_memory_write``"
msgstr ""

#: ../../../devel/loads-stores.rst:329
msgid "``cpu_physical_memory_rw``"
msgstr ""

#: ../../../devel/loads-stores.rst:332
msgid "``\\<cpu_physical_memory_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:335 ../../../devel/loads-stores.rst:348
msgid "``cpu_memory_rw_debug``"
msgstr ""

#: ../../../devel/loads-stores.rst:337
msgid "Access CPU memory by virtual address for debug purposes."
msgstr ""

#: ../../../devel/loads-stores.rst:339
msgid ""
"This function is intended for use by the GDB stub and similar code. It takes "
"a virtual address, converts it to a physical address via an MMU lookup using "
"the current settings of the specified CPU, and then performs the access "
"(using ``address_space_rw`` for reads or ``cpu_physical_memory_write_rom`` "
"for writes). This means that if the access is a write to a ROM then this "
"function will modify the contents (whereas a normal guest CPU access would "
"ignore the write attempt)."
msgstr ""

#: ../../../devel/loads-stores.rst:351
msgid "``dma_memory_*``"
msgstr ""

#: ../../../devel/loads-stores.rst:353
msgid ""
"These behave like ``address_space_*``, except that they perform a DMA "
"barrier operation first."
msgstr ""

#: ../../../devel/loads-stores.rst:356
msgid ""
"**TODO**: We should provide guidance on when you need the DMA barrier "
"operation and when it's OK to use ``address_space_*``, and make sure our "
"existing code is doing things correctly."
msgstr ""

#: ../../../devel/loads-stores.rst:360
msgid "``dma_memory_read``"
msgstr ""

#: ../../../devel/loads-stores.rst:362
msgid "``dma_memory_write``"
msgstr ""

#: ../../../devel/loads-stores.rst:364
msgid "``dma_memory_rw``"
msgstr ""

#: ../../../devel/loads-stores.rst:367
msgid "``\\<dma_memory_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:370
msgid "``pci_dma_*`` and ``{ld,st}*_pci_dma``"
msgstr ""

#: ../../../devel/loads-stores.rst:372
msgid ""
"These functions are specifically for PCI device models which need to perform "
"accesses where the PCI device is a bus master. You pass them a ``PCIDevice "
"*`` and they will do ``dma_memory_*`` operations on the correct address "
"space for that device."
msgstr ""

#: ../../../devel/loads-stores.rst:377
msgid "``pci_dma_read``"
msgstr ""

#: ../../../devel/loads-stores.rst:379
msgid "``pci_dma_write``"
msgstr ""

#: ../../../devel/loads-stores.rst:381
msgid "``pci_dma_rw``"
msgstr ""

#: ../../../devel/loads-stores.rst:383
msgid "``load: ld{sign}{size}_{endian}_pci_dma``"
msgstr ""

#: ../../../devel/loads-stores.rst:385
msgid "``store: st{size}_{endian}_pci_dma``"
msgstr ""

#: ../../../devel/loads-stores.rst:406
msgid "``\\<pci_dma_\\(read\\|write\\|rw\\)\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:407
msgid "``\\<ldu\\?[bwlq]\\(_[bl]e\\)\\?_pci_dma\\>``"
msgstr ""

#: ../../../devel/loads-stores.rst:408
msgid "``\\<st[bwlq]\\(_[bl]e\\)\\?_pci_dma\\>``"
msgstr ""
