# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 10:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/clocks.rst:2
msgid "Modelling a clock tree in QEMU"
msgstr ""

#: ../../../devel/clocks.rst:5
msgid "What are clocks?"
msgstr ""

#: ../../../devel/clocks.rst:7
msgid ""
"Clocks are QOM objects developed for the purpose of modelling the "
"distribution of clocks in QEMU."
msgstr ""

#: ../../../devel/clocks.rst:10
msgid ""
"They allow us to model the clock distribution of a platform and detect "
"configuration errors in the clock tree such as badly configured PLL, clock "
"source selection or disabled clock."
msgstr ""

#: ../../../devel/clocks.rst:14
msgid ""
"The object is *Clock* and its QOM name is ``clock`` (in C code, the macro "
"``TYPE_CLOCK``)."
msgstr ""

#: ../../../devel/clocks.rst:17
msgid ""
"Clocks are typically used with devices where they are used to model inputs "
"and outputs. They are created in a similar way to GPIOs. Inputs and outputs "
"of different devices can be connected together."
msgstr ""

#: ../../../devel/clocks.rst:21
msgid ""
"In these cases a Clock object is a child of a Device object, but this is not "
"a requirement. Clocks can be independent of devices. For example it is "
"possible to create a clock outside of any device to model the main clock "
"source of a machine."
msgstr ""

#: ../../../devel/clocks.rst:26
msgid "Here is an example of clocks::"
msgstr ""

#: ../../../devel/clocks.rst:28
msgid ""
"+---------+      +----------------------+   +--------------+\n"
"| Clock 1 |      |       Device B       |   |   Device C   |\n"
"|         |      | +-------+  +-------+ |   | +-------+    |\n"
"|         |>>-+-->>|Clock 2|  |Clock 3|>>--->>|Clock 6|    |\n"
"+---------+   |  | | (in)  |  | (out) | |   | | (in)  |    |\n"
"              |  | +-------+  +-------+ |   | +-------+    |\n"
"              |  |            +-------+ |   +--------------+\n"
"              |  |            |Clock 4|>>\n"
"              |  |            | (out) | |   +--------------+\n"
"              |  |            +-------+ |   |   Device D   |\n"
"              |  |            +-------+ |   | +-------+    |\n"
"              |  |            |Clock 5|>>--->>|Clock 7|    |\n"
"              |  |            | (out) | |   | | (in)  |    |\n"
"              |  |            +-------+ |   | +-------+    |\n"
"              |  +----------------------+   |              |\n"
"              |                             | +-------+    |\n"
"              +----------------------------->>|Clock 8|    |\n"
"                                            | | (in)  |    |\n"
"                                            | +-------+    |\n"
"                                            +--------------+"
msgstr ""

#: ../../../devel/clocks.rst:49
msgid ""
"Clocks are defined in the ``include/hw/clock.h`` header and device related "
"functions are defined in the ``include/hw/qdev-clock.h`` header."
msgstr ""

#: ../../../devel/clocks.rst:54
msgid "The clock state"
msgstr ""

#: ../../../devel/clocks.rst:56
msgid ""
"The state of a clock is its period; it is stored as an integer representing "
"it in units of 2 :sup:`-32` ns. The special value of 0 is used to represent "
"the clock being inactive or gated. The clocks do not model the signal itself "
"(pin toggling) or other properties such as the duty cycle."
msgstr ""

#: ../../../devel/clocks.rst:62
msgid ""
"All clocks contain this state: outputs as well as inputs. This allows the "
"current period of a clock to be fetched at any time. When a clock is "
"updated, the value is immediately propagated to all connected clocks in the "
"tree."
msgstr ""

#: ../../../devel/clocks.rst:67
msgid ""
"To ease interaction with clocks, helpers with a unit suffix are defined for "
"every clock state setter or getter. The suffixes are:"
msgstr ""

#: ../../../devel/clocks.rst:70
msgid "``_ns`` for handling periods in nanoseconds"
msgstr ""

#: ../../../devel/clocks.rst:71
msgid "``_hz`` for handling frequencies in hertz"
msgstr ""

#: ../../../devel/clocks.rst:73
msgid ""
"The 0 period value is converted to 0 in hertz and vice versa. 0 always means "
"that the clock is disabled."
msgstr ""

#: ../../../devel/clocks.rst:77
msgid "Adding a new clock"
msgstr ""

#: ../../../devel/clocks.rst:79
msgid ""
"Adding clocks to a device must be done during the init method of the Device "
"instance."
msgstr ""

#: ../../../devel/clocks.rst:82
msgid ""
"To add an input clock to a device, the function ``qdev_init_clock_in()`` "
"must be used.  It takes the name, a callback and an opaque parameter for the "
"callback (this will be explained in a following section). Output is simpler; "
"only the name is required. Typically::"
msgstr ""

#: ../../../devel/clocks.rst:87
msgid ""
"qdev_init_clock_in(DEVICE(dev), \"clk_in\", clk_in_callback, dev);\n"
"qdev_init_clock_out(DEVICE(dev), \"clk_out\");"
msgstr ""

#: ../../../devel/clocks.rst:90
msgid ""
"Both functions return the created Clock pointer, which should be saved in "
"the device's state structure for further use."
msgstr ""

#: ../../../devel/clocks.rst:93
msgid ""
"These objects will be automatically deleted by the QOM reference mechanism."
msgstr ""

#: ../../../devel/clocks.rst:95
msgid ""
"Note that it is possible to create a static array describing clock inputs "
"and outputs. The function ``qdev_init_clocks()`` must be called with the "
"array as parameter to initialize the clocks: it has the same behaviour as "
"calling the ``qdev_init_clock_in/out()`` for each clock in the array. To "
"ease the array construction, some macros are defined in ``include/hw/qdev-"
"clock.h``. As an example, the following creates 2 clocks to a device: one "
"input and one output."
msgstr ""

#: ../../../devel/clocks.rst:103
msgid ""
"/* device structure containing pointers to the clock objects */\n"
"typedef struct MyDeviceState {\n"
"    DeviceState parent_obj;\n"
"    Clock *clk_in;\n"
"    Clock *clk_out;\n"
"} MyDeviceState;\n"
"\n"
"/*\n"
" * callback for the input clock (see \"Callback on input clock\n"
" * change\" section below for more information).\n"
" */\n"
"static void clk_in_callback(void *opaque);\n"
"\n"
"/*\n"
" * static array describing clocks:\n"
" * + a clock input named \"clk_in\", whose pointer is stored in\n"
" *   the clk_in field of a MyDeviceState structure with callback\n"
" *   clk_in_callback.\n"
" * + a clock output named \"clk_out\" whose pointer is stored in\n"
" *   the clk_out field of a MyDeviceState structure.\n"
" */\n"
"static const ClockPortInitArray mydev_clocks = {\n"
"    QDEV_CLOCK_IN(MyDeviceState, clk_in, clk_in_callback),\n"
"    QDEV_CLOCK_OUT(MyDeviceState, clk_out),\n"
"    QDEV_CLOCK_END\n"
"};\n"
"\n"
"/* device initialization function */\n"
"static void mydev_init(Object *obj)\n"
"{\n"
"    /* cast to MyDeviceState */\n"
"    MyDeviceState *mydev = MYDEVICE(obj);\n"
"    /* create and fill the pointer fields in the MyDeviceState */\n"
"    qdev_init_clocks(mydev, mydev_clocks);\n"
"    [...]\n"
"}"
msgstr ""

#: ../../../devel/clocks.rst:142
msgid ""
"An alternative way to create a clock is to simply call "
"``object_new(TYPE_CLOCK)``. In that case the clock will neither be an input "
"nor an output of a device. After the whole QOM hierarchy of the clock has "
"been set ``clock_setup_canonical_path()`` should be called."
msgstr ""

#: ../../../devel/clocks.rst:147
msgid ""
"At creation, the period of the clock is 0: the clock is disabled. You can "
"change it using ``clock_set_ns()`` or ``clock_set_hz()``."
msgstr ""

#: ../../../devel/clocks.rst:150
msgid ""
"Note that if you are creating a clock with a fixed period which will never "
"change (for example the main clock source of a board), then you'll have "
"nothing else to do. This value will be propagated to other clocks when "
"connecting the clocks together and devices will fetch the right value during "
"the first reset."
msgstr ""

#: ../../../devel/clocks.rst:157
msgid "Retrieving clocks from a device"
msgstr ""

#: ../../../devel/clocks.rst:159
msgid ""
"``qdev_get_clock_in()`` and ``dev_get_clock_out()`` are available to get the "
"clock inputs or outputs of a device. For example:"
msgstr ""

#: ../../../devel/clocks.rst:162
msgid "Clock *clk = qdev_get_clock_in(DEVICE(mydev), \"clk_in\");"
msgstr ""

#: ../../../devel/clocks.rst:166
msgid "or:"
msgstr ""

#: ../../../devel/clocks.rst:168
msgid "Clock *clk = qdev_get_clock_out(DEVICE(mydev), \"clk_out\");"
msgstr ""

#: ../../../devel/clocks.rst:173
msgid "Connecting two clocks together"
msgstr ""

#: ../../../devel/clocks.rst:175
msgid ""
"To connect two clocks together, use the ``clock_set_source()`` function. "
"Given two clocks ``clk1``, and ``clk2``, ``clock_set_source(clk2, clk1);`` "
"configures ``clk2`` to follow the ``clk1`` period changes. Every time "
"``clk1`` is updated, ``clk2`` will be updated too."
msgstr ""

#: ../../../devel/clocks.rst:180
msgid ""
"When connecting clock between devices, prefer using the "
"``qdev_connect_clock_in()`` function to set the source of an input device "
"clock.  For example, to connect the input clock ``clk2`` of ``devB`` to the "
"output clock ``clk1`` of ``devA``, do:"
msgstr ""

#: ../../../devel/clocks.rst:185
msgid ""
"qdev_connect_clock_in(devB, \"clk2\", qdev_get_clock_out(devA, \"clk1\"))"
msgstr ""

#: ../../../devel/clocks.rst:189
msgid ""
"We used ``qdev_get_clock_out()`` above, but any clock can drive an input "
"clock, even another input clock. The following diagram shows some examples "
"of connections. Note also that a clock can drive several other clocks."
msgstr ""

#: ../../../devel/clocks.rst:196
msgid ""
"+------------+  +--------------------------------------------------+\n"
"|  Device A  |  |                   Device B                       |\n"
"|            |  |               +---------------------+            |\n"
"|            |  |               |       Device C      |            |\n"
"|  +-------+ |  | +-------+     | +-------+ +-------+ |  +-------+ |\n"
"|  |Clock 1|>>-->>|Clock 2|>>+-->>|Clock 3| |Clock 5|>>>>|Clock 6|>>\n"
"|  | (out) | |  | | (in)  |  |  | | (in)  | | (out) | |  | (out) | |\n"
"|  +-------+ |  | +-------+  |  | +-------+ +-------+ |  +-------+ |\n"
"+------------+  |            |  +---------------------+            |\n"
"                |            |                                     |\n"
"                |            |  +--------------+                   |\n"
"                |            |  |   Device D   |                   |\n"
"                |            |  | +-------+    |                   |\n"
"                |            +-->>|Clock 4|    |                   |\n"
"                |               | | (in)  |    |                   |\n"
"                |               | +-------+    |                   |\n"
"                |               +--------------+                   |\n"
"                +--------------------------------------------------+"
msgstr ""

#: ../../../devel/clocks.rst:215
msgid ""
"In the above example, when *Clock 1* is updated by *Device A*, three clocks "
"get the new clock period value: *Clock 2*, *Clock 3* and *Clock 4*."
msgstr ""

#: ../../../devel/clocks.rst:218
msgid ""
"It is not possible to disconnect a clock or to change the clock connection "
"after it is connected."
msgstr ""

#: ../../../devel/clocks.rst:222
msgid "Unconnected input clocks"
msgstr ""

#: ../../../devel/clocks.rst:224
msgid ""
"A newly created input clock is disabled (period of 0). This means the clock "
"will be considered as disabled until the period is updated. If the clock "
"remains unconnected it will always keep its initial value of 0. If this is "
"not the desired behaviour, ``clock_set()``, ``clock_set_ns()`` or "
"``clock_set_hz()`` should be called on the Clock object during device "
"instance init. For example:"
msgstr ""

#: ../../../devel/clocks.rst:231
msgid ""
"clk = qdev_init_clock_in(DEVICE(dev), \"clk-in\", clk_in_callback,\n"
"                         dev);\n"
"/* set initial value to 10ns / 100MHz */\n"
"clock_set_ns(clk, 10);"
msgstr ""

#: ../../../devel/clocks.rst:239
msgid "Fetching clock frequency/period"
msgstr ""

#: ../../../devel/clocks.rst:241
msgid ""
"To get the current state of a clock, use the functions ``clock_get()``, "
"``clock_get_ns()`` or ``clock_get_hz()``."
msgstr ""

#: ../../../devel/clocks.rst:244
msgid ""
"It is also possible to register a callback on clock frequency changes. Here "
"is an example:"
msgstr ""

#: ../../../devel/clocks.rst:247
msgid ""
"void clock_callback(void *opaque) {\n"
"    MyDeviceState *s = (MyDeviceState *) opaque;\n"
"    /*\n"
"     * 'opaque' is the argument passed to qdev_init_clock_in();\n"
"     * usually this will be the device state pointer.\n"
"     */\n"
"\n"
"    /* do something with the new period */\n"
"    fprintf(stdout, \"device new period is %\" PRIu64 \"ns\\n\",\n"
"                    clock_get_ns(dev->my_clk_input));\n"
"}"
msgstr ""

#: ../../../devel/clocks.rst:262
msgid "Changing a clock period"
msgstr ""

#: ../../../devel/clocks.rst:264
msgid ""
"A device can change its outputs using the ``clock_update()``, "
"``clock_update_ns()`` or ``clock_update_hz()`` function. It will trigger "
"updates on every connected input."
msgstr ""

#: ../../../devel/clocks.rst:268
msgid ""
"For example, let's say that we have an output clock *clkout* and we have a "
"pointer to it in the device state because we did the following in init phase:"
msgstr ""

#: ../../../devel/clocks.rst:272
msgid "dev->clkout = qdev_init_clock_out(DEVICE(dev), \"clkout\");"
msgstr ""

#: ../../../devel/clocks.rst:276
msgid ""
"Then at any time (apart from the cases listed below), it is possible to "
"change the clock value by doing:"
msgstr ""

#: ../../../devel/clocks.rst:279
msgid "clock_update_hz(dev->clkout, 1000 * 1000 * 1000); /* 1GHz */"
msgstr ""

#: ../../../devel/clocks.rst:283
msgid ""
"Because updating a clock may trigger any side effects through connected "
"clocks and their callbacks, this operation must be done while holding the "
"qemu io lock."
msgstr ""

#: ../../../devel/clocks.rst:287
msgid ""
"For the same reason, one can update clocks only when it is allowed to have "
"side effects on other objects. In consequence, it is forbidden:"
msgstr ""

#: ../../../devel/clocks.rst:290
msgid "during migration,"
msgstr ""

#: ../../../devel/clocks.rst:291
msgid "and in the enter phase of reset."
msgstr ""

#: ../../../devel/clocks.rst:293
msgid ""
"Note that calling ``clock_update[_ns|_hz]()`` is equivalent to calling "
"``clock_set[_ns|_hz]()`` (with the same arguments) then "
"``clock_propagate()`` on the clock. Thus, setting the clock value can be "
"separated from triggering the side-effects. This is often required to "
"factorize code to handle reset and migration in devices."
msgstr ""

#: ../../../devel/clocks.rst:300
msgid "Aliasing clocks"
msgstr ""

#: ../../../devel/clocks.rst:302
msgid ""
"Sometimes, one needs to forward, or inherit, a clock from another device.  "
"Typically, when doing device composition, a device might expose a sub-"
"device's clock without interfering with it.  The function "
"``qdev_alias_clock()`` can be used to achieve this behaviour. Note that it "
"is possible to expose the clock under a different name. "
"``qdev_alias_clock()`` works for both input and output clocks."
msgstr ""

#: ../../../devel/clocks.rst:309
msgid ""
"For example, if device B is a child of device A, "
"``device_a_instance_init()`` may do something like this:"
msgstr ""

#: ../../../devel/clocks.rst:312
msgid ""
"void device_a_instance_init(Object *obj)\n"
"{\n"
"    AState *A = DEVICE_A(obj);\n"
"    BState *B;\n"
"    /* create object B as child of A */\n"
"    [...]\n"
"    qdev_alias_clock(B, \"clk\", A, \"b_clk\");\n"
"    /*\n"
"     * Now A has a clock \"b_clk\" which is an alias to\n"
"     * the clock \"clk\" of its child B.\n"
"     */\n"
"}"
msgstr ""

#: ../../../devel/clocks.rst:327
msgid ""
"This function does not return any clock object. The new clock has the same "
"direction (input or output) as the original one. This function only adds a "
"link to the existing clock. In the above example, object B remains the only "
"object allowed to use the clock and device A must not try to change the "
"clock period or set a callback to the clock. This diagram describes the "
"example with an input clock::"
msgstr ""

#: ../../../devel/clocks.rst:334
msgid ""
"+--------------------------+\n"
"|        Device A          |\n"
"|         +--------------+ |\n"
"|         |   Device B   | |\n"
"|         | +-------+    | |\n"
">>\"b_clk\">>>| \"clk\" |    | |\n"
"|  (in)   | |  (in) |    | |\n"
"|         | +-------+    | |\n"
"|         +--------------+ |\n"
"+--------------------------+"
msgstr ""

#: ../../../devel/clocks.rst:346
msgid "Migration"
msgstr ""

#: ../../../devel/clocks.rst:348
msgid ""
"Clock state is not migrated automatically. Every device must handle its "
"clock migration. Alias clocks must not be migrated."
msgstr ""

#: ../../../devel/clocks.rst:351
msgid ""
"To ensure clock states are restored correctly during migration, there are "
"two solutions."
msgstr ""

#: ../../../devel/clocks.rst:354
msgid ""
"Clock states can be migrated by adding an entry into the device vmstate "
"description. You should use the ``VMSTATE_CLOCK`` macro for this. This is "
"typically used to migrate an input clock state. For example:"
msgstr ""

#: ../../../devel/clocks.rst:358
msgid ""
"MyDeviceState {\n"
"    DeviceState parent_obj;\n"
"    [...] /* some fields */\n"
"    Clock *clk;\n"
"};\n"
"\n"
"VMStateDescription my_device_vmstate = {\n"
"    .name = \"my_device\",\n"
"    .fields = (VMStateField[]) {\n"
"        [...], /* other migrated fields */\n"
"        VMSTATE_CLOCK(clk, MyDeviceState),\n"
"        VMSTATE_END_OF_LIST()\n"
"    }\n"
"};"
msgstr ""

#: ../../../devel/clocks.rst:375
msgid ""
"The second solution is to restore the clock state using information already "
"at our disposal. This can be used to restore output clock states using the "
"device state. The functions ``clock_set[_ns|_hz]()`` can be used during the "
"``post_load()`` migration callback."
msgstr ""

#: ../../../devel/clocks.rst:380
msgid ""
"When adding clock support to an existing device, if you care about migration "
"compatibility you will need to be careful, as simply adding a "
"``VMSTATE_CLOCK()`` line will break compatibility. Instead, you can put the "
"``VMSTATE_CLOCK()`` line into a vmstate subsection with a suitable "
"``needed`` function, and use ``clock_set()`` in a ``pre_load()`` function to "
"set the default value that will be used if the source virtual machine in the "
"migration does not send the clock state."
msgstr ""

#: ../../../devel/clocks.rst:389
msgid ""
"Care should be taken not to use ``clock_update[_ns|_hz]()`` or "
"``clock_propagate()`` during the whole migration procedure because it will "
"trigger side effects to other devices in an unknown state."
msgstr ""
