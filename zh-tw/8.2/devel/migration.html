

<!DOCTYPE html>
<html class="writer-html5" lang="zh-TW" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Migration &mdash; QEMU 8.2.10 說明文件</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=7ab3649f" />
      <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css?v=08e6c168" />

  
    <link rel="shortcut icon" href="../_static/qemu_32x32.png"/>
    <link rel="canonical" href="https://projects.localizethedocs.org/qemu-docs-l10n/devel/migration.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=155ab4ff"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=cbf116e0"></script>
      <script src="../_static/custom.js?v=2ab9f71d"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="Multi-process QEMU" href="multi-process.html" />
    <link rel="prev" title="eBPF RSS virtio-net support" href="ebpf_rss.html" />
 
<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >

          
          
          <a href="../index.html" class="icon icon-home">
            QEMU
              <img src="../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目次：</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">關於 QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">系統仿真</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">使用者模式仿真</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">開發者資訊</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index-process.html">QEMU Community Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-build.html">QEMU Build and Test System</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-api.html">Internal QEMU APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index-internals.html">Internal Subsystem Information</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="qom.html">The QEMU Object Model (QOM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomics.html">Atomic operations in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="block-coroutine-wrapper.html">block-coroutine-wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="clocks.html">Modelling a clock tree in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="ebpf_rss.html">eBPF RSS virtio-net support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Migration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#transports">Transports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugging">Debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#common-infrastructure">Common infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#saving-the-state-of-one-device">Saving the state of one device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stream-structure">Stream structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dirty-limit">Dirty limit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#postcopy">Postcopy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#firmware">韌體</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backwards-compatibility">Backwards compatibility</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="multi-process.html">Multi-process QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset in QEMU: the Resettable interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-cpu-topology.html">QAPI interface for S390 CPU topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-dasd-ipl.html">Booting from real channel-attached devices on s390x</a></li>
<li class="toctree-l3"><a class="reference internal" href="tracing.html">Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfio-migration.html">VFIO device Migration</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing-monitor-commands.html">How to write monitor commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="virtio-backends.html">Writing VirtIO backends for QEMU</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index-tcg.html">TCG 仿真</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #802400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QEMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">開發者資訊</a></li>
          <li class="breadcrumb-item"><a href="index-internals.html">Internal Subsystem Information</a></li>
      <li class="breadcrumb-item active">Migration</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://gitlab.com/qemu-project/qemu/blob/master/docs/devel/migration.rst" class="fa fa-gitlab"> Edit on GitLab</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="migration">
<h1><a class="toc-backref" href="#id2" role="doc-backlink">Migration</a><a class="headerlink" href="#migration" title="連結到這個標頭"></a></h1>
<p>QEMU has code to load/save the state of the guest that it is running.
These are two complementary operations.  Saving the state just does
that, saves the state for each device that the guest is running.
Restoring a guest is just the opposite operation: we need to load the
state of each device.</p>
<p>For this to work, QEMU has to be launched with the same arguments the
two times.  I.e. it can only restore the state in one guest that has
the same devices that the one it was saved (this last requirement can
be relaxed a bit, but for now we can consider that configuration has
to be exactly the same).</p>
<p>Once that we are able to save/restore a guest, a new functionality is
requested: migration.  This means that QEMU is able to start in one
machine and being &quot;migrated&quot; to another machine.  I.e. being moved to
another machine.</p>
<p>Next was the &quot;live migration&quot; functionality.  This is important
because some guests run with a lot of state (specially RAM), and it
can take a while to move all state from one machine to another.  Live
migration allows the guest to continue running while the state is
transferred.  Only while the last part of the state is transferred has
the guest to be stopped.  Typically the time that the guest is
unresponsive during live migration is the low hundred of milliseconds
(notice that this depends on a lot of things).</p>
<nav class="contents" id="id1">
<p class="topic-title">目錄</p>
<ul class="simple">
<li><p><a class="reference internal" href="#migration" id="id2">Migration</a></p>
<ul>
<li><p><a class="reference internal" href="#transports" id="id3">Transports</a></p></li>
<li><p><a class="reference internal" href="#debugging" id="id4">Debugging</a></p></li>
<li><p><a class="reference internal" href="#common-infrastructure" id="id5">Common infrastructure</a></p></li>
<li><p><a class="reference internal" href="#saving-the-state-of-one-device" id="id6">Saving the state of one device</a></p>
<ul>
<li><p><a class="reference internal" href="#general-advice-for-device-developers" id="id7">General advice for device developers</a></p></li>
<li><p><a class="reference internal" href="#vmstate" id="id8">VMState</a></p></li>
<li><p><a class="reference internal" href="#legacy-way" id="id9">Legacy way</a></p></li>
<li><p><a class="reference internal" href="#changing-migration-data-structures" id="id10">Changing migration data structures</a></p></li>
<li><p><a class="reference internal" href="#subsections" id="id11">Subsections</a></p></li>
<li><p><a class="reference internal" href="#connecting-subsections-to-properties" id="id12">Connecting subsections to properties</a></p></li>
<li><p><a class="reference internal" href="#not-sending-existing-elements" id="id13">Not sending existing elements</a></p></li>
<li><p><a class="reference internal" href="#versions" id="id14">Versions</a></p></li>
<li><p><a class="reference internal" href="#massaging-functions" id="id15">Massaging functions</a></p></li>
<li><p><a class="reference internal" href="#iterative-device-migration" id="id16">Iterative device migration</a></p></li>
<li><p><a class="reference internal" href="#device-ordering" id="id17">Device ordering</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#stream-structure" id="id18">Stream structure</a></p>
<ul>
<li><p><a class="reference internal" href="#return-path" id="id19">Return path</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#dirty-limit" id="id20">Dirty limit</a></p></li>
<li><p><a class="reference internal" href="#postcopy" id="id21">Postcopy</a></p>
<ul>
<li><p><a class="reference internal" href="#enabling-postcopy" id="id22">Enabling postcopy</a></p></li>
<li><p><a class="reference internal" href="#postcopy-device-transfer" id="id23">Postcopy device transfer</a></p></li>
<li><p><a class="reference internal" href="#source-behaviour" id="id24">Source behaviour</a></p></li>
<li><p><a class="reference internal" href="#destination-behaviour" id="id25">Destination behaviour</a></p></li>
<li><p><a class="reference internal" href="#postcopy-recovery" id="id26">Postcopy Recovery</a></p></li>
<li><p><a class="reference internal" href="#postcopy-states" id="id27">Postcopy states</a></p></li>
<li><p><a class="reference internal" href="#source-side-page-map" id="id28">Source side page map</a></p></li>
<li><p><a class="reference internal" href="#postcopy-with-hugepages" id="id29">Postcopy with hugepages</a></p></li>
<li><p><a class="reference internal" href="#postcopy-with-shared-memory" id="id30">Postcopy with shared memory</a></p></li>
<li><p><a class="reference internal" href="#postcopy-preemption-mode" id="id31">Postcopy Preemption Mode</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#firmware" id="id32">韌體</a></p></li>
<li><p><a class="reference internal" href="#backwards-compatibility" id="id33">Backwards compatibility</a></p>
<ul>
<li><p><a class="reference internal" href="#how-backwards-compatibility-works" id="id34">How backwards compatibility works</a></p></li>
<li><p><a class="reference internal" href="#a-device-with-different-features-on-both-sides" id="id35">A device with different features on both sides</a></p></li>
<li><p><a class="reference internal" href="#how-to-mitigate-when-we-have-a-backward-compatibility-error" id="id36">How to mitigate when we have a backward compatibility error</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="transports">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Transports</a><a class="headerlink" href="#transports" title="連結到這個標頭"></a></h2>
<p>The migration stream is normally just a byte stream that can be passed
over any transport.</p>
<ul class="simple">
<li><p>tcp migration: do the migration using tcp sockets</p></li>
<li><p>unix migration: do the migration using unix sockets</p></li>
<li><p>exec migration: do the migration using the stdin/stdout through a process.</p></li>
<li><p>fd migration: do the migration using a file descriptor that is
passed to QEMU.  QEMU doesn't care how this file descriptor is opened.</p></li>
</ul>
<p>In addition, support is included for migration using RDMA, which
transports the page data using <code class="docutils literal notranslate"><span class="pre">RDMA</span></code>, where the hardware takes care of
transporting the pages, and the load on the CPU is much lower.  While the
internals of RDMA migration are a bit different, this isn't really visible
outside the RAM migration code.</p>
<p>All these migration protocols use the same infrastructure to
save/restore state devices.  This infrastructure is shared with the
savevm/loadvm functionality.</p>
</section>
<section id="debugging">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Debugging</a><a class="headerlink" href="#debugging" title="連結到這個標頭"></a></h2>
<p>The migration stream can be analyzed thanks to <code class="docutils literal notranslate"><span class="pre">scripts/analyze-migration.py</span></code>.</p>
<p>Example usage:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-x86_64<span class="w"> </span>-display<span class="w"> </span>none<span class="w"> </span>-monitor<span class="w"> </span>stdio
<span class="o">(</span>qemu<span class="o">)</span><span class="w"> </span>migrate<span class="w"> </span><span class="s2">&quot;exec:cat &gt; mig&quot;</span>
<span class="o">(</span>qemu<span class="o">)</span><span class="w"> </span>q
$<span class="w"> </span>./scripts/analyze-migration.py<span class="w"> </span>-f<span class="w"> </span>mig
<span class="o">{</span>
<span class="w">  </span><span class="s2">&quot;ram (3)&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">      </span><span class="s2">&quot;section sizes&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">          </span><span class="s2">&quot;pc.ram&quot;</span>:<span class="w"> </span><span class="s2">&quot;0x0000000008000000&quot;</span>,
...
</pre></div>
</div>
<p>See also <code class="docutils literal notranslate"><span class="pre">analyze-migration.py</span> <span class="pre">-h</span></code> help for more options.</p>
</section>
<section id="common-infrastructure">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Common infrastructure</a><a class="headerlink" href="#common-infrastructure" title="連結到這個標頭"></a></h2>
<p>The files, sockets or fd's that carry the migration stream are abstracted by
the  <code class="docutils literal notranslate"><span class="pre">QEMUFile</span></code> type (see <code class="docutils literal notranslate"><span class="pre">migration/qemu-file.h</span></code>).  In most cases this
is connected to a subtype of <code class="docutils literal notranslate"><span class="pre">QIOChannel</span></code> (see <code class="docutils literal notranslate"><span class="pre">io/</span></code>).</p>
</section>
<section id="saving-the-state-of-one-device">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Saving the state of one device</a><a class="headerlink" href="#saving-the-state-of-one-device" title="連結到這個標頭"></a></h2>
<p>For most devices, the state is saved in a single call to the migration
infrastructure; these are <em>non-iterative</em> devices.  The data for these
devices is sent at the end of precopy migration, when the CPUs are paused.
There are also <em>iterative</em> devices, which contain a very large amount of
data (e.g. RAM or large tables).  See the iterative device section below.</p>
<section id="general-advice-for-device-developers">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">General advice for device developers</a><a class="headerlink" href="#general-advice-for-device-developers" title="連結到這個標頭"></a></h3>
<ul class="simple">
<li><p>The migration state saved should reflect the device being modelled rather
than the way your implementation works.  That way if you change the implementation
later the migration stream will stay compatible.  That model may include
internal state that's not directly visible in a register.</p></li>
<li><p>When saving a migration stream the device code may walk and check
the state of the device.  These checks might fail in various ways (e.g.
discovering internal state is corrupt or that the guest has done something bad).
Consider carefully before asserting/aborting at this point, since the
normal response from users is that <em>migration broke their VM</em> since it had
apparently been running fine until then.  In these error cases, the device
should log a message indicating the cause of error, and should consider
putting the device into an error state, allowing the rest of the VM to
continue execution.</p></li>
<li><p>The migration might happen at an inconvenient point,
e.g. right in the middle of the guest reprogramming the device, during
guest reboot or shutdown or while the device is waiting for external IO.
It's strongly preferred that migrations do not fail in this situation,
since in the cloud environment migrations might happen automatically to
VMs that the administrator doesn't directly control.</p></li>
<li><p>If you do need to fail a migration, ensure that sufficient information
is logged to identify what went wrong.</p></li>
<li><p>The destination should treat an incoming migration stream as hostile
(which we do to varying degrees in the existing code).  Check that offsets
into buffers and the like can't cause overruns.  Fail the incoming migration
in the case of a corrupted stream like this.</p></li>
<li><p>Take care with internal device state or behaviour that might become
migration version dependent.  For example, the order of PCI capabilities
is required to stay constant across migration.  Another example would
be that a special case handled by subsections (see below) might become
much more common if a default behaviour is changed.</p></li>
<li><p>The state of the source should not be changed or destroyed by the
outgoing migration.  Migrations timing out or being failed by
higher levels of management, or failures of the destination host are
not unusual, and in that case the VM is restarted on the source.
Note that the management layer can validly revert the migration
even though the QEMU level of migration has succeeded as long as it
does it before starting execution on the destination.</p></li>
<li><p>Buses and devices should be able to explicitly specify addresses when
instantiated, and management tools should use those.  For example,
when hot adding USB devices it's important to specify the ports
and addresses, since implicit ordering based on the command line order
may be different on the destination.  This can result in the
device state being loaded into the wrong device.</p></li>
</ul>
</section>
<section id="vmstate">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">VMState</a><a class="headerlink" href="#vmstate" title="連結到這個標頭"></a></h3>
<p>Most device data can be described using the <code class="docutils literal notranslate"><span class="pre">VMSTATE</span></code> macros (mostly defined
in <code class="docutils literal notranslate"><span class="pre">include/migration/vmstate.h</span></code>).</p>
<p>An example (from hw/input/pckbd.c)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">VMStateDescription</span><span class="w"> </span><span class="n">vmstate_kbd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pckbd&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">version_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">minimum_version_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">VMStateField</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">VMSTATE_UINT8</span><span class="p">(</span><span class="n">write_cmd</span><span class="p">,</span><span class="w"> </span><span class="n">KBDState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_UINT8</span><span class="p">(</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">KBDState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_UINT8</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">KBDState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_UINT8</span><span class="p">(</span><span class="n">pending</span><span class="p">,</span><span class="w"> </span><span class="n">KBDState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_END_OF_LIST</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We are declaring the state with name &quot;pckbd&quot;.  The <code class="docutils literal notranslate"><span class="pre">version_id</span></code> is
3, and there are 4 uint8_t fields in the KBDState structure.  We
registered this <code class="docutils literal notranslate"><span class="pre">VMSTATEDescription</span></code> with one of the following
functions.  The first one will generate a device <code class="docutils literal notranslate"><span class="pre">instance_id</span></code>
different for each registration.  Use the second one if you already
have an id that is different for each instance of the device:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">vmstate_register_any</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmstate_kbd</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="n">vmstate_register</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">instance_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmstate_kbd</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>For devices that are <code class="docutils literal notranslate"><span class="pre">qdev</span></code> based, we can register the device in the class
init function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dc</span><span class="o">-&gt;</span><span class="n">vmsd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmstate_kbd_isa</span><span class="p">;</span>
</pre></div>
</div>
<p>The VMState macros take care of ensuring that the device data section
is formatted portably (normally big endian) and make some compile time checks
against the types of the fields in the structures.</p>
<p>VMState macros can include other VMStateDescriptions to store substructures
(see <code class="docutils literal notranslate"><span class="pre">VMSTATE_STRUCT_</span></code>), arrays (<code class="docutils literal notranslate"><span class="pre">VMSTATE_ARRAY_</span></code>) and variable length
arrays (<code class="docutils literal notranslate"><span class="pre">VMSTATE_VARRAY_</span></code>).  Various other macros exist for special
cases.</p>
<p>Note that the format on the wire is still very raw; i.e. a VMSTATE_UINT32
ends up with a 4 byte bigendian representation on the wire; in the future
it might be possible to use a more structured format.</p>
</section>
<section id="legacy-way">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Legacy way</a><a class="headerlink" href="#legacy-way" title="連結到這個標頭"></a></h3>
<p>This way is going to disappear as soon as all current users are ported to VMSTATE;
although converting existing code can be tricky, and thus 'soon' is relative.</p>
<p>Each device has to register two functions, one to save the state and
another to load the state back.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">register_savevm_live</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">idstr</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">instance_id</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">version_id</span><span class="p">,</span>
<span class="w">                         </span><span class="n">SaveVMHandlers</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">opaque</span><span class="p">);</span>
</pre></div>
</div>
<p>Two functions in the <code class="docutils literal notranslate"><span class="pre">ops</span></code> structure are the <code class="docutils literal notranslate"><span class="pre">save_state</span></code>
and <code class="docutils literal notranslate"><span class="pre">load_state</span></code> functions.  Notice that <code class="docutils literal notranslate"><span class="pre">load_state</span></code> receives a version_id
parameter to know what state format is receiving.  <code class="docutils literal notranslate"><span class="pre">save_state</span></code> doesn't
have a version_id parameter because it always uses the latest version.</p>
<p>Note that because the VMState macros still save the data in a raw
format, in many cases it's possible to replace legacy code
with a carefully constructed VMState description that matches the
byte layout of the existing code.</p>
</section>
<section id="changing-migration-data-structures">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Changing migration data structures</a><a class="headerlink" href="#changing-migration-data-structures" title="連結到這個標頭"></a></h3>
<p>When we migrate a device, we save/load the state as a series
of fields.  Sometimes, due to bugs or new functionality, we need to
change the state to store more/different information.  Changing the migration
state saved for a device can break migration compatibility unless
care is taken to use the appropriate techniques.  In general QEMU tries
to maintain forward migration compatibility (i.e. migrating from
QEMU n-&gt;n+1) and there are users who benefit from backward compatibility
as well.</p>
</section>
<section id="subsections">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Subsections</a><a class="headerlink" href="#subsections" title="連結到這個標頭"></a></h3>
<p>The most common structure change is adding new data, e.g. when adding
a newer form of device, or adding that state that you previously
forgot to migrate.  This is best solved using a subsection.</p>
<p>A subsection is &quot;like&quot; a device vmstate, but with a particularity, it
has a Boolean function that tells if that values are needed to be sent
or not.  If this functions returns false, the subsection is not sent.
Subsections have a unique name, that is looked for on the receiving
side.</p>
<p>On the receiving side, if we found a subsection for a device that we
don't understand, we just fail the migration.  If we understand all
the subsections, then we load the state with success.  There's no check
that a subsection is loaded, so a newer QEMU that knows about a subsection
can (with care) load a stream from an older QEMU that didn't send
the subsection.</p>
<p>If the new data is only needed in a rare case, then the subsection
can be made conditional on that case and the migration will still
succeed to older QEMUs in most cases.  This is OK for data that's
critical, but in some use cases it's preferred that the migration
should succeed even with the data missing.  To support this the
subsection can be connected to a device property and from there
to a versioned machine type.</p>
<p>The 'pre_load' and 'post_load' functions on subsections are only
called if the subsection is loaded.</p>
<p>One important note is that the outer post_load() function is called &quot;after&quot;
loading all subsections, because a newer subsection could change the same
value that it uses.  A flag, and the combination of outer pre_load and
post_load can be used to detect whether a subsection was loaded, and to
fall back on default behaviour when the subsection isn't present.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">ide_drive_pio_state_needed</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">IDEState</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opaque</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">DRQ_STAT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">error_status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BM_STATUS_PIO_RETRY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">VMStateDescription</span><span class="w"> </span><span class="n">vmstate_ide_drive_pio_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ide_drive/pio_state&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">version_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">minimum_version_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">pre_save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_drive_pio_pre_save</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">post_load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_drive_pio_post_load</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">needed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_drive_pio_state_needed</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">VMStateField</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">VMSTATE_INT32</span><span class="p">(</span><span class="n">req_nb_sectors</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_VARRAY_INT32</span><span class="p">(</span><span class="n">io_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">,</span><span class="w"> </span><span class="n">io_buffer_total_len</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                             </span><span class="n">vmstate_info_uint8</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_INT32</span><span class="p">(</span><span class="n">cur_io_buffer_offset</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_INT32</span><span class="p">(</span><span class="n">cur_io_buffer_len</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_UINT8</span><span class="p">(</span><span class="n">end_transfer_fn_idx</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_INT32</span><span class="p">(</span><span class="n">elementary_transfer_size</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_INT32</span><span class="p">(</span><span class="n">packet_transfer_size</span><span class="p">,</span><span class="w"> </span><span class="n">IDEState</span><span class="p">),</span>
<span class="w">        </span><span class="n">VMSTATE_END_OF_LIST</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">const</span><span class="w"> </span><span class="n">VMStateDescription</span><span class="w"> </span><span class="n">vmstate_ide_drive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ide_drive&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">version_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">minimum_version_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">post_load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ide_drive_post_load</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">VMStateField</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">....</span><span class="w"> </span><span class="n">several</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="p">....</span>
<span class="w">        </span><span class="n">VMSTATE_END_OF_LIST</span><span class="p">()</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">.</span><span class="n">subsections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VMStateDescription</span><span class="o">*</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">vmstate_ide_drive_pio_state</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have a subsection for the pio state.  We only need to
save/send this state when we are in the middle of a pio operation
(that is what <code class="docutils literal notranslate"><span class="pre">ide_drive_pio_state_needed()</span></code> checks).  If DRQ_STAT is
not enabled, the values on that fields are garbage and don't need to
be sent.</p>
</section>
<section id="connecting-subsections-to-properties">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Connecting subsections to properties</a><a class="headerlink" href="#connecting-subsections-to-properties" title="連結到這個標頭"></a></h3>
<p>Using a condition function that checks a 'property' to determine whether
to send a subsection allows backward migration compatibility when
new subsections are added, especially when combined with versioned
machine types.</p>
<p>For example:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Add a new property using <code class="docutils literal notranslate"><span class="pre">DEFINE_PROP_BOOL</span></code> - e.g. support-foo and
default it to true.</p></li>
<li><p>Add an entry to the <code class="docutils literal notranslate"><span class="pre">hw_compat_</span></code> for the previous version that sets
the property to false.</p></li>
<li><p>Add a static bool  support_foo function that tests the property.</p></li>
<li><p>Add a subsection with a .needed set to the support_foo function</p></li>
<li><p>(potentially) Add an outer pre_load that sets up a default value
for 'foo' to be used if the subsection isn't loaded.</p></li>
</ol>
</div></blockquote>
<p>Now that subsection will not be generated when using an older
machine type and the migration stream will be accepted by older
QEMU versions.</p>
</section>
<section id="not-sending-existing-elements">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Not sending existing elements</a><a class="headerlink" href="#not-sending-existing-elements" title="連結到這個標頭"></a></h3>
<p>Sometimes members of the VMState are no longer needed:</p>
<blockquote>
<div><ul class="simple">
<li><p>removing them will break migration compatibility</p></li>
<li><p>making them version dependent and bumping the version will break backward migration
compatibility.</p></li>
</ul>
</div></blockquote>
<p>Adding a dummy field into the migration stream is normally the best way to preserve
compatibility.</p>
<p>If the field really does need to be removed then:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Add a new property/compatibility/function in the same way for subsections above.</p></li>
<li><p>replace the VMSTATE macro with the _TEST version of the macro, e.g.:</p></li>
</ol>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">VMSTATE_UINT32(foo,</span> <span class="pre">barstruct)</span></code></p>
<p>becomes</p>
<p><code class="docutils literal notranslate"><span class="pre">VMSTATE_UINT32_TEST(foo,</span> <span class="pre">barstruct,</span> <span class="pre">pre_version_baz)</span></code></p>
<p>Sometime in the future when we no longer care about the ancient versions these can be killed off.
Note that for backward compatibility it's important to fill in the structure with
data that the destination will understand.</p>
</div></blockquote>
</div></blockquote>
<p>Any difference in the predicates on the source and destination will end up
with different fields being enabled and data being loaded into the wrong
fields; for this reason conditional fields like this are very fragile.</p>
</section>
<section id="versions">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Versions</a><a class="headerlink" href="#versions" title="連結到這個標頭"></a></h3>
<p>Version numbers are intended for major incompatible changes to the
migration of a device, and using them breaks backward-migration
compatibility; in general most changes can be made by adding Subsections
(see above) or _TEST macros (see above) which won't break compatibility.</p>
<p>Each version is associated with a series of fields saved.  The <code class="docutils literal notranslate"><span class="pre">save_state</span></code> always saves
the state as the newer version.  But <code class="docutils literal notranslate"><span class="pre">load_state</span></code> sometimes is able to
load state from an older version.</p>
<p>You can see that there are two version fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">version_id</span></code>: the maximum version_id supported by VMState for that device.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">minimum_version_id</span></code>: the minimum version_id that VMState is able to understand
for that device.</p></li>
</ul>
<p>VMState is able to read versions from minimum_version_id to version_id.</p>
<p>There are <em>_V</em> forms of many <code class="docutils literal notranslate"><span class="pre">VMSTATE_</span></code> macros to load fields for version dependent fields,
e.g.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">VMSTATE_UINT16_V</span><span class="p">(</span><span class="n">ip_id</span><span class="p">,</span><span class="w"> </span><span class="n">Slirp</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
</pre></div>
</div>
<p>only loads that field for versions 2 and newer.</p>
<p>Saving state will always create a section with the 'version_id' value
and thus can't be loaded by any older QEMU.</p>
</section>
<section id="massaging-functions">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Massaging functions</a><a class="headerlink" href="#massaging-functions" title="連結到這個標頭"></a></h3>
<p>Sometimes, it is not enough to be able to save the state directly
from one structure, we need to fill the correct values there.  One
example is when we are using kvm.  Before saving the cpu state, we
need to ask kvm to copy to QEMU the state that it is using.  And the
opposite when we are loading the state, we need a way to tell kvm to
load the state for the cpu that we have just loaded from the QEMUFile.</p>
<p>The functions to do that are inside a vmstate definition, and are called:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*pre_load)(void</span> <span class="pre">*opaque);</span></code></p>
<p>This function is called before we load the state of one device.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*post_load)(void</span> <span class="pre">*opaque,</span> <span class="pre">int</span> <span class="pre">version_id);</span></code></p>
<p>This function is called after we load the state of one device.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*pre_save)(void</span> <span class="pre">*opaque);</span></code></p>
<p>This function is called before we save the state of one device.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*post_save)(void</span> <span class="pre">*opaque);</span></code></p>
<p>This function is called after we save the state of one device
(even upon failure, unless the call to pre_save returned an error).</p>
</li>
</ul>
<p>Example: You can look at hpet.c, that uses the first three functions
to massage the state that is transferred.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VMSTATE_WITH_TMP</span></code> macro may be useful when the migration
data doesn't match the stored device data well; it allows an
intermediate temporary structure to be populated with migration
data and then transferred to the main structure.</p>
<p>If you use memory API functions that update memory layout outside
initialization (i.e., in response to a guest action), this is a strong
indication that you need to call these functions in a <code class="docutils literal notranslate"><span class="pre">post_load</span></code> callback.
Examples of such memory API functions are:</p>
<blockquote>
<div><ul class="simple">
<li><p>memory_region_add_subregion()</p></li>
<li><p>memory_region_del_subregion()</p></li>
<li><p>memory_region_set_readonly()</p></li>
<li><p>memory_region_set_readonly()</p></li>
<li><p>memory_region_set_enabled()</p></li>
<li><p>memory_region_set_address()</p></li>
<li><p>memory_region_set_alias_offset()</p></li>
</ul>
</div></blockquote>
</section>
<section id="iterative-device-migration">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Iterative device migration</a><a class="headerlink" href="#iterative-device-migration" title="連結到這個標頭"></a></h3>
<p>Some devices, such as RAM, Block storage or certain platform devices,
have large amounts of data that would mean that the CPUs would be
paused for too long if they were sent in one section.  For these
devices an <em>iterative</em> approach is taken.</p>
<p>The iterative devices generally don't use VMState macros
(although it may be possible in some cases) and instead use
qemu_put_*/qemu_get_* macros to read/write data to the stream.  Specialist
versions exist for high bandwidth IO.</p>
<p>An iterative device must provide:</p>
<blockquote>
<div><ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">save_setup</span></code> function that initialises the data structures and
transmits a first section containing information on the device.  In the
case of RAM this transmits a list of RAMBlocks and sizes.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">load_setup</span></code> function that initialises the data structures on the
destination.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">state_pending_exact</span></code> function that indicates how much more
data we must save.  The core migration code will use this to
determine when to pause the CPUs and complete the migration.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">state_pending_estimate</span></code> function that indicates how much more
data we must save.  When the estimated amount is smaller than the
threshold, we call <code class="docutils literal notranslate"><span class="pre">state_pending_exact</span></code>.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">save_live_iterate</span></code> function should send a chunk of data until
the point that stream bandwidth limits tell it to stop.  Each call
generates one section.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">save_live_complete_precopy</span></code> function that must transmit the
last section for the device containing any remaining data.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">load_state</span></code> function used to load sections generated by
any of the save functions that generate sections.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cleanup</span></code> functions for both save and load that are called
at the end of migration.</p></li>
</ul>
</div></blockquote>
<p>Note that the contents of the sections for iterative migration tend
to be open-coded by the devices; care should be taken in parsing
the results and structuring the stream to make them easy to validate.</p>
</section>
<section id="device-ordering">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Device ordering</a><a class="headerlink" href="#device-ordering" title="連結到這個標頭"></a></h3>
<p>There are cases in which the ordering of device loading matters; for
example in some systems where a device may assert an interrupt during loading,
if the interrupt controller is loaded later then it might lose the state.</p>
<p>Some ordering is implicitly provided by the order in which the machine
definition creates devices, however this is somewhat fragile.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MigrationPriority</span></code> enum provides a means of explicitly enforcing
ordering.  Numerically higher priorities are loaded earlier.
The priority is set by setting the <code class="docutils literal notranslate"><span class="pre">priority</span></code> field of the top level
<code class="docutils literal notranslate"><span class="pre">VMStateDescription</span></code> for the device.</p>
</section>
</section>
<section id="stream-structure">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Stream structure</a><a class="headerlink" href="#stream-structure" title="連結到這個標頭"></a></h2>
<p>The stream tries to be word and endian agnostic, allowing migration between hosts
of different characteristics running the same VM.</p>
<blockquote>
<div><ul>
<li><p>Header</p>
<ul>
<li><p>Magic</p></li>
<li><p>Version</p></li>
<li><p>VM configuration section</p>
<blockquote>
<div><ul class="simple">
<li><p>Machine type</p></li>
<li><p>Target page bits</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</li>
<li><p>List of sections
Each section contains a device, or one iteration of a device save.</p>
<ul class="simple">
<li><p>section type</p></li>
<li><p>section id</p></li>
<li><p>ID string (First section of each device)</p></li>
<li><p>instance id (First section of each device)</p></li>
<li><p>version id (First section of each device)</p></li>
<li><p>&lt;device data&gt;</p></li>
<li><p>Footer mark</p></li>
</ul>
</li>
<li><p>EOF mark</p></li>
<li><p>VM Description structure
Consisting of a JSON description of the contents for analysis only</p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">device</span> <span class="pre">data</span></code> in each section consists of the data produced
by the code described above.  For non-iterative devices they have a single
section; iterative devices have an initial and last section and a set
of parts in between.
Note that there is very little checking by the common code of the integrity
of the <code class="docutils literal notranslate"><span class="pre">device</span> <span class="pre">data</span></code> contents, that's up to the devices themselves.
The <code class="docutils literal notranslate"><span class="pre">footer</span> <span class="pre">mark</span></code> provides a little bit of protection for the case where
the receiving side reads more or less data than expected.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ID</span> <span class="pre">string</span></code> is normally unique, having been formed from a bus name
and device address, PCI devices and storage devices hung off PCI controllers
fit this pattern well.  Some devices are fixed single instances (e.g. &quot;pc-ram&quot;).
Others (especially either older devices or system devices which for
some reason don't have a bus concept) make use of the <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">id</span></code>
for otherwise identically named devices.</p>
<section id="return-path">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Return path</a><a class="headerlink" href="#return-path" title="連結到這個標頭"></a></h3>
<p>Only a unidirectional stream is required for normal migration, however a
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">path</span></code> can be created when bidirectional communication is desired.
This is primarily used by postcopy, but is also used to return a success
flag to the source at the end of migration.</p>
<p><code class="docutils literal notranslate"><span class="pre">qemu_file_get_return_path(QEMUFile*</span> <span class="pre">fwdpath)</span></code> gives the QEMUFile* for the return
path.</p>
<blockquote>
<div><p>Source side</p>
<blockquote>
<div><p>Forward path - written by migration thread
Return path  - opened by main thread, read by return-path thread</p>
</div></blockquote>
<p>Destination side</p>
<blockquote>
<div><p>Forward path - read by main thread
Return path  - opened by main thread, written by main thread AND postcopy
thread (protected by rp_mutex)</p>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="dirty-limit">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Dirty limit</a><a class="headerlink" href="#dirty-limit" title="連結到這個標頭"></a></h2>
<p>The dirty limit, short for dirty page rate upper limit, is a new capability
introduced in the 8.1 QEMU release that uses a new algorithm based on the KVM
dirty ring to throttle down the guest during live migration.</p>
<p>The algorithm framework is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">------------------------------------------------------------------------------</span>
<span class="n">main</span>   <span class="o">--------------&gt;</span> <span class="n">throttle</span> <span class="n">thread</span> <span class="o">------------&gt;</span> <span class="n">PREPARE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;--------</span>
<span class="n">thread</span>  \                                                <span class="o">|</span>              <span class="o">|</span>
         \                                               <span class="o">|</span>              <span class="o">|</span>
          \                                              <span class="n">V</span>              <span class="o">|</span>
           <span class="o">-</span>\                                        <span class="n">CALCULATE</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="o">|</span>
             \                                           <span class="o">|</span>              <span class="o">|</span>
              \                                          <span class="o">|</span>              <span class="o">|</span>
               \                                         <span class="n">V</span>              <span class="o">|</span>
                \                                    <span class="n">SET</span> <span class="n">PENALTY</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-----</span>
                 <span class="o">-</span>\                                      <span class="o">|</span>
                   \                                     <span class="o">|</span>
                    \                                    <span class="n">V</span>
                     <span class="o">-&gt;</span> <span class="n">virtual</span> <span class="n">CPU</span> <span class="n">thread</span> <span class="o">-------&gt;</span> <span class="n">ACCEPT</span> <span class="n">PENALTY</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">------------------------------------------------------------------------------</span>
</pre></div>
</div>
<p>When the qmp command qmp_set_vcpu_dirty_limit is called for the first time,
the QEMU main thread starts the throttle thread. The throttle thread, once
launched, executes the loop, which consists of three steps:</p>
<blockquote>
<div><ul>
<li><p>PREPARE (1)</p>
<blockquote>
<div><p>The entire work of PREPARE (1) is preparation for the second stage,
CALCULATE(2), as the name implies. It involves preparing the dirty
page rate value and the corresponding upper limit of the VM:
The dirty page rate is calculated via the KVM dirty ring mechanism,
which tells QEMU how many dirty pages a virtual CPU has had since the
last KVM_EXIT_DIRTY_RING_FULL exception; The dirty page rate upper
limit is specified by caller, therefore fetch it directly.</p>
</div></blockquote>
</li>
<li><p>CALCULATE (2)</p>
<blockquote>
<div><p>Calculate a suitable sleep period for each virtual CPU, which will be
used to determine the penalty for the target virtual CPU. The
computation must be done carefully in order to reduce the dirty page
rate progressively down to the upper limit without oscillation. To
achieve this, two strategies are provided: the first is to add or
subtract sleep time based on the ratio of the current dirty page rate
to the limit, which is used when the current dirty page rate is far
from the limit; the second is to add or subtract a fixed time when
the current dirty page rate is close to the limit.</p>
</div></blockquote>
</li>
<li><p>SET PENALTY (3)</p>
<blockquote>
<div><p>Set the sleep time for each virtual CPU that should be penalized based
on the results of the calculation supplied by step CALCULATE (2).</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>After completing the three above stages, the throttle thread loops back
to step PREPARE (1) until the dirty limit is reached.</p>
<p>On the other hand, each virtual CPU thread reads the sleep duration and
sleeps in the path of the KVM_EXIT_DIRTY_RING_FULL exception handler, that
is ACCEPT PENALTY (4). Virtual CPUs tied with writing processes will
obviously exit to the path and get penalized, whereas virtual CPUs involved
with read processes will not.</p>
<p>In summary, thanks to the KVM dirty ring technology, the dirty limit
algorithm will restrict virtual CPUs as needed to keep their dirty page
rate inside the limit. This leads to more steady reading performance during
live migration and can aid in improving large guest responsiveness.</p>
</section>
<section id="postcopy">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Postcopy</a><a class="headerlink" href="#postcopy" title="連結到這個標頭"></a></h2>
<p>'Postcopy' migration is a way to deal with migrations that refuse to converge
(or take too long to converge) its plus side is that there is an upper bound on
the amount of migration traffic and time it takes, the down side is that during
the postcopy phase, a failure of <em>either</em> side causes the guest to be lost.</p>
<p>In postcopy the destination CPUs are started before all the memory has been
transferred, and accesses to pages that are yet to be transferred cause
a fault that's translated by QEMU into a request to the source QEMU.</p>
<p>Postcopy can be combined with precopy (i.e. normal migration) so that if precopy
doesn't finish in a given time the switch is made to postcopy.</p>
<section id="enabling-postcopy">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Enabling postcopy</a><a class="headerlink" href="#enabling-postcopy" title="連結到這個標頭"></a></h3>
<p>To enable postcopy, issue this command on the monitor (both source and
destination) prior to the start of migration:</p>
<p><code class="docutils literal notranslate"><span class="pre">migrate_set_capability</span> <span class="pre">postcopy-ram</span> <span class="pre">on</span></code></p>
<p>The normal commands are then used to start a migration, which is still
started in precopy mode.  Issuing:</p>
<p><code class="docutils literal notranslate"><span class="pre">migrate_start_postcopy</span></code></p>
<p>will now cause the transition from precopy to postcopy.
It can be issued immediately after migration is started or any
time later on.  Issuing it after the end of a migration is harmless.</p>
<p>Blocktime is a postcopy live migration metric, intended to show how
long the vCPU was in state of interruptible sleep due to pagefault.
That metric is calculated both for all vCPUs as overlapped value, and
separately for each vCPU. These values are calculated on destination
side.  To enable postcopy blocktime calculation, enter following
command on destination monitor:</p>
<p><code class="docutils literal notranslate"><span class="pre">migrate_set_capability</span> <span class="pre">postcopy-blocktime</span> <span class="pre">on</span></code></p>
<p>Postcopy blocktime can be retrieved by query-migrate qmp command.
postcopy-blocktime value of qmp command will show overlapped blocking
time for all vCPU, postcopy-vcpu-blocktime will show list of blocking
time per vCPU.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>During the postcopy phase, the bandwidth limits set using
<code class="docutils literal notranslate"><span class="pre">migrate_set_parameter</span></code> is ignored (to avoid delaying requested pages that
the destination is waiting for).</p>
</div>
</section>
<section id="postcopy-device-transfer">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Postcopy device transfer</a><a class="headerlink" href="#postcopy-device-transfer" title="連結到這個標頭"></a></h3>
<p>Loading of device data may cause the device emulation to access guest RAM
that may trigger faults that have to be resolved by the source, as such
the migration stream has to be able to respond with page data <em>during</em> the
device load, and hence the device data has to be read from the stream completely
before the device load begins to free the stream up.  This is achieved by
'packaging' the device data into a blob that's read in one go.</p>
</section>
<section id="source-behaviour">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Source behaviour</a><a class="headerlink" href="#source-behaviour" title="連結到這個標頭"></a></h3>
<p>Until postcopy is entered the migration stream is identical to normal
precopy, except for the addition of a 'postcopy advise' command at
the beginning, to tell the destination that postcopy might happen.
When postcopy starts the source sends the page discard data and then
forms the 'package' containing:</p>
<blockquote>
<div><ul>
<li><p>Command: 'postcopy listen'</p></li>
<li><p>The device state</p>
<p>A series of sections, identical to the precopy streams device state stream
containing everything except postcopiable devices (i.e. RAM)</p>
</li>
<li><p>Command: 'postcopy run'</p></li>
</ul>
</div></blockquote>
<p>The 'package' is sent as the data part of a Command: <code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code>, and the
contents are formatted in the same way as the main migration stream.</p>
<p>During postcopy the source scans the list of dirty pages and sends them
to the destination without being requested (in much the same way as precopy),
however when a page request is received from the destination, the dirty page
scanning restarts from the requested location.  This causes requested pages
to be sent quickly, and also causes pages directly after the requested page
to be sent quickly in the hope that those pages are likely to be used
by the destination soon.</p>
</section>
<section id="destination-behaviour">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Destination behaviour</a><a class="headerlink" href="#destination-behaviour" title="連結到這個標頭"></a></h3>
<p>Initially the destination looks the same as precopy, with a single thread
reading the migration stream; the 'postcopy advise' and 'discard' commands
are processed to change the way RAM is managed, but don't affect the stream
processing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">------------------------------------------------------------------------------</span>
                        <span class="mi">1</span>      <span class="mi">2</span>   <span class="mi">3</span>     <span class="mi">4</span> <span class="mi">5</span>                      <span class="mi">6</span>   <span class="mi">7</span>
<span class="n">main</span> <span class="o">-----</span><span class="n">DISCARD</span><span class="o">-</span><span class="n">CMD_PACKAGED</span> <span class="p">(</span> <span class="n">LISTEN</span>  <span class="n">DEVICE</span>     <span class="n">DEVICE</span> <span class="n">DEVICE</span> <span class="n">RUN</span> <span class="p">)</span>
<span class="n">thread</span>                             <span class="o">|</span>       <span class="o">|</span>
                                   <span class="o">|</span>     <span class="p">(</span><span class="n">page</span> <span class="n">request</span><span class="p">)</span>
                                   <span class="o">|</span>        \<span class="n">___</span>
                                   <span class="n">v</span>            \
<span class="n">listen</span> <span class="n">thread</span><span class="p">:</span>                     <span class="o">---</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span>

                                   <span class="n">a</span>   <span class="n">b</span>        <span class="n">c</span>
<span class="o">------------------------------------------------------------------------------</span>
</pre></div>
</div>
<ul>
<li><p>On receipt of <code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code> (1)</p>
<blockquote>
<div><p>All the data associated with the package - the ( ... ) section in the diagram -
is read into memory, and the main thread recurses into qemu_loadvm_state_main
to process the contents of the package (2) which contains commands (3,6) and
devices (4...)</p>
</div></blockquote>
</li>
<li><p>On receipt of 'postcopy listen' - 3 -(i.e. the 1st command in the package)</p>
<blockquote>
<div><p>a new thread (a) is started that takes over servicing the migration stream,
while the main thread carries on loading the package.   It loads normal
background page data (b) but if during a device load a fault happens (5)
the returned page (c) is loaded by the listen thread allowing the main
threads device load to carry on.</p>
</div></blockquote>
</li>
<li><p>The last thing in the <code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code> is a 'RUN' command (6)</p>
<blockquote>
<div><p>letting the destination CPUs start running.  At the end of the
<code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code> (7) the main thread returns to normal running behaviour and
is no longer used by migration, while the listen thread carries on servicing
page data until the end of migration.</p>
</div></blockquote>
</li>
</ul>
</section>
<section id="postcopy-recovery">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Postcopy Recovery</a><a class="headerlink" href="#postcopy-recovery" title="連結到這個標頭"></a></h3>
<p>Comparing to precopy, postcopy is special on error handlings.  When any
error happens (in this case, mostly network errors), QEMU cannot easily
fail a migration because VM data resides in both source and destination
QEMU instances.  On the other hand, when issue happens QEMU on both sides
will go into a paused state.  It'll need a recovery phase to continue a
paused postcopy migration.</p>
<p>The recovery phase normally contains a few steps:</p>
<blockquote>
<div><ul class="simple">
<li><p>When network issue occurs, both QEMU will go into PAUSED state</p></li>
<li><p>When the network is recovered (or a new network is provided), the admin
can setup the new channel for migration using QMP command
'migrate-recover' on destination node, preparing for a resume.</p></li>
<li><p>On source host, the admin can continue the interrupted postcopy
migration using QMP command 'migrate' with resume=true flag set.</p></li>
<li><p>After the connection is re-established, QEMU will continue the postcopy
migration on both sides.</p></li>
</ul>
</div></blockquote>
<p>During a paused postcopy migration, the VM can logically still continue
running, and it will not be impacted from any page access to pages that
were already migrated to destination VM before the interruption happens.
However, if any of the missing pages got accessed on destination VM, the VM
thread will be halted waiting for the page to be migrated, it means it can
be halted until the recovery is complete.</p>
<p>The impact of accessing missing pages can be relevant to different
configurations of the guest.  For example, when with async page fault
enabled, logically the guest can proactively schedule out the threads
accessing missing pages.</p>
</section>
<section id="postcopy-states">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Postcopy states</a><a class="headerlink" href="#postcopy-states" title="連結到這個標頭"></a></h3>
<p>Postcopy moves through a series of states (see postcopy_state) from
ADVISE-&gt;DISCARD-&gt;LISTEN-&gt;RUNNING-&gt;END</p>
<blockquote>
<div><ul>
<li><p>Advise</p>
<blockquote>
<div><p>Set at the start of migration if postcopy is enabled, even
if it hasn't had the start command; here the destination
checks that its OS has the support needed for postcopy, and performs
setup to ensure the RAM mappings are suitable for later postcopy.
The destination will fail early in migration at this point if the
required OS support is not present.
(Triggered by reception of POSTCOPY_ADVISE command)</p>
</div></blockquote>
</li>
<li><p>Discard</p>
<blockquote>
<div><p>Entered on receipt of the first 'discard' command; prior to
the first Discard being performed, hugepages are switched off
(using madvise) to ensure that no new huge pages are created
during the postcopy phase, and to cause any huge pages that
have discards on them to be broken.</p>
</div></blockquote>
</li>
<li><p>Listen</p>
<blockquote>
<div><p>The first command in the package, POSTCOPY_LISTEN, switches
the destination state to Listen, and starts a new thread
(the 'listen thread') which takes over the job of receiving
pages off the migration stream, while the main thread carries
on processing the blob.  With this thread able to process page
reception, the destination now 'sensitises' the RAM to detect
any access to missing pages (on Linux using the 'userfault'
system).</p>
</div></blockquote>
</li>
<li><p>Running</p>
<blockquote>
<div><p>POSTCOPY_RUN causes the destination to synchronise all
state and start the CPUs and IO devices running.  The main
thread now finishes processing the migration package and
now carries on as it would for normal precopy migration
(although it can't do the cleanup it would do as it
finishes a normal migration).</p>
</div></blockquote>
</li>
<li><p>Paused</p>
<blockquote>
<div><p>Postcopy can run into a paused state (normally on both sides when
happens), where all threads will be temporarily halted mostly due to
network errors.  When reaching paused state, migration will make sure
the qemu binary on both sides maintain the data without corrupting
the VM.  To continue the migration, the admin needs to fix the
migration channel using the QMP command 'migrate-recover' on the
destination node, then resume the migration using QMP command 'migrate'
again on source node, with resume=true flag set.</p>
</div></blockquote>
</li>
<li><p>End</p>
<blockquote>
<div><p>The listen thread can now quit, and perform the cleanup of migration
state, the migration is now complete.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="source-side-page-map">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Source side page map</a><a class="headerlink" href="#source-side-page-map" title="連結到這個標頭"></a></h3>
<p>The 'migration bitmap' in postcopy is basically the same as in the precopy,
where each of the bit to indicate that page is 'dirty' - i.e. needs
sending.  During the precopy phase this is updated as the CPU dirties
pages, however during postcopy the CPUs are stopped and nothing should
dirty anything any more. Instead, dirty bits are cleared when the relevant
pages are sent during postcopy.</p>
</section>
<section id="postcopy-with-hugepages">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Postcopy with hugepages</a><a class="headerlink" href="#postcopy-with-hugepages" title="連結到這個標頭"></a></h3>
<p>Postcopy now works with hugetlbfs backed memory:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>The linux kernel on the destination must support userfault on hugepages.</p></li>
<li><p>The huge-page configuration on the source and destination VMs must be
identical; i.e. RAMBlocks on both sides must use the same page size.</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">-mem-path</span> <span class="pre">/dev/hugepages</span></code>  will fall back to allocating normal
RAM if it doesn't have enough hugepages, triggering (b) to fail.
Using <code class="docutils literal notranslate"><span class="pre">-mem-prealloc</span></code> enforces the allocation using hugepages.</p></li>
<li><p>Care should be taken with the size of hugepage used; postcopy with 2MB
hugepages works well, however 1GB hugepages are likely to be problematic
since it takes ~1 second to transfer a 1GB hugepage across a 10Gbps link,
and until the full page is transferred the destination thread is blocked.</p></li>
</ol>
</div></blockquote>
</section>
<section id="postcopy-with-shared-memory">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Postcopy with shared memory</a><a class="headerlink" href="#postcopy-with-shared-memory" title="連結到這個標頭"></a></h3>
<p>Postcopy migration with shared memory needs explicit support from the other
processes that share memory and from QEMU. There are restrictions on the type of
memory that userfault can support shared.</p>
<p>The Linux kernel userfault support works on <code class="docutils literal notranslate"><span class="pre">/dev/shm</span></code> memory and on <code class="docutils literal notranslate"><span class="pre">hugetlbfs</span></code>
(although the kernel doesn't provide an equivalent to <code class="docutils literal notranslate"><span class="pre">madvise(MADV_DONTNEED)</span></code>
for hugetlbfs which may be a problem in some configurations).</p>
<p>The vhost-user code in QEMU supports clients that have Postcopy support,
and the <code class="docutils literal notranslate"><span class="pre">vhost-user-bridge</span></code> (in <code class="docutils literal notranslate"><span class="pre">tests/</span></code>) and the DPDK package have changes
to support postcopy.</p>
<p>The client needs to open a userfaultfd and register the areas
of memory that it maps with userfault.  The client must then pass the
userfaultfd back to QEMU together with a mapping table that allows
fault addresses in the clients address space to be converted back to
RAMBlock/offsets.  The client's userfaultfd is added to the postcopy
fault-thread and page requests are made on behalf of the client by QEMU.
QEMU performs 'wake' operations on the client's userfaultfd to allow it
to continue after a page has arrived.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<dl class="simple">
<dt>There are two future improvements that would be nice:</dt><dd><ol class="loweralpha simple">
<li><p>Some way to make QEMU ignorant of the addresses in the clients
address space</p></li>
<li><p>Avoiding the need for QEMU to perform ufd-wake calls after the
pages have arrived</p></li>
</ol>
</dd>
</dl>
</div>
<dl class="simple">
<dt>Retro-fitting postcopy to existing clients is possible:</dt><dd><ol class="loweralpha simple">
<li><p>A mechanism is needed for the registration with userfault as above,
and the registration needs to be coordinated with the phases of
postcopy.  In vhost-user extra messages are added to the existing
control channel.</p></li>
<li><p>Any thread that can block due to guest memory accesses must be
identified and the implication understood; for example if the
guest memory access is made while holding a lock then all other
threads waiting for that lock will also be blocked.</p></li>
</ol>
</dd>
</dl>
</section>
<section id="postcopy-preemption-mode">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">Postcopy Preemption Mode</a><a class="headerlink" href="#postcopy-preemption-mode" title="連結到這個標頭"></a></h3>
<p>Postcopy preempt is a new capability introduced in 8.0 QEMU release, it
allows urgent pages (those got page fault requested from destination QEMU
explicitly) to be sent in a separate preempt channel, rather than queued in
the background migration channel.  Anyone who cares about latencies of page
faults during a postcopy migration should enable this feature.  By default,
it's not enabled.</p>
</section>
</section>
<section id="firmware">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">韌體</a><a class="headerlink" href="#firmware" title="連結到這個標頭"></a></h2>
<p>Migration migrates the copies of RAM and ROM, and thus when running
on the destination it includes the firmware from the source. Even after
resetting a VM, the old firmware is used.  Only once QEMU has been restarted
is the new firmware in use.</p>
<ul class="simple">
<li><p>Changes in firmware size can cause changes in the required RAMBlock size
to hold the firmware and thus migration can fail.  In practice it's best
to pad firmware images to convenient powers of 2 with plenty of space
for growth.</p></li>
<li><p>Care should be taken with device emulation code so that newer
emulation code can work with older firmware to allow forward migration.</p></li>
<li><p>Care should be taken with newer firmware so that backward migration
to older systems with older device emulation code will work.</p></li>
</ul>
<p>In some cases it may be best to tie specific firmware versions to specific
versioned machine types to cut down on the combinations that will need
support.  This is also useful when newer versions of firmware outgrow
the padding.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#id33" role="doc-backlink">Backwards compatibility</a><a class="headerlink" href="#backwards-compatibility" title="連結到這個標頭"></a></h2>
<section id="how-backwards-compatibility-works">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">How backwards compatibility works</a><a class="headerlink" href="#how-backwards-compatibility-works" title="連結到這個標頭"></a></h3>
<p>When we do migration, we have two QEMU processes: the source and the
target.  There are two cases, they are the same version or they are
different versions.  The easy case is when they are the same version.
The difficult one is when they are different versions.</p>
<p>There are two things that are different, but they have very similar
names and sometimes get confused:</p>
<ul class="simple">
<li><p>QEMU version</p></li>
<li><p>machine type version</p></li>
</ul>
<p>Let's start with a practical example, we start with:</p>
<ul class="simple">
<li><p>qemu-system-x86_64 (v5.2), from now on qemu-5.2.</p></li>
<li><p>qemu-system-x86_64 (v5.1), from now on qemu-5.1.</p></li>
</ul>
<p>Related to this are the &quot;latest&quot; machine types defined on each of
them:</p>
<ul class="simple">
<li><p>pc-q35-5.2 (newer one in qemu-5.2) from now on pc-5.2</p></li>
<li><p>pc-q35-5.1 (newer one in qemu-5.1) from now on pc-5.1</p></li>
</ul>
<p>First of all, migration is only supposed to work if you use the same
machine type in both source and destination. The QEMU hardware
configuration needs to be the same also on source and destination.
Most aspects of the backend configuration can be changed at will,
except for a few cases where the backend features influence frontend
device feature exposure.  But that is not relevant for this section.</p>
<p>I am going to list the number of combinations that we can have.  Let's
start with the trivial ones, QEMU is the same on source and
destination:</p>
<p>1 - qemu-5.2 -M pc-5.2  -&gt; migrates to -&gt; qemu-5.2 -M pc-5.2</p>
<blockquote>
<div><p>This is the latest QEMU with the latest machine type.
This have to work, and if it doesn't work it is a bug.</p>
</div></blockquote>
<p>2 - qemu-5.1 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.1 -M pc-5.1</p>
<blockquote>
<div><p>Exactly the same case than the previous one, but for 5.1.
Nothing to see here either.</p>
</div></blockquote>
<p>This are the easiest ones, we will not talk more about them in this
section.</p>
<p>Now we start with the more interesting cases.  Consider the case where
we have the same QEMU version in both sides (qemu-5.2) but we are using
the latest machine type for that version (pc-5.2) but one of an older
QEMU version, in this case pc-5.1.</p>
<p>3 - qemu-5.2 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.2 -M pc-5.1</p>
<blockquote>
<div><p>It needs to use the definition of pc-5.1 and the devices as they
were configured on 5.1, but this should be easy in the sense that
both sides are the same QEMU and both sides have exactly the same
idea of what the pc-5.1 machine is.</p>
</div></blockquote>
<p>4 - qemu-5.1 -M pc-5.2  -&gt; migrates to -&gt; qemu-5.1 -M pc-5.2</p>
<blockquote>
<div><p>This combination is not possible as the qemu-5.1 doesn't understand
pc-5.2 machine type.  So nothing to worry here.</p>
</div></blockquote>
<p>Now it comes the interesting ones, when both QEMU processes are
different.  Notice also that the machine type needs to be pc-5.1,
because we have the limitation than qemu-5.1 doesn't know pc-5.2.  So
the possible cases are:</p>
<p>5 - qemu-5.2 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.1 -M pc-5.1</p>
<blockquote>
<div><p>This migration is known as newer to older.  We need to make sure
when we are developing 5.2 we need to take care about not to break
migration to qemu-5.1.  Notice that we can't make updates to
qemu-5.1 to understand whatever qemu-5.2 decides to change, so it is
in qemu-5.2 side to make the relevant changes.</p>
</div></blockquote>
<p>6 - qemu-5.1 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.2 -M pc-5.1</p>
<blockquote>
<div><p>This migration is known as older to newer.  We need to make sure
than we are able to receive migrations from qemu-5.1. The problem is
similar to the previous one.</p>
</div></blockquote>
<p>If qemu-5.1 and qemu-5.2 were the same, there will not be any
compatibility problems.  But the reason that we create qemu-5.2 is to
get new features, devices, defaults, etc.</p>
<p>If we get a device that has a new feature, or change a default value,
we have a problem when we try to migrate between different QEMU
versions.</p>
<p>So we need a way to tell qemu-5.2 that when we are using machine type
pc-5.1, it needs to <strong>not</strong> use the feature, to be able to migrate to
real qemu-5.1.</p>
<p>And the equivalent part when migrating from qemu-5.1 to qemu-5.2.
qemu-5.2 has to expect that it is not going to get data for the new
feature, because qemu-5.1 doesn't know about it.</p>
<p>How do we tell QEMU about these device feature changes?  In
hw/core/machine.c:hw_compat_X_Y arrays.</p>
<p>If we change a default value, we need to put back the old value on
that array.  And the device, during initialization needs to look at
that array to see what value it needs to get for that feature.  And
what are we going to put in that array, the value of a property.</p>
<p>To create a property for a device, we need to use one of the
DEFINE_PROP_*() macros. See include/hw/qdev-properties.h to find the
macros that exist.  With it, we set the default value for that
property, and that is what it is going to get in the latest released
version.  But if we want a different value for a previous version, we
can change that in the hw_compat_X_Y arrays.</p>
<p>hw_compat_X_Y is an array of registers that have the format:</p>
<ul class="simple">
<li><p>name_device</p></li>
<li><p>name_property</p></li>
<li><p>value</p></li>
</ul>
<p>Let's see a practical example.</p>
<p>In qemu-5.2 virtio-blk-device got multi queue support.  This is a
change that is not backward compatible.  In qemu-5.1 it has one
queue. In qemu-5.2 it has the same number of queues as the number of
cpus in the system.</p>
<p>When we are doing migration, if we migrate from a device that has 4
queues to a device that have only one queue, we don't know where to
put the extra information for the other 3 queues, and we fail
migration.</p>
<p>Similar problem when we migrate from qemu-5.1 that has only one queue
to qemu-5.2, we only sent information for one queue, but destination
has 4, and we have 3 queues that are not properly initialized and
anything can happen.</p>
<p>So, how can we address this problem.  Easy, just convince qemu-5.2
that when it is running pc-5.1, it needs to set the number of queues
for virtio-blk-devices to 1.</p>
<p>That way we fix the cases 5 and 6.</p>
<p>5 - qemu-5.2 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.1 -M pc-5.1</p>
<blockquote>
<div><p>qemu-5.2 -M pc-5.1 sets number of queues to be 1.
qemu-5.1 -M pc-5.1 expects number of queues to be 1.</p>
<p>correct.  migration works.</p>
</div></blockquote>
<p>6 - qemu-5.1 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.2 -M pc-5.1</p>
<blockquote>
<div><p>qemu-5.1 -M pc-5.1 sets number of queues to be 1.
qemu-5.2 -M pc-5.1 expects number of queues to be 1.</p>
<p>correct.  migration works.</p>
</div></blockquote>
<p>And now the other interesting case, case 3.  In this case we have:</p>
<p>3 - qemu-5.2 -M pc-5.1  -&gt; migrates to -&gt; qemu-5.2 -M pc-5.1</p>
<blockquote>
<div><p>Here we have the same QEMU in both sides.  So it doesn't matter a
lot if we have set the number of queues to 1 or not, because
they are the same.</p>
<p>WRONG!</p>
<p>Think what happens if we do one of this double migrations:</p>
<p>A -&gt; migrates -&gt; B -&gt; migrates -&gt; C</p>
<p>where:</p>
<p>A: qemu-5.1 -M pc-5.1
B: qemu-5.2 -M pc-5.1
C: qemu-5.2 -M pc-5.1</p>
<p>migration A -&gt; B is case 6, so number of queues needs to be 1.</p>
<p>migration B -&gt; C is case 3, so we don't care.  But actually we
care because we haven't started the guest in qemu-5.2, it came
migrated from qemu-5.1.  So to be in the safe place, we need to
always use number of queues 1 when we are using pc-5.1.</p>
</div></blockquote>
<p>Now, how was this done in reality?  The following commit shows how it
was done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">commit</span> <span class="mf">9445e1</span><span class="n">e15e66c19e42bea942ba810db28052cd05</span>
<span class="n">Author</span><span class="p">:</span> <span class="n">Stefan</span> <span class="n">Hajnoczi</span> <span class="o">&lt;</span><span class="n">stefanha</span><span class="nd">@redhat</span><span class="o">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="p">:</span>   <span class="n">Tue</span> <span class="n">Aug</span> <span class="mi">18</span> <span class="mi">15</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">47</span> <span class="mi">2020</span> <span class="o">+</span><span class="mi">0100</span>

<span class="n">virtio</span><span class="o">-</span><span class="n">blk</span><span class="o">-</span><span class="n">pci</span><span class="p">:</span> <span class="n">default</span> <span class="n">num_queues</span> <span class="n">to</span> <span class="o">-</span><span class="n">smp</span> <span class="n">N</span>
</pre></div>
</div>
<p>The relevant parts for migration are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">@@</span> <span class="o">-</span><span class="mi">1281</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">1284</span><span class="p">,</span><span class="mi">8</span> <span class="o">@@</span> <span class="n">static</span> <span class="n">Property</span> <span class="n">virtio_blk_properties</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="c1">#endif</span>
     <span class="n">DEFINE_PROP_BIT</span><span class="p">(</span><span class="s2">&quot;request-merging&quot;</span><span class="p">,</span> <span class="n">VirtIOBlock</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">request_merging</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                     <span class="n">true</span><span class="p">),</span>
<span class="o">-</span>    <span class="n">DEFINE_PROP_UINT16</span><span class="p">(</span><span class="s2">&quot;num-queues&quot;</span><span class="p">,</span> <span class="n">VirtIOBlock</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">num_queues</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="o">+</span>    <span class="n">DEFINE_PROP_UINT16</span><span class="p">(</span><span class="s2">&quot;num-queues&quot;</span><span class="p">,</span> <span class="n">VirtIOBlock</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">num_queues</span><span class="p">,</span>
<span class="o">+</span>                       <span class="n">VIRTIO_BLK_AUTO_NUM_QUEUES</span><span class="p">),</span>
     <span class="n">DEFINE_PROP_UINT16</span><span class="p">(</span><span class="s2">&quot;queue-size&quot;</span><span class="p">,</span> <span class="n">VirtIOBlock</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">queue_size</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
</pre></div>
</div>
<p>It changes the default value of num_queues.  But it fishes it for old
machine types to have the right value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">@@</span> <span class="o">-</span><span class="mi">31</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">31</span><span class="p">,</span><span class="mi">7</span> <span class="o">@@</span>
 <span class="n">GlobalProperty</span> <span class="n">hw_compat_5_1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="o">...</span>
<span class="o">+</span>    <span class="p">{</span> <span class="s2">&quot;virtio-blk-device&quot;</span><span class="p">,</span> <span class="s2">&quot;num-queues&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">},</span>
     <span class="o">...</span>
 <span class="p">};</span>
</pre></div>
</div>
</section>
<section id="a-device-with-different-features-on-both-sides">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">A device with different features on both sides</a><a class="headerlink" href="#a-device-with-different-features-on-both-sides" title="連結到這個標頭"></a></h3>
<p>Let's assume that we are using the same QEMU binary on both sides,
just to make the things easier.  But we have a device that has
different features on both sides of the migration.  That can be
because the devices are different, because the kernel driver of both
devices have different features, whatever.</p>
<p>How can we get this to work with migration.  The way to do that is
&quot;theoretically&quot; easy.  You have to get the features that the device
has in the source of the migration.  The features that the device has
on the target of the migration, you get the intersection of the
features of both sides, and that is the way that you should launch
QEMU.</p>
<p>Notice that this is not completely related to QEMU.  The most
important thing here is that this should be handled by the managing
application that launches QEMU.  If QEMU is configured correctly, the
migration will succeed.</p>
<p>That said, actually doing it is complicated.  Almost all devices are
bad at being able to be launched with only some features enabled.
With one big exception: cpus.</p>
<p>You can read the documentation for QEMU x86 cpu models here:</p>
<p><a class="reference external" href="https://qemu-project.gitlab.io/qemu/system/qemu-cpu-models.html">https://qemu-project.gitlab.io/qemu/system/qemu-cpu-models.html</a></p>
<p>See when they talk about migration they recommend that one chooses the
newest cpu model that is supported for all cpus.</p>
<p>Let's say that we have:</p>
<p>Host A:</p>
<p>Device X has the feature Y</p>
<p>Host B:</p>
<p>Device X has not the feature Y</p>
<p>If we try to migrate without any care from host A to host B, it will
fail because when migration tries to load the feature Y on
destination, it will find that the hardware is not there.</p>
<p>Doing this would be the equivalent of doing with cpus:</p>
<p>Host A:</p>
<p>$ qemu-system-x86_64 -cpu host</p>
<p>Host B:</p>
<p>$ qemu-system-x86_64 -cpu host</p>
<p>When both hosts have different cpu features this is guaranteed to
fail.  Especially if Host B has less features than host A.  If host A
has less features than host B, sometimes it works.  Important word of
last sentence is &quot;sometimes&quot;.</p>
<p>So, forgetting about cpu models and continuing with the -cpu host
example, let's see that the differences of the cpus is that Host A and
B have the following features:</p>
<p>Features:   'pcid'  'stibp' 'taa-no'
Host A:        X       X
Host B:                        X</p>
<p>And we want to migrate between them, the way configure both QEMU cpu
will be:</p>
<p>Host A:</p>
<p>$ qemu-system-x86_64 -cpu host,pcid=off,stibp=off</p>
<p>Host B:</p>
<p>$ qemu-system-x86_64 -cpu host,taa-no=off</p>
<p>And you would be able to migrate between them.  It is responsibility
of the management application or of the user to make sure that the
configuration is correct.  QEMU doesn't know how to look at this kind
of features in general.</p>
<p>Notice that we don't recommend to use -cpu host for migration.  It is
used in this example because it makes the example simpler.</p>
<p>Other devices have worse control about individual features.  If they
want to be able to migrate between hosts that show different features,
the device needs a way to configure which ones it is going to use.</p>
<p>In this section we have considered that we are using the same QEMU
binary in both sides of the migration.  If we use different QEMU
versions process, then we need to have into account all other
differences and the examples become even more complicated.</p>
</section>
<section id="how-to-mitigate-when-we-have-a-backward-compatibility-error">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">How to mitigate when we have a backward compatibility error</a><a class="headerlink" href="#how-to-mitigate-when-we-have-a-backward-compatibility-error" title="連結到這個標頭"></a></h3>
<p>We broke migration for old machine types continuously during
development.  But as soon as we find that there is a problem, we fix
it.  The problem is what happens when we detect after we have done a
release that something has gone wrong.</p>
<p>Let see how it worked with one example.</p>
<p>After the release of qemu-8.0 we found a problem when doing migration
of the machine type pc-7.2.</p>
<ul>
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2</p>
<p>This migration works</p>
</li>
<li><p>$ qemu-8.0 -M pc-7.2  -&gt;  qemu-8.0 -M pc-7.2</p>
<p>This migration works</p>
</li>
<li><p>$ qemu-8.0 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2</p>
<p>This migration fails</p>
</li>
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-8.0 -M pc-7.2</p>
<p>This migration fails</p>
</li>
</ul>
<p>So clearly something fails when migration between qemu-7.2 and
qemu-8.0 with machine type pc-7.2.  The error messages, and git bisect
pointed to this commit.</p>
<p>In qemu-8.0 we got this commit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">commit</span> <span class="mi">010746</span><span class="n">ae1db7f52700cb2e2c46eb94f299cfa0d2</span>
<span class="n">Author</span><span class="p">:</span> <span class="n">Jonathan</span> <span class="n">Cameron</span> <span class="o">&lt;</span><span class="n">Jonathan</span><span class="o">.</span><span class="n">Cameron</span><span class="nd">@huawei</span><span class="o">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="p">:</span>   <span class="n">Thu</span> <span class="n">Mar</span> <span class="mi">2</span> <span class="mi">13</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">02</span> <span class="mi">2023</span> <span class="o">+</span><span class="mi">0000</span>

<span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">aer</span><span class="p">:</span> <span class="n">Implement</span> <span class="n">PCI_ERR_UNCOR_MASK</span> <span class="n">register</span>
</pre></div>
</div>
<p>The relevant bits of the commit for our example are this ones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">---</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pcie_aer</span><span class="o">.</span><span class="n">c</span>
<span class="o">+++</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pcie_aer</span><span class="o">.</span><span class="n">c</span>
<span class="o">@@</span> <span class="o">-</span><span class="mi">112</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">112</span><span class="p">,</span><span class="mi">10</span> <span class="o">@@</span> <span class="nb">int</span> <span class="n">pcie_aer_init</span><span class="p">(</span><span class="n">PCIDevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>

     <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">w1cmask</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_STATUS</span><span class="p">,</span>
                  <span class="n">PCI_ERR_UNC_SUPPORTED</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span>
<span class="o">+</span>                 <span class="n">PCI_ERR_UNC_MASK_DEFAULT</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wmask</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span>
<span class="o">+</span>                 <span class="n">PCI_ERR_UNC_SUPPORTED</span><span class="p">);</span>

     <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_SEVER</span><span class="p">,</span>
                 <span class="n">PCI_ERR_UNC_SEVERITY_DEFAULT</span><span class="p">);</span>
</pre></div>
</div>
<p>The patch changes how we configure PCI space for AER.  But QEMU fails
when the PCI space configuration is different between source and
destination.</p>
<p>The following commit shows how this got fixed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">commit</span> <span class="mi">5</span><span class="n">ed3dabe57dd9f4c007404345e5f5bf0e347317f</span>
<span class="n">Author</span><span class="p">:</span> <span class="n">Leonardo</span> <span class="n">Bras</span> <span class="o">&lt;</span><span class="n">leobras</span><span class="nd">@redhat</span><span class="o">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="p">:</span>   <span class="n">Tue</span> <span class="n">May</span> <span class="mi">2</span> <span class="mi">21</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">02</span> <span class="mi">2023</span> <span class="o">-</span><span class="mi">0300</span>

<span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="p">:</span> <span class="n">Disable</span> <span class="n">PCI_ERR_UNCOR_MASK</span> <span class="n">register</span> <span class="k">for</span> <span class="n">machine</span> <span class="nb">type</span> <span class="o">&lt;</span> <span class="mf">8.0</span>

<span class="p">[</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>The relevant parts of the fix in QEMU are as follow:</p>
<p>First, we create a new property for the device to be able to configure
the old behaviour or the new behaviour:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">diff</span> <span class="o">--</span><span class="n">git</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pci</span><span class="o">.</span><span class="n">c</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pci</span><span class="o">.</span><span class="n">c</span>
<span class="n">index</span> <span class="mi">8</span><span class="n">a87ccc8b0</span><span class="o">.</span><span class="mf">.5153</span><span class="n">ad63d6</span> <span class="mi">100644</span>
<span class="o">---</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pci</span><span class="o">.</span><span class="n">c</span>
<span class="o">+++</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pci</span><span class="o">.</span><span class="n">c</span>
<span class="o">@@</span> <span class="o">-</span><span class="mi">79</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">79</span><span class="p">,</span><span class="mi">8</span> <span class="o">@@</span> <span class="n">static</span> <span class="n">Property</span> <span class="n">pci_props</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="n">DEFINE_PROP_STRING</span><span class="p">(</span><span class="s2">&quot;failover_pair_id&quot;</span><span class="p">,</span> <span class="n">PCIDevice</span><span class="p">,</span>
                        <span class="n">failover_pair_id</span><span class="p">),</span>
     <span class="n">DEFINE_PROP_UINT32</span><span class="p">(</span><span class="s2">&quot;acpi-index&quot;</span><span class="p">,</span>  <span class="n">PCIDevice</span><span class="p">,</span> <span class="n">acpi_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="o">+</span>    <span class="n">DEFINE_PROP_BIT</span><span class="p">(</span><span class="s2">&quot;x-pcie-err-unc-mask&quot;</span><span class="p">,</span> <span class="n">PCIDevice</span><span class="p">,</span> <span class="n">cap_present</span><span class="p">,</span>
<span class="o">+</span>                    <span class="n">QEMU_PCIE_ERR_UNC_MASK_BITNR</span><span class="p">,</span> <span class="n">true</span><span class="p">),</span>
     <span class="n">DEFINE_PROP_END_OF_LIST</span><span class="p">()</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>Notice that we enable the feature for new machine types.</p>
<p>Now we see how the fix is done.  This is going to depend on what kind
of breakage happens, but in this case it is quite simple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">diff</span> <span class="o">--</span><span class="n">git</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pcie_aer</span><span class="o">.</span><span class="n">c</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pcie_aer</span><span class="o">.</span><span class="n">c</span>
<span class="n">index</span> <span class="mi">103667</span><span class="n">c368</span><span class="o">.</span><span class="mf">.374</span><span class="n">d593ead</span> <span class="mi">100644</span>
<span class="o">---</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pcie_aer</span><span class="o">.</span><span class="n">c</span>
<span class="o">+++</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">pci</span><span class="o">/</span><span class="n">pcie_aer</span><span class="o">.</span><span class="n">c</span>
<span class="o">@@</span> <span class="o">-</span><span class="mi">112</span><span class="p">,</span><span class="mi">10</span> <span class="o">+</span><span class="mi">112</span><span class="p">,</span><span class="mi">13</span> <span class="o">@@</span> <span class="nb">int</span> <span class="n">pcie_aer_init</span><span class="p">(</span><span class="n">PCIDevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="n">cap_ver</span><span class="p">,</span>
<span class="n">uint16_t</span> <span class="n">offset</span><span class="p">,</span>

     <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">w1cmask</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_STATUS</span><span class="p">,</span>
                  <span class="n">PCI_ERR_UNC_SUPPORTED</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span>
<span class="o">-</span>                 <span class="n">PCI_ERR_UNC_MASK_DEFAULT</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wmask</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span>
<span class="o">-</span>                 <span class="n">PCI_ERR_UNC_SUPPORTED</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cap_present</span> <span class="o">&amp;</span> <span class="n">QEMU_PCIE_ERR_UNC_MASK</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>        <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span>
<span class="o">+</span>                     <span class="n">PCI_ERR_UNC_MASK_DEFAULT</span><span class="p">);</span>
<span class="o">+</span>        <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wmask</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span>
<span class="o">+</span>                     <span class="n">PCI_ERR_UNC_SUPPORTED</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span>

     <span class="n">pci_set_long</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_SEVER</span><span class="p">,</span>
                  <span class="n">PCI_ERR_UNC_SEVERITY_DEFAULT</span><span class="p">);</span>
</pre></div>
</div>
<p>I.e. If the property bit is enabled, we configure it as we did for
qemu-8.0.  If the property bit is not set, we configure it as it was in 7.2.</p>
<p>And now, everything that is missing is disabling the feature for old
machine types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">diff</span> <span class="o">--</span><span class="n">git</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">machine</span><span class="o">.</span><span class="n">c</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">machine</span><span class="o">.</span><span class="n">c</span>
<span class="n">index</span> <span class="mi">47</span><span class="n">a34841a5</span><span class="o">.</span><span class="mf">.07</span><span class="n">f763eb2e</span> <span class="mi">100644</span>
<span class="o">---</span> <span class="n">a</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">machine</span><span class="o">.</span><span class="n">c</span>
<span class="o">+++</span> <span class="n">b</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">machine</span><span class="o">.</span><span class="n">c</span>
<span class="o">@@</span> <span class="o">-</span><span class="mi">48</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">48</span><span class="p">,</span><span class="mi">7</span> <span class="o">@@</span> <span class="n">GlobalProperty</span> <span class="n">hw_compat_7_2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="p">{</span> <span class="s2">&quot;e1000e&quot;</span><span class="p">,</span> <span class="s2">&quot;migrate-timadj&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span> <span class="p">},</span>
     <span class="p">{</span> <span class="s2">&quot;virtio-mem&quot;</span><span class="p">,</span> <span class="s2">&quot;x-early-migration&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span> <span class="p">},</span>
     <span class="p">{</span> <span class="s2">&quot;migration&quot;</span><span class="p">,</span> <span class="s2">&quot;x-preempt-pre-7-2&quot;</span><span class="p">,</span> <span class="s2">&quot;true&quot;</span> <span class="p">},</span>
<span class="o">+</span>    <span class="p">{</span> <span class="n">TYPE_PCI_DEVICE</span><span class="p">,</span> <span class="s2">&quot;x-pcie-err-unc-mask&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span> <span class="p">},</span>
 <span class="p">};</span>
 <span class="n">const</span> <span class="n">size_t</span> <span class="n">hw_compat_7_2_len</span> <span class="o">=</span> <span class="n">G_N_ELEMENTS</span><span class="p">(</span><span class="n">hw_compat_7_2</span><span class="p">);</span>
</pre></div>
</div>
<p>And now, when qemu-8.0.1 is released with this fix, all combinations
are going to work as supposed.</p>
<ul class="simple">
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2 (works)</p></li>
<li><p>$ qemu-8.0.1 -M pc-7.2  -&gt;  qemu-8.0.1 -M pc-7.2 (works)</p></li>
<li><p>$ qemu-8.0.1 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2 (works)</p></li>
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-8.0.1 -M pc-7.2 (works)</p></li>
</ul>
<p>So the normality has been restored and everything is ok, no?</p>
<p>Not really, now our matrix is much bigger.  We started with the easy
cases, migration from the same version to the same version always
works:</p>
<ul class="simple">
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2</p></li>
<li><p>$ qemu-8.0 -M pc-7.2  -&gt;  qemu-8.0 -M pc-7.2</p></li>
<li><p>$ qemu-8.0.1 -M pc-7.2  -&gt;  qemu-8.0.1 -M pc-7.2</p></li>
</ul>
<p>Now the interesting ones.  When the QEMU processes versions are
different.  For the 1st set, their fail and we can do nothing, both
versions are released and we can't change anything.</p>
<ul class="simple">
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-8.0 -M pc-7.2</p></li>
<li><p>$ qemu-8.0 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2</p></li>
</ul>
<p>This two are the ones that work. The whole point of making the
change in qemu-8.0.1 release was to fix this issue:</p>
<ul class="simple">
<li><p>$ qemu-7.2 -M pc-7.2  -&gt;  qemu-8.0.1 -M pc-7.2</p></li>
<li><p>$ qemu-8.0.1 -M pc-7.2  -&gt;  qemu-7.2 -M pc-7.2</p></li>
</ul>
<p>But now we found that qemu-8.0 neither can migrate to qemu-7.2 not
qemu-8.0.1.</p>
<ul class="simple">
<li><p>$ qemu-8.0 -M pc-7.2  -&gt;  qemu-8.0.1 -M pc-7.2</p></li>
<li><p>$ qemu-8.0.1 -M pc-7.2  -&gt;  qemu-8.0 -M pc-7.2</p></li>
</ul>
<p>So, if we start a pc-7.2 machine in qemu-8.0 we can't migrate it to
anything except to qemu-8.0.</p>
<p>Can we do better?</p>
<p>Yeap.  If we know that we are going to do this migration:</p>
<ul class="simple">
<li><p>$ qemu-8.0 -M pc-7.2  -&gt;  qemu-8.0.1 -M pc-7.2</p></li>
</ul>
<p>We can launch the appropriate devices with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span><span class="n">device</span><span class="o">...</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="n">pci</span><span class="o">-</span><span class="n">e</span><span class="o">-</span><span class="n">err</span><span class="o">-</span><span class="n">unc</span><span class="o">-</span><span class="n">mask</span><span class="o">=</span><span class="n">on</span>
</pre></div>
</div>
<p>And now we can receive a migration from 8.0.  And from now on, we can
do that migration to new machine types if we remember to enable that
property for pc-7.2.  Notice that we need to remember, it is not
enough to know that the source of the migration is qemu-8.0.  Think of
this example:</p>
<p>$ qemu-8.0 -M pc-7.2 -&gt; qemu-8.0.1 -M pc-7.2 -&gt; qemu-8.2 -M pc-7.2</p>
<p>In the second migration, the source is not qemu-8.0, but we still have
that &quot;problem&quot; and have that property enabled.  Notice that we need to
continue having this mark/property until we have this machine
rebooted.  But it is not a normal reboot (that don't reload QEMU) we
need the machine to poweroff/poweron on a fixed QEMU.  And from now
on we can use the proper real machine.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ebpf_rss.html" class="btn btn-neutral float-left" title="eBPF RSS virtio-net support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="multi-process.html" class="btn btn-neutral float-right" title="Multi-process QEMU" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, The QEMU Project Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 8.2.</p>


<p><a href="../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>