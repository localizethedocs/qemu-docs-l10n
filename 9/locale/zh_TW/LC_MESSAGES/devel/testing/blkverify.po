# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, The QEMU Project Developers
# This file is distributed under the same license as the QEMU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QEMU 9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 05:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devel/testing/blkverify.rst:2
msgid "Block driver correctness testing with ``blkverify``"
msgstr ""

#: ../../../devel/testing/blkverify.rst:5
msgid "Introduction"
msgstr ""

#: ../../../devel/testing/blkverify.rst:7
msgid ""
"This document describes how to use the ``blkverify`` protocol to test that a "
"block driver is operating correctly."
msgstr ""

#: ../../../devel/testing/blkverify.rst:10
msgid ""
"It is difficult to test and debug block drivers against real guests.  Often "
"processes inside the guest will crash because corrupt sectors were read as "
"part of the executable.  Other times obscure errors are raised by a program "
"inside the guest.  These issues are extremely hard to trace back to bugs in "
"the block driver."
msgstr ""

#: ../../../devel/testing/blkverify.rst:16
msgid ""
"``blkverify`` solves this problem by catching data corruption inside QEMU "
"the first time bad data is read and reporting the disk sector that is "
"corrupted."
msgstr ""

#: ../../../devel/testing/blkverify.rst:20
msgid "How it works"
msgstr ""

#: ../../../devel/testing/blkverify.rst:22
msgid ""
"The ``blkverify`` protocol has two child block devices, the \"test\" device "
"and the \"raw\" device.  Read/write operations are mirrored to both devices "
"so their state should always be in sync."
msgstr ""

#: ../../../devel/testing/blkverify.rst:26
msgid ""
"The \"raw\" device is a raw image, a flat file, that has identical starting "
"contents to the \"test\" image.  The idea is that the \"raw\" device will "
"handle read/write operations correctly and not corrupt data.  It can be used "
"as a reference for comparison against the \"test\" device."
msgstr ""

#: ../../../devel/testing/blkverify.rst:31
msgid ""
"After a mirrored read operation completes, ``blkverify`` will compare the "
"data and raise an error if it is not identical.  This makes it possible to "
"catch the first instance where corrupt data is read."
msgstr ""

#: ../../../devel/testing/blkverify.rst:36
msgid "Example"
msgstr ""

#: ../../../devel/testing/blkverify.rst:38
msgid "Imagine raw.img has 0xcd repeated throughout its first sector::"
msgstr ""

#: ../../../devel/testing/blkverify.rst:40
msgid ""
"$ ./qemu-io -c 'read -v 0 512' raw.img\n"
"00000000:  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd "
"cd  ................\n"
"00000010:  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd "
"cd  ................\n"
"[...]\n"
"000001e0:  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd "
"cd  ................\n"
"000001f0:  cd cd cd cd cd cd cd cd cd cd cd cd cd cd cd "
"cd  ................\n"
"read 512/512 bytes at offset 0\n"
"512.000000 bytes, 1 ops; 0.0000 sec (97.656 MiB/sec and 200000.0000 ops/sec)"
msgstr ""

#: ../../../devel/testing/blkverify.rst:49
msgid ""
"And test.img is corrupt, its first sector is zeroed when it shouldn't be::"
msgstr ""

#: ../../../devel/testing/blkverify.rst:51
msgid ""
"$ ./qemu-io -c 'read -v 0 512' test.img\n"
"00000000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00  ................\n"
"00000010:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00  ................\n"
"[...]\n"
"000001e0:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00  ................\n"
"000001f0:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
"00  ................\n"
"read 512/512 bytes at offset 0\n"
"512.000000 bytes, 1 ops; 0.0000 sec (81.380 MiB/sec and 166666.6667 ops/sec)"
msgstr ""

#: ../../../devel/testing/blkverify.rst:60
msgid "This error is caught by ``blkverify``::"
msgstr ""

#: ../../../devel/testing/blkverify.rst:62
msgid ""
"$ ./qemu-io -c 'read 0 512' blkverify:a.img:b.img\n"
"blkverify: read sector_num=0 nb_sectors=4 contents mismatch in sector 0"
msgstr ""

#: ../../../devel/testing/blkverify.rst:65
msgid "A more realistic scenario is verifying the installation of a guest OS::"
msgstr ""

#: ../../../devel/testing/blkverify.rst:67
msgid ""
"$ ./qemu-img create raw.img 16G\n"
"$ ./qemu-img create -f qcow2 test.qcow2 16G\n"
"$ ./qemu-system-x86_64 -cdrom debian.iso \\\n"
"      -drive file=blkverify:raw.img:test.qcow2"
msgstr ""

#: ../../../devel/testing/blkverify.rst:72
msgid ""
"If the installation is aborted when ``blkverify`` detects corruption, use "
"``qemu-io`` to explore the contents of the disk image at the sector in "
"question."
msgstr ""
